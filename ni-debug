#!/usr/bin/env perl
{

use v5.14;
no strict 'refs';
package ni;
sub ni;
sub ::ni;

sub self {
  join "\n", "#!/usr/bin/env perl",
             q{eval($ni::selfcode = join '', <DATA>); die $@ if $@;},
             "__DATA__",
             $ni::selfcode;
}

use POSIX qw/:sys_wait_h/;

$SIG{CHLD} = sub {
  local ($!, $?);
  waitpid -1, WNOHANG;
};
# Memoized function compilation
our %compiled_functions;

sub expand_function_shorthands {
  my ($code) = @_;
  $code =~ s/%(\d+)/\$_[$1]/g;

  # JSON shortcuts
  1 while $code =~ s/([a-zA-Z0-9_\)\}\]\?\$])
                     \.
                     ([\$_a-zA-Z](?:-[0-9\w\?\$]|[0-9_\w?\$])*)
                    /$1\->{'$2'}/x;
  $code;
}

sub compile {
  return $_[0] if ref $_[0] eq 'CODE';
  return $compiled_functions{$_[0]}
     //= eval "package main; sub {\n" . expand_function_shorthands($_[0])
                                      . "\n}";
}
# Code generator
# This exists because I want gensyms and external references to be easier to
# deal with. It also supports some nice stuff like insertion points and
# peephole optimizations.

BEGIN {

sub ni::gen::new;
sub gen       { local $_; ni::gen->new(@_) }
sub gen_empty { gen('empty', {}, '') }

sub gen_seq {
  # Generates an imperative sequence of statements.
  my ($name, @statements) = @_;
  my $code_template = join "\n", map "%\@x$_;", 0 .. $#statements;
  my %subst;
  $subst{"x$_"} = $statements[$_] for 0 .. $#statements;
  gen $name, {%subst}, $code_template;
}

{

package ni::gen;

use overload qw# %  subst  * map  @{} inserted_code_keys  "" compile
                 eq compile_equals #;

our $gensym_id = 0;
sub gensym { '$_' . ($_[0] // '') . '_' . $gensym_id++ . '__gensym' }

our $gen_id = 0;

sub parse_signature {
  return $_[0] if ref $_[0];
  my ($first, @stuff) = split /\s*;\s*/, $_[0];
  my ($desc, $type)   = split /\s*:\s*/, $first;
  my $result = {description => $desc,
                type        => [split /\s*->\s*/, $type]};

  /^(\S+)\s*=\s*(.*)$/ and $$result{$1} = $2 for @stuff;
  $result;
}

sub parse_code;
sub new {
  my ($class, $sig, $refs, $code) = @_;
  my ($fragments, $gensym_indexes, $insertions) = parse_code $code;

  # Substitutions can be specified as refs, in which case we pull them out and
  # do a rewrite automatically (this is more notationally expedient than having
  # to do a % operation right away).
  my %subst;
  for (keys %$refs) {
    if (exists $$insertions{$_}) {
      $subst{$_} = $$refs{$_};
      delete $$refs{$_};
    }
  }

  exists $$gensym_indexes{$_} or die "unknown ref $_ in $code" for keys %$refs;
  exists $$refs{$_}           or die  "unused ref $_ in $code"
    for keys %$gensym_indexes;

  # NB: always copy the fragments because parse_code returns cached results
  bless({ id                => ++$gen_id,
          sig               => parse_signature $sig,
          fragments         => $fragments,
          gensym_names      => {map {$_, undef} keys %$gensym_indexes},
          gensym_indexes    => $gensym_indexes,
          insertion_indexes => $insertions,
          refs              => $refs // {} },
        $class) % {%subst};
}

sub copy {
  my ($self) = @_;
  my %new = %$self;
  $new{id}           = ++$gen_id;
  $new{sig}          = {%{$new{sig}}};
  $new{fragments}    = [@{$new{fragments}}];
  $new{gensym_names} = {%{$new{gensym_names}}};

  bless(\%new, ref $self)->replace_gensyms(
    {map {$_, gensym $_} keys %{$new{gensym_names}}});
}

sub replace_gensyms {
  my ($self, $replacements) = @_;
  for (keys %$replacements) {
    if (exists $$self{gensym_names}{$_}) {
      my $is = $$self{gensym_indexes}{$_};
      my $g  = $$self{gensym_names}{$_} = $$replacements{$_};
      $$self{fragments}[$_] = $g for @$is;
    }
  }
  $self;
}

sub genify {
  return $_[0] if ref $_[0] && $_[0]->isa('ni::gen');
  return ni::gen('genified', {}, $_[0]);
}

sub compile_equals {
  my ($self, $x) = @_;
  $x = $x->compile if ref $x;
  $self->compile eq $x;
}

sub share_gensyms_with {
  # Any intersecting gensyms from $g will be renamed to align with $self.
  # This directionality matters so multiple calls against $self will form a set
  # of mutually gensym-shared fragments.
  my ($self, $g) = @_;
  $self->replace_gensyms($$g{gensym_names});
}

sub inherit_gensyms_from {
  $_[1]->share_gensyms_with($_[0]);
  $_[0];
}

sub build_ref_hash {
  my ($self, $refs) = @_;
  $refs //= {};
  $$refs{$$self{gensym_names}{$_}} = $$self{refs}{$_} for keys %{$$self{refs}};
  $$self{fragments}[$$self{insertion_indexes}{$_}[0]]->build_ref_hash($refs)
    for @$self;
  $refs;
}

sub inserted_code_keys {
  my ($self) = @_;
  [sort keys %{$$self{insertion_indexes}}];
}

sub subst_in_place {
  my ($self, $vars) = @_;
  for my $k (keys %$vars) {
    my $is = $$self{insertion_indexes}{$k};
    die "unknown subst var: $k (code is $self)" unless defined $is;
    my $f = genify $$vars{$k};
    $$self{fragments}[$_] = $f for @$is;
  }
  $self;
}

sub subst {
  my ($self, $vars) = @_;
  $self->copy->subst_in_place($vars);
}

sub map {
  my ($self, $f) = @_;
  $f = ni::compile $f;
  my $y = &$f($self);
  return $y unless $y eq $self;

  # If we haven't changed, then operate independently on the
  # already-substituted code fragments and build a new instance.
  my $new = bless {}, ref $self;
  $$new{$_} = $$self{$_} for keys %$self;
  $$new{fragments} = [@{$$new{fragments}}];

  $new % {map {$_, $$new{fragments}[$$new{insertion_indexes}{$_}] * $f} @$new};
}

sub debug_to_string {
  # Don't use this to compile; use ->compile() instead.
  my ($self) = @_;
  my $refs = $self->build_ref_hash;

  my $code_string = join '',
    map ref $_ eq 'ARRAY'   ? "<UNBOUND: $$_[0]>"
      : ref $_ eq 'ni::gen' ? $_->debug_to_string
                            : $_,
        @{$$self{fragments}};

  my $ref_string = join ', ', map "$_: $$refs{$_}", sort keys %$refs;
  "[$$self{id} $$self{sig} {$ref_string}\n$code_string]";
}

sub compile {
  my ($self) = @_;
  ref $_ eq 'ARRAY' && die "cannot compile underdetermined gen $self"
    for @{$$self{fragments}};
  join '', @{$$self{fragments}};
}

sub lexical_definitions {
  my ($self, $refs) = @_;
  $refs //= $self->build_ref_hash;
  ni::gen "lexicals", {},
    join "\n", map sprintf("my %s = \$_[0]->{'%s'};", $_, $_), keys %$refs;
}

sub compile_to_sub {
  my ($self) = @_;
  my $code     = $self->compile;
  my $refs     = $self->build_ref_hash;
  my $bindings = $self->lexical_definitions($refs);
  my $f        = eval($code = "package main; sub {\n$bindings\n$code\n}");
  die "$@ compiling\n$code" if $@;
  ($f, $refs);
}

sub run {
  my ($self) = @_;
  my ($f, $refs) = $self->compile_to_sub;
  my @result = &$f($refs);
  delete $$refs{$_} for keys %$refs;    # we create circular refs sometimes
  @result;
}

our %parsed_code_cache;
sub parse_code {
  # Returns ([@code_fragments], {gensym_indexes}, {insertion_indexes})
  my ($code) = @_;
  my $cached;
  unless (defined($cached = $parsed_code_cache{$code})) {
    my @pieces = split /(\%:\w+|\%\@\w+)/, $code;
    my @fragments;
    my %gensym_indexes;
    my %insertion_indexes;
    for (0 .. $#pieces) {
      if ($pieces[$_] =~ /^\%:(\w+)$/) {
        push @{$gensym_indexes{$1} //= []}, $_;
        push @fragments, undef;
      } elsif ($pieces[$_] =~ /^\%\@(\w+)$/) {
        push @{$insertion_indexes{$1} //= []}, $_;
        push @fragments, [$1];
      } else {
        push @fragments, $pieces[$_];
      }
    }
    $cached = $parsed_code_cache{$code} = [[@fragments],
                                           {%gensym_indexes},
                                           {%insertion_indexes}];
  }
  @$cached;
}

}

}
# Type-tracked code fragments
# ni data functions typically receive a list of arguments corresponding to
# tab-delimited values, but file data is read line by line. We could convert
# every function's output to a line string and reparse for the next function,
# but this is quite slow and unnecessary. Instead, we track the type of each
# code element and do conversions only when appropriate.
#
# This model gives us the ability to optimize a bit further: calling
# split(/\t/) is actually quite slow compared to pulling fields out using
# index() and relying on substr() to do aliasing. So at this point we have two
# possible representations:
#
# 1. Fields stored in @_, which is what we'll have after a function call
# 2. Field positions stored in index variables, accessed using substr()
#
# We aren't done quite yet. We also sometimes have situations where we're
# dealing with flatmapped output from a function, and we want to be able to
# return multiple rows each with multiple columns. Perl references are a
# performance disaster, so we instead pack everything into a single array with
# bundles prefixed by length:
#
# (3, 'foo', 'bar', 'bif', 1, 'bif')  ->  foo   bar   bif
#                                         baz
#
# This gives us a third representation, packed-arrays.
#
# There's still more we can do. In some cases we can tell which fields are
# accessed by a function. If the function supplying data generates more fields
# (particularly in the packed-array case), we can sometimes modify it to return
# fewer values. This matters because Perl copies strings when you move them
# between arrays. So, for example, if we have a situation like this:
#
# flatmap sub { (row(a, b, c), row(d, e, f)) }
# map     sub { %0 + %1 }
#
# we don't actually need to emit a packed array at all; the row() function can
# contain the map code and the resulting type ends up being a series of single
# values. The flatmap function must end up calling row() since otherwise it
# would have no way to emit a packed array in the first place.
#
# Perl code can't be type-inferred beyond doing something simple like scanning
# for various field references. Even if we could use a combination of operator
# overloading and CORE shadowing to get a symbolic form of some chunk of code
# (which is tempting), we'd run into problems anytime that code made any call
# to something external -- particularly native code.
#
# Given that, we can make the following assumptions:
#
# 1. We can find the set of fields a function uses, though not what it does
#    with them. Sometimes a function will use the field array, but we'll know
#    this too.
# 2. In some (known) cases, the function must use some explicit return function
#    like row() -- and we'll need to be able to rewrite this with our own
#    custom function.

# TODO
# Extensible IO stream abstraction
# Streams are defined by the Perl code that runs in order to put their values
# somewhere. This abstraction ends up getting completely erased at runtime,
# which is good because Perl OO is really slow.
#
# If you want to construct one of these and use it for IO purposes, the fastest
# option should be to get a filehandle for it first:
#
# my $fh = $ni_io->into_fh;
# while (<$fh>) {
#   ...
# }
#
# my $fh = $ni_io->from_fh;
# print $fh "foo bar\n";
#
# This will fork the compiled code into a separate process, which is still
# usually faster than the abstraction otherwise required.

our %io_constructors;

sub is_io { ref $_[0] && $_[0]->isa('ni::io') }

sub defio {
  my ($name, $constructor, $methods) = @_;
  *{"ni::io::${name}::new"} = $io_constructors{$name} = sub {
    my ($class, @args) = @_;
    bless $constructor->(@args), $class;
  };
  *{"::ni_$name"} = *{"ni::ni_$name"} =
    sub { ${"ni::io::${name}::"}{new}("ni::io::$name", @_) };
  *{"ni::io::$name::$_"} = $methods->{$_} for keys %$methods;
  push @{"ni::io::${name}::ISA"}, 'ni::io';
}

sub defioproxy {
  my ($name, $f) = @_;
  *{"::ni_$name"} = *{"ni::ni_$name"} = $f;
}

sub mapone_binding;
sub flatmap_binding;
sub reduce_binding;
sub grep_binding;
sub pipe_binding;

# Internally we're using these IO objects to generate imperative code, so it's
# going to be source-driven. This means we can't do much until we know where
# the values need to go (though we can defer that by fork/piping).

{

package ni::io;
use overload qw# + plus_op  * mapone_op  / reduce_op  % grep_op  | pipe_op
                 eq compare_refs
                 "" explain
                 >>= bind_op
                 > into  >= into_bg
                 < from  <= from_bg #;

use Scalar::Util qw/refaddr/;

BEGIN { *gen = \&ni::gen }

use POSIX qw/dup2/;

# Methods implemented by children
sub source_gen { ... }          # gen to source from this thing
sub sink_gen   { ... }          # gen to sink into this thing
sub explain    { ... }

sub transform {
  my ($self, $f) = @_;
  $f->($self);
}

sub reader_fh { (::ni_pipe() <= $_[0])->reader_fh }
sub writer_fh { (::ni_pipe() >= $_[0])->writer_fh }

sub has_reader_fh { 0 }
sub has_writer_fh { 0 }

sub supports_reads  { 1 }
sub supports_writes { 0 }

sub flatten { ($_[0]) }
sub close   { $_[0] }

# Transforms
sub plus_op   { $_[0]->plus($_[1]) }
sub bind_op   { $_[0]->bind($_[1]) }
sub mapone_op { $_[0]->mapone($_[1]) }
sub reduce_op { $_[0]->reduce($_[1], {}) }
sub grep_op   { $_[0]->grep($_[1]) }
sub pipe_op   { $_[0]->pipe($_[1]) }

sub plus    { ::ni_sum(@_) }
sub bind    { ::ni_bind(@_) }
sub mapone  { $_[0] >>= ni::mapone_binding  @_[1..$#_] }
sub flatmap { $_[0] >>= ni::flatmap_binding @_[1..$#_] }
sub reduce  { $_[0] >>= ni::reduce_binding  @_[1..$#_] }
sub grep    { $_[0] >>= ni::grep_binding    @_[1..$#_] }
sub pipe    { ::ni_process($_[1], $_[0], undef) }

sub compare_refs { refaddr($_[0]) eq refaddr($_[1]) }

# User-facing methods
sub from {
  my ($self, $source) = @_;
  ::ni($source)->source_gen($self)->run;
  $self;
}

sub from_bg {
  my ($self, $source) = @_;
  $self < $source, exit unless fork;
  $self;
}

sub into {
  my ($self, $dest) = @_;
  $self->source_gen(::ni $dest)->run;
  $self;
}

sub into_bg {
  my ($self, $dest) = @_;
  $self > $dest, exit unless fork;
  $self;
}

}
# Data source definitions
BEGIN {
  our @data_names;
  our %data_matchers;
  our %data_transformers;

  sub defdata {
    my ($name, $matcher, $transfomer) = @_;
    die "data type $name is already defined" if exists $data_matchers{$name};
    unshift @data_names, $name;
    $data_matchers{$name}     = $matcher;
    $data_transformers{$name} = $transfomer;
  }

  sub ni_io_for {
    my ($f, @args) = @_;
    for my $n (@data_names) {
      return $data_transformers{$n}->($f, @args)
        if $data_matchers{$n}->($f, @args);
    }
    die "$f does not match any known ni::io constructor";
  }

  sub ::ni {
    my ($f, @args) = @_;
    return undef unless defined $f;
    return $f if ref $f && $f->isa('ni::io');
    return ni_io_for($f, @args);
  }

  *{"ni::ni"} = *{"::ni"};
}
# Data source/sink implementations

our %read_filters;
our %write_filters;

defdata 'file',
  sub { -e $_[0] || $_[0] =~ s/^file:// },
  sub {
    my ($f)       = @_;
    my $extension = ($f =~ /\.(\w+)$/)[0];
    my $file      = ni_file("[file $f]", "< $f", "> $f");
    exists $read_filters{$extension}
      ? ni_filter($file, $read_filters{$extension}, $write_filters{$extension})
      : $file;
  };

sub deffilter {
  my ($extension, $read, $write) = @_;
  $read_filters{$extension}  = $read;
  $write_filters{$extension} = $write;

  my $prefix_detector = qr/^$extension:/;
  defdata $extension,
    sub { $_[0] =~ s/$prefix_detector// },
    sub { ni_filter(ni($_[0]), $read, $write) };
}

deffilter 'gz',  'gzip -d',  'gzip';
deffilter 'lzo', 'lzop -d',  'lzop';
deffilter 'xz',  'xz -d',    'xz';
deffilter 'bz2', 'bzip2 -d', 'bzip2';

defdata 'ssh',
  sub { $_[0] =~ /^\w*@[^:\/]+:/ },
  sub { $_[0] =~ /^([^:@]+)@([^:]+):(.*)$/;
        my ($user, $host, $file) = ($1, $2, $3);

        };

defdata 'globfile', sub { ref $_[0] eq 'GLOB' },
                    sub { ni_file("[fh = " . fileno($_[0]) . "]",
                                  $_[0], $_[0]) };
BEGIN {

use List::Util qw/min max/;
use POSIX qw/dup2/;

sub to_fh {
  return undef unless defined $_[0];
  return $_[0]->() if ref $_[0] eq 'CODE';
  return $_[0]     if ref $_[0] eq 'GLOB';
  open my $fh, $_[0] or die "failed to open $_[0]: $!";
  $fh;
}

# Partial implementations
defio 'sink_as',
sub { +{description => $_[0], f => $_[1]} },
{
  explain         => sub { "[sink as: " . ${$_[0]}{description} . "]" },
  supports_reads  => sub { 0 },
  supports_writes => sub { 1 },
  sink_gen        => sub { ${$_[0]}{f}->(@_[1..$#_]) },
};

defio 'source_as',
sub { +{description => $_[0], f => $_[1]} },
{
  explain    => sub { "[source as: " . ${$_[0]}{description} . "]" },
  source_gen => sub { ${$_[0]}{f}->(@_[1..$#_]) },
};

sub sink_as(&)   { ni_sink_as("[anonymous sink]", @_) }
sub source_as(&) { ni_source_as("[anonymous source]", @_) }

# Bidirectional filehandle IO with lazy creation
defio 'file',
sub {
  die "ni_file() requires three constructor arguments (got @_)" unless @_ == 3;
  +{description => $_[0], reader => $_[1], writer => $_[2]}
},
{
  explain => sub { ${$_[0]}{description} },

  reader_fh => sub {
    my ($self) = @_;
    die "io not configured for reading" unless $self->supports_reads;
    $$self{reader} = to_fh $$self{reader};
  },

  writer_fh => sub {
    my ($self) = @_;
    die "io not configured for writing" unless $self->supports_writes;
    $$self{writer} = to_fh $$self{writer};
  },

  supports_reads  => sub { defined ${$_[0]}{reader} },
  supports_writes => sub { defined ${$_[0]}{writer} },
  has_reader_fh   => sub { ${$_[0]}->supports_reads },
  has_writer_fh   => sub { ${$_[0]}->supports_writes },

  source_gen => sub {
    my ($self, $destination) = @_;
    gen 'file_source:V', {fh   => $self->reader_fh,
                          body => $destination->sink_gen('L')},
      q{ while (<%:fh>) {
           chomp;
           @_ = split /\t/;
           %@body
         } };
  },

  sink_gen => sub {
    my ($self, $type) = @_;
    with_input_type $type,
      gen 'file_sink:L', {fh => $self->writer_fh},
        q{ print %:fh join("\t", @_) . "\n"; };
  },

  close => sub { close $_[0]->writer_fh; $_[0] },
};

# An array of stuff in memory
defio 'memory',
sub { [@_] },
{
  explain => sub {
    "[memory io of " . scalar(@{$_[0]}) . " element(s): "
                     . "[" . join(', ', @{$_[0]}[0 .. min(3, $#{$_[0]})],
                                        @{$_[0]} > 4 ? ("...") : ()) . "]]";
  },

  supports_writes => sub { 1 },

  source_gen => sub {
    my ($self, $destination) = @_;
    gen 'memory_source:VV', {xs   => $self,
                             body => $destination->sink_gen('O')},
      q{ for (@{%:xs}) {
           @_ = ($_);
           %@body
         } };
  },

  sink_gen => sub {
    my ($self) = @_;
    gen 'memory_sink:FV', {xs => $self}, q{ push @{%:xs}, @_; };
  },
};

# A ring buffer of a specified size
defio 'ring',
sub { die "ring must contain at least one element" unless $_[0] > 0;
      my $n = 0;
      +{xs       => [map undef, 1..$_[0]],
        overflow => $_[1],
        n        => \$n} },
{
  explain => sub {
    my ($self) = @_;
    "[ring io of " . min(${$$self{n}}, scalar @{$$self{xs}})
                   . " element(s)"
                   . ($$self{overflow} ? ", > $$self{overflow}]"
                                       : "]");
  },

  supports_writes => sub { 1 },

  source_gen => sub {
    my ($self, $destination) = @_;
    my $i     = ${$$self{n}};
    my $size  = @{$$self{xs}};
    my $start = max 0, $i - $size;

    # Emit two loops, one before and one after the break. This way we won't end
    # up doing a modulus per loop iteration.
    gen 'ring_source:VV', {xs    => $$self{xs},
                           n     => $size,
                           end   => $i % $size,
                           i     => $start % $size,
                           body  => $destination->sink_gen('O')},
      q{ while (%:i < %@n) {
           @_ = (${%:xs}[%:i++]);
           %@body
         }
         %:i = 0;
         while (%:i < %@end) {
           @_ = (${%:xs}[%:i++]);
           %@body
         } };
  },

  sink_gen => sub {
    my ($self, $type) = @_;
    if (defined $$self{overflow}) {
      gen "ring_sink:${type}V", {xs   => $$self{xs},
                                 size => scalar(@{$$self{xs}}),
                                 body => $$self{overflow}->sink_gen('O'),
                                 n    => $$self{n},
                                 e    => $type eq 'F' ? '[@_]' : '$_',
                                 v    => 0,
                                 i    => 0},
        q{ %:v = $_;
           %:i = ${%:n} % %@size;
           if (${%:n}++ >= %@size) {
             $_ = ${%:xs}[%:i];
             %@body
           }
           ${%:xs}[%:i] = %:v; };
    } else {
      gen "ring_sink:${type}V", {xs   => $$self{xs},
                                 size => scalar(@{$$self{xs}}),
                                 n    => $$self{n},
                                 e    => $type eq 'F' ? '[@_]' : '$_'},
        q{ ${%:xs}[${%:n}++ % %@size] = %@e; };
    }
  },
};

# Empty source, null sink
defio 'null', sub { +{} },
{
  explain         => sub { '[null io]' },
  supports_writes => sub { 1 },
  source_gen      => sub { gen 'empty', {}, '' },
  sink_gen        => sub { gen "null_sink:$_[1]V", {}, '' },
};

# Sum of multiple IOs
defio 'sum',
sub { [map $_->flatten, @_] },
{
  explain => sub {
    "[sum: " . join(' + ', @{$_[0]}) . "]";
  },

  transform  => sub {
    my ($self, $f) = @_;
    my $x = $f->($self);
    $x eq $self ? ni_sum(map $_->transform($f), @$self)
                : $x;
  },

  flatten    => sub { @{$_[0]} },
  source_gen => sub {
    my ($self, $destination) = @_;
    return gen 'empty', {}, '' unless @$self;
    gen_seq 'sum_source:VV', map $_->source_gen($destination), @$self;
  },
};

# Concatenation of an IO of IOs
defio 'cat',
sub { \$_[0] },
{
  explain => sub {
    "[cat ${$_[0]}]";
  },

  source_gen => sub {
    my ($self, $destination) = @_;
    $$self->source_gen(sink_as {
      my ($type) = @_;
      with_input_type $type,
        gen 'cat_source:OV',
            {dest => $destination},
            q{ $_ > %:dest; }});
  },
};

# Introduces arbitrary indirection into an IO's code stream
defio 'bind',
sub {
  die "code transform must be [description, f]" unless ref $_[1] eq 'ARRAY';
  +{ base => $_[0], code_transform => $_[1] }
},
{
  explain => sub {
    my ($self) = @_;
    "$$self{base} >>= $$self{code_transform}[0]";
  },

  supports_reads  => sub { ${$_[0]}{base}->supports_reads },
  supports_writes => sub { ${$_[0]}{base}->supports_writes },

  transform => sub {
    my ($self, $f) = @_;
    my $x = $f->($self);
    $x eq $self ? ni_bind($$self{base}->transform($f), $$self{code_transform})
                : $x;
  },

  sink_gen => sub {
    my ($self, $type) = @_;
    $$self{code_transform}[1]->($$self{base}, $type);
  },

  source_gen => sub {
    my ($self, $destination) = @_;
    $$self{base}->source_gen(sink_as {
      my ($type) = @_;
      $$self{code_transform}[1]->($destination, $type);
    });
  },

  close => sub { ${$_[0]}{base}->close; $_[0] },
};

# A file-descriptor pipe
defioproxy 'pipe', sub {
  pipe my $out, my $in or die "pipe failed: $!";
  ni_file("[pipe in = " . fileno($in) . ", out = " . fileno($out). "]",
          $out, $in);
};

# Stdin/stdout of an external process with stdin, stdout, neither, or both
# redirected to the specified ios. If you don't specify them, this function
# creates pipes and returns a lazy io wrapping them.
defioproxy 'process', sub {
  my ($command, $stdin_fh, $stdout_fh) = @_;
  my $stdin  = undef;
  my $stdout = undef;

  unless (defined $stdin_fh) {
    $stdin    = ni_pipe();
    $stdin_fh = $stdin->reader_fh;
  }

  unless (defined $stdout_fh) {
    $stdout    = ni_pipe();
    $stdout_fh = $stdout->writer_fh;
  }

  my $pid = undef;
  my $create_process = sub {
    return if defined $pid;
    unless ($pid = fork) {
      close STDIN;  close $stdin->writer_fh  if defined $stdin;
      close STDOUT; close $stdout->reader_fh if defined $stdout;
      dup2 fileno $stdin_fh,  0 or die "dup2 failed: $!";
      dup2 fileno $stdout_fh, 1 or die "dup2 failed: $!";
      exec $command or exit;
    }
  };

  ni_file(
    "[process $command, stdin = $stdin, stdout = $stdout]",
    sub { $create_process->(); defined $stdout ? $stdout->reader_fh : undef },
    sub { $create_process->(); defined $stdin  ? $stdin->writer_fh  : undef });
};

# Filtered through shell processes
defioproxy 'filter', sub {
  my ($base, $read_filter, $write_filter) = @_;
  ni_file(
    "[filter $base, read = $read_filter, write = $write_filter]",
    $base->supports_reads && defined $read_filter
      ? sub {ni_process($read_filter, $base->reader_fh, undef)->reader_fh}
      : undef,
    $base->supports_writes && defined $write_filter
      ? sub {ni_process($write_filter, undef, $base->writer_fh)->writer_fh}
      : undef);
};

}
sub invocation {
  my ($f, @args) = @_;
  if (@args || ref $f eq 'CODE' || $f =~ s/^;//) {
    # We need to generate a function call.
    @args
      ? gen('fn:FF', {f => compile($f), args => [@args]},
            q{ %:f->(@_, @{%:args}) })
      : gen('fn:FF', {f => compile($f)}, q{ %:f->(@_) });
  } else {
    # We can inline the expression to avoid function call overhead.
    gen('fn:FF', {f => $f}, q{ (%@f) });
  }
}

# Bindings for common transformations
sub flatmap_binding {
  my $i  = invocation @_;
  my $is = input_sig $i;
  ["flatmap $i", sub {
    my ($into, $type) = @_;
    with_input_type $type,
      gen "flatmap:${is}V", {invocation => $i,
                             body       => $into->sink_gen('R')},
        q{ for (%@invocation) {
             %@body
           } };
  }];
}

sub mapone_binding {
  my $i  = invocation @_;
  my $is = input_sig $i;
  ["mapone $i", sub {
    my ($into, $type) = @_;
    with_input_type $type,
      gen "mapone:${is}V", {invocation => $i,
                            body       => $into->sink_gen('F')},
        q{ if (@_ = %@invocation) {
             %@body
           } };
  }];
}

sub grep_binding {
  my $i  = invocation @_;
  my $is = input_sig $i;
  ["grep $i", sub {
    my ($into, $type) = @_;
    with_input_type $type,
      gen "grep:${is}V", {invocation => $i,
                          body       => $into->sink_gen($is)},
        q{ if (%@invocation) {
             %@body
           } };
  }];
}

sub reduce_binding {
  my ($f, $init) = @_;
  $f = compile $f;
  ["reduce $f, $init", sub {
    my ($into, $type) = @_;
    with_input_type $type,
      gen 'reduce:FV', {f    => $f,
                        init => $init,
                        body => $into->sink_gen('R')},
        q{ (%:init, @_) = %:f->(%:init, @_);
           for (@_) {
             %@body
           } };
  }];
}

# Stream manipulation
sub tee_binding {
  my ($tee) = @_;
  ["tee $tee", sub {
    my ($into, $type) = @_;
    my $init    = gen 'tee_init', {x => []},
                      $type eq 'F' ? q{ @{%:x} = @_ } : q{ %:x = $_ };

    my $recover = gen('tee_recover', {x => []},
                      $type eq 'F' ? q{ @_ = @{%:x} } : q{ $_ = %:x })
                  ->inherit_gensyms_from($init);

    gen_seq "tee:${type}V", $init,    $tee->sink_gen($type),
                            $recover, $into->sink_gen($type);
  }];
}

sub take_binding {
  my ($n) = @_;
  die "must take a positive number of things" unless $n > 0;
  ["take $n", sub {
    my ($into, $type) = @_;
    gen "take:${type}V", {body      => $into->sink_gen($type),
                          remaining => $n},
      q{ %@body;
         return if --%:remaining <= 0; };
  }];
}

sub drop_binding {
  my ($n) = @_;
  ["drop $n", sub {
    my ($into, $type) = @_;
    gen "take:${type}V", {body      => $into->sink_gen($type),
                          remaining => $n},
      q{ if (--%:remaining < 0) {
           %@body
         }};
  }];
}
# Extra IO functions

# Eagerly reads N items, returning (buffer, rest) both as IOs.
sub ni::io::peek {
  my ($self, $n) = @_;
  my $buffer = ni_memory();
  ($buffer < $self->bind(take_binding($n)), $self);
}
# High-level pipe operations, each of which corresponds to a command-line
# option. They can also be used from compiled code.

our %op_shorthand_lookups;      # keyed by short
our %op_shorthands;             # keyed by long
our %op_formats;                # ditto
our %op_usage;                  # ditto
our %op_fns;                    # ditto

sub long_op_method  { "--$_[0]" =~ s/-/_/gr }
sub short_op_method { "_$_[0]" }

sub defop {
  my ($long, $short, $format, $usage, $fn) = @_;
  if (defined $short) {
    $op_shorthands{$long}         = $short;
    $op_shorthand_lookups{$short} = "--$long";
  }
  $op_formats{$long} = $format;
  $op_usage{$long}   = $usage;
  $op_fns{$long}     = $fn;

  my $long_method_name = long_op_method $long;
  my $short_method_name =
    defined $short ? short_op_method $short : undef;

  die "operator $long already exists (possibly as a method rather than an op)"
    if exists $ni::io::{$long_method_name}
    or defined $short_method_name && exists $ni::io::{$short_method_name};

  # Enable programmatic access
  *{"ni::io::$short_method_name"} = $fn if defined $short_method_name;
  *{"ni::io::$long_method_name"}  = $fn;
}

our %format_matchers = (
  a => qr/^[a-zA-Z]+$/,
  d => qr/^[-+\.0-9]+$/,
  s => qr/^.*$/,
  v => qr/^[^-].*$/,
);

sub apply_format {
  my ($format, @args) = @_;
  my @format = split //, $format;
  my @parsed;

  for (@format) {
    die "too few arguments for $format" if !@args && !/[A-Z]/;
    my $a = shift @args;
    if ($a =~ /$format_matchers{lc $_}/) {
      push @parsed, $a;
    } else {
      die "failed to match format $format" unless /[A-Z]/;
      push @parsed, undef;
    }
  }

  [@parsed], @args;
}

sub file_opt { ['plus', ni $_[0]] }
sub parse_commands {
  my @parsed;
  for (my $o; defined($o = shift @_);) {
    return @parsed, map file_opt($_), @_ if $o eq '--';
    if ($o =~ /^--/) {
      my $c = $o =~ s/^--//r;
      die "unknown long command: $o" unless exists $op_fns{$c};
      my ($args, @rest) = apply_format $op_formats{$c}, @_;
      push @parsed, [$c, @$args];
      @_ = @rest;
    } elsif ($o =~ s/^-//) {
      my ($op, @stuff) = grep length,
                         split /([:+^=%\/]?[a-zA-Z]|[-+\.0-9]+)/, $o;
      die "undefined short op: $op" unless exists $op_shorthand_lookups{$op};
      unshift @_, map $op_shorthand_lookups{$_} // $_, $op, @stuff;
    } else {
      push @parsed, file_opt $o;
    }
  }
  @parsed;
}
# Operator implementations

use B::Deparse;
use File::Temp qw/tmpnam/;

# Meta
defop 'self', undef, '',
  'adds the source code of ni',
  sub { $_[0] + ni_memory(self) };

defop 'explain-stream', undef, '',
  'explains the current stream',
  sub { ni_memory($_[0]->explain) };

defop 'explain-compilation', undef, '',
  'shows the compiled output for the current stream',
  sub {
    my $gen = $_[0]->source_gen(sink_as {
      with_input_type $_[0],
        gen 'print:LV', {}, "print STDOUT \$_;"});
    my $deparser = B::Deparse->new;
    my ($f, $refs) = $gen->compile_to_sub;
    delete $$refs{$_} for keys %$refs;
    ni_memory($deparser->coderef2text($f));
  };

defop 'defined-methods', undef, '',
  'lists defined long and short methods on IO objects',
  sub { ni_memory(map "$_\n", grep /^_/, sort keys %{ni::io::}) };

defop 'debug-compile', undef, '',
  'shows the compiled code generated for the given io',
  sub {
    my $gen = $_[0]->source_gen(sink_as {
                with_input_type $_[0],
                  gen 'print:LV', {}, "print STDOUT \$_;"});
    ni_memory("\nCOMPILED\n" . $gen->compile,
              "\n",
              "\nDEBUG\n"    . $gen->debug_to_string);
  };

# Stream transforms
defop 'plus', undef, '',
  'adds two streams together (implied for files)',
  sub { $_[0] + $_[1] };

defop 'tee', undef, 's',
  'tees current output into the specified io',
  sub { $_[0] >>= tee_binding(ni $_[1]) };

defop 'take', undef, 'd',
  'takes the first or last N records from the specified io',
  sub { $_[1] > 0 ? $_[0] >>= take_binding($_[1])
                  : ni_ring(-$_[1]) < $_[0] };

defop 'drop', undef, 'd',
  'drops the first or last N records from the specified io',
  sub {
    my ($self, $n) = @_;
    $n >= 0
      ? $self->bind(drop_binding($n))
      : ni_source_as("$self >>= drop " . -$n . "]", sub {
          my ($destination) = @_;
          $self->source_gen(ni_ring(-$n, $destination));
        });
  };

# Functional transforms
defop 'map', 'm', 's',
  'transforms each record using the specified function',
  sub { $_[0] * $_[1] };

defop 'keep', 'k', 's',
  'keeps records for which the function returns true',
  sub { $_[0] % $_[1] };

defop 'transform', 'M', 's',
  'transforms the stream as an object using the specified function',
  sub { compile($_[1])->($_[0]) };

defop 'deref', 'r', '',
  'interprets each record as a data source and emits it',
  sub { ni_cat($_[0] * \&ni) };

defop 'ref', 'R', 'V',
  'collects data into a file and emits the filename',
  sub { my ($self, $f) = @_;
        $self > ni($f //= "file:" . tmpnam);
        ni_memory($f) };

defop 'branch', 'b', 's',
  'splits input by its first field, forwarding to subprocesses',
  sub {
    my ($in, $subprocesses) = @_;
    my @subs = unpack_branch_map $subprocesses;
    my $fifo = ni::io::fifo->new->from(map ${$_}[1], @subs);

    unless (fork) {
      my $line;
      while (defined($line = <$in>)) {
        my ($k, $v) = split /\t/, $line, 2;
        for my $s (@subs) {
          if ($s->[0]->($k)) {
            $s->[1]->enqueue($line);
            last;
          }
        }
      }
      exit;
    }
    $fifo;
  };

# Sorting (shells out to command-line sort)
sub sort_options {
  my @fieldspec = split //, $_[0] // '';
  # TODO
}

defop 'order', 'o', 'AD',
  'order {n|N|g|G|l|L|u|U|m} [fields]',
  sub {
    my ($in, $flags, $fields) = @_;
    $in | 'sort';
  };
# Preprocess command line, collapsing stuff into array and hash references as
# appropriate.

use POSIX qw/dup2/;

sub preprocess_cli {
  my @preprocessed;
  for (my $o; defined($o = shift @_);) {
    if ($o =~ s/\[$//) {
      my @xs;
      my $depth = 1;
      for (@_) {
        last unless $depth -= /^\]$/;
        $depth += /\[$/;
        push @xs, $_;
      }
      push @preprocessed, bless [@xs], $o;
    } elsif ($o =~ s/\{$//) {
      my @xs;
      my $depth = 1;
      for (@_) {
        last unless $depth -= /^\}$/;
        $depth += /\{$/;
        push @xs, $_;
      }
      push @preprocessed, bless {@xs}, $o;
    } else {
      push @preprocessed, $o;
    }
  }
  @preprocessed;
}

sub stream_for {
  my ($stream, @options) = @_;
  $stream //= -t STDIN ? ni_sum() : ni_file('[stdin]', \*STDIN, undef);
  for (parse_commands @options) {
    my ($command, @args) = @$_;
    eval {$stream = $ni::io::{long_op_method $command}($stream, @args)};
    die "failed to apply stream command $command [@args] "
      . "(method: " . long_op_method($command) . "): $@" if $@;
  }
  $stream;
}

sub stream_to_process {
  my ($stream, @process_alternatives) = @_;
  my $fh = $stream->reader_fh;
  if (fileno $fh) {
    close STDIN;
    dup2 fileno $fh, 0 or die "dup2 failed: $!";
  }
  exec $_ for @process_alternatives;
}

sub main {
  $|++;
  my $data = stream_for undef, preprocess_cli @_;
  if (-t STDOUT && !exists $ENV{NI_NO_PAGER}) {
    # Use a pager rather than writing straight to the terminal
    stream_to_process $data, $ENV{NI_PAGER} // $ENV{PAGER} // 'less',
                             'more';

    # Ok, we're out of options; just write to the terminal after all
    print STDERR "ni: couldn't exec any pagers, writing to the terminal\n";
    print STDERR "ni: (sorry about this; if you set \$PAGER it should work)\n";
    print STDERR "\n";
    print while <>;
  } else {
    $data > \*STDOUT;
  }
}

END { main @ARGV }

}
