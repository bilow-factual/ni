#!/usr/bin/env perl
eval $ni::selfcode;
die $@ if $@;
__DATA__
{

use v5.14;
no strict 'refs';
package ni;
sub ni;
sub ::ni;

sub self {
  join "\n", "#!/usr/bin/env perl",
             q{$ni::selfcode = '';},
             q{$ni::selfcode .= ($_ = <DATA>) until /^__END__$/;},
             q{eval $ni::selfcode;},
             q{die $@ if $@;},
             "__DATA__",
             $ni::selfcode,
             "__END__";
}

use POSIX qw/:sys_wait_h/;

$SIG{CHLD} = sub {
  local ($!, $?);
  waitpid -1, WNOHANG;
};
# Memoized function compilation
our %compiled_functions;

sub expand_function_shorthands {
  my ($code) = @_;
  $code =~ s/%(\d+)/\$_[$1]/g;

  # JSON shortcuts
  1 while $code =~ s/([a-zA-Z0-9_\)\}\]\?\$])
                     \.
                     ([\$_a-zA-Z](?:-[0-9\w\?\$]|[0-9_\w?\$])*)
                    /$1\->{'$2'}/x;
  $code;
}

sub compile {
  return $_[0] if ref $_[0] eq 'CODE';
  return $compiled_functions{$_[0]}
     //= eval "package main; sub {\n" . expand_function_shorthands($_[0])
                                      . "\n}";
}
# Code generator, type solver, and adaptive JIT
# ni executes all IO by emitting pipeline-specific code and running it. This
# file contains a bunch of definitions to make that possible.
#
# At the core of this abstraction is a code-quoting mechanism that lets you
# drop live references into compiled code. This lowers the barrier between a
# regular lambda function and a JIT template.
#
# Slightly above that is a type solver. The type system isn't very
# sophisticated; all we have is a very basic description of how to access the
# inputs to a function. Types are short strings. For example, "L" and "A" refer
# to data stored in $_; "F" refers to data in @_, etc. See below for a full
# list.
#
# Above all of this is the adaptive JIT, which starts with a series of
# alternatives from genalt() calls, profiles each one, and recompiles down to
# whichever one ends up being fastest. Each adaptive branch is fully
# type-compiled, so this is as much about representational optimization as it
# is about general optimization. Adaptive JIT on running code imposes some
# constraints that impact how code must be written; see below for details.

# Type representation details
# ni has a very simple addressing scheme in that there's only one piece of
# addressable data at a time. This means that type solving is basically linear;
# each code join point will have two possibilities:
#
# 1. An appropriately-typed branch exists, so use that monomorphically.
# 2. No appropriate branch exists, so generate a polyrmorphic alternative that
#    will be adaptively optimized.
#
# Possible types are:
#
# - L: we have an unsplit line in $_; basically a straight read from a file.
# - A\d+: data is unsplit in $_, but the first N field boundaries are known and
#   stored in $f0, $f1, ..., $fN-1. If N = 0, then we know all field
#   boundaries.
# - F: we have data split into fields and stored in @_.

# Adaptive JIT details
# This is actually a lot easier than it sounds. We need to preserve two
# invariants:
#
# 1. Any monomorphic alternative must contain only monomorphic alternatives.
# 2. Any code containing a polymorphic alternative must be resumable.
#
# (1) is necessary to prevent the JIT from preferring alternatives with only
# monomorphic descendants (since resumable, profiled, branched code is more
# expensive). (2) makes it possible to suspend from an inner loop, reduce some
# polymorphic branches to monomorphic ones (possibly more than just the ones we
# jumped out of), and pick up where we left off.

our $gensym_id = 0;
sub gensym { '__' . ($_[0] // 'gensym') . '_' . ++$gensym_id . '__' }

sub analyze_gen_template;
sub gen {
  # Monomorphic code that has been type-erased. Optionally resumable. Code
  # generators should never return one of these directly; they should wrap
  # within a genalt() instead. Instances of this class are semantically
  # immutable.
  my ($refs, $nonresumable_form, $resumable_form) = @_;

  # Try to use the nonresumable form since it's faster.
  my ($nonrefs, $nonresumable_code, $non_contains_poly) =
    analyze_gen_template $refs, $nonresumable_form;
  return bless { refs => $nonrefs,
                 code => $nonresumable_code,
                 poly => 0 }, 'ni::gen::mono'
    unless $non_contains_poly;

  die "must provide a resumable alternative for $nonresumable_code"
    unless defined $resumable_form;

  # Need to use a resumable form, so compile that one instead.
  my ($rrefs, $resumable_code, $resumable_contains_poly) =
    analyze_gen_template $refs, $resumable_form;
  bless { refs => $rrefs,
          code => $resumable_code,
          poly => 1 }, 'ni::gen::mono';
}

{

package ni::gen::mono;
use overload qw/ "" code /;

sub code { my ($self) = @_; $$self{code} }
sub poly { my ($self) = @_; $$self{poly} }

}


sub genalt {
  # Polymorphic code indexed by type. Not always compiled down to a polymorphic
  # branch; often the container can match its source type with one of the
  # alternatives here, and that's usually assumed to be faster than an adaptive
  # JIT branch.
  my %alternatives = @_;
  my @branches = sort keys %alternatives;

  bless { alternatives  => \%alternatives,
          branch_types  => [@branches],
          branches      => [map $alternatives{$_}, @branches],
          branch_times  => [map 0, @branches],
          branch_counts => [map 0, @branches],
          decided       => 0 },
        'ni::gen::poly';
}

sub analyze_gen_template {
  # Takes ($refs, $code) and returns ($refs, $code, $contains_poly). The $refs
  # returned are a subset of the originals, since the original contains both
  # value closures and gen substitutions.
  my @pieces;
  my $contains_poly = 0;
  my %original_refs = %{$_[0]};
  my %refs;
  my %gensyms;
  my %subst;

  for (split /(:\<\w+\>|\:\w+)/, $_[1]) {
    if (/^:(\w+)$/) {
      die "gen template $_[1] used with undefined gensym ref $1"
        unless defined $original_refs{$1};
      push @pieces, $gensyms{$1} //= gensym $1;
      $refs{$gensyms{$1}} = $original_refs{$1};
    } elsif (/^:\<(\w+)\>$/) {
      die "gen template $_[1] used with undefined subst ref $1"
        unless defined $original_refs{$1};
      my $r = $original_refs{$1};
      push @pieces, $subst{$1} //= $r;
      if (ref $r) {
        $contains_poly ||= $r->poly;
        my $r_refs = $r->refs;
        $refs{$_} = $$r_refs{$_} for keys %$r_refs;
      }
    } else {
      push @pieces, $_;
    }
  }

  (\%refs, join('', @pieces), $contains_poly);
}
# Extensible IO stream abstraction
# Streams are defined by the Perl code that runs in order to put their values
# somewhere. This abstraction ends up getting completely erased at runtime,
# which is good because Perl OO is really slow.
#
# If you want to construct one of these and use it for IO purposes, the fastest
# option should be to get a filehandle for it first:
#
# my $fh = $ni_io->into_fh;
# while (<$fh>) {
#   ...
# }
#
# my $fh = $ni_io->from_fh;
# print $fh "foo bar\n";
#
# This will fork the compiled code into a separate process, which is still
# usually faster than the abstraction otherwise required.

our %io_constructors;

sub is_io { ref $_[0] && $_[0]->isa('ni::io') }

sub defio {
  my ($name, $constructor, $methods) = @_;
  *{"ni::io::${name}::new"} = $io_constructors{$name} = sub {
    my ($class, @args) = @_;
    bless $constructor->(@args), $class;
  };
  *{"::ni_$name"} = *{"ni::ni_$name"} =
    sub { ${"ni::io::${name}::"}{new}("ni::io::$name", @_) };
  *{"ni::io::$name::$_"} = $methods->{$_} for keys %$methods;
  push @{"ni::io::${name}::ISA"}, 'ni::io';
}

sub defioproxy {
  my ($name, $f) = @_;
  *{"::ni_$name"} = *{"ni::ni_$name"} = $f;
}

sub mapone_binding;
sub flatmap_binding;
sub reduce_binding;
sub grep_binding;
sub pipe_binding;

# Internally we're using these IO objects to generate imperative code, so it's
# going to be source-driven. This means we can't do much until we know where
# the values need to go (though we can defer that by fork/piping).

{

package ni::io;
use overload qw# + plus_op  * mapone_op  / reduce_op  % grep_op  | pipe_op
                 eq compare_refs
                 "" explain
                 >>= bind_op
                 > into  >= into_bg
                 < from  <= from_bg #;

use Scalar::Util qw/refaddr/;

BEGIN { *gen = \&ni::gen }

use POSIX qw/dup2/;

# Methods implemented by children
sub source_gen { ... }          # gen to source from this thing
sub sink_gen   { ... }          # gen to sink into this thing
sub explain    { ... }

sub transform {
  my ($self, $f) = @_;
  $f->($self);
}

sub reader_fh { (::ni_pipe() <= $_[0])->reader_fh }
sub writer_fh { (::ni_pipe() >= $_[0])->writer_fh }

sub has_reader_fh { 0 }
sub has_writer_fh { 0 }
sub process_local { 0 }

sub supports_reads  { 1 }
sub supports_writes { 0 }

sub flatten { ($_[0]) }
sub close   { $_[0] }

# Transforms
sub plus_op   { $_[0]->plus($_[1]) }
sub bind_op   { $_[0]->bind($_[1]) }
sub mapone_op { $_[0]->mapone($_[1]) }
sub reduce_op { $_[0]->reduce($_[1], {}) }
sub grep_op   { $_[0]->grep($_[1]) }
sub pipe_op   { $_[0]->pipe($_[1]) }

sub plus    { ::ni_sum(@_) }
sub bind    { ::ni_bind(@_) }
sub mapone  { $_[0] >>= ni::mapone_binding  @_[1..$#_] }
sub flatmap { $_[0] >>= ni::flatmap_binding @_[1..$#_] }
sub reduce  { $_[0] >>= ni::reduce_binding  @_[1..$#_] }
sub grep    { $_[0] >>= ni::grep_binding    @_[1..$#_] }
sub pipe    { ::ni_process($_[1], $_[0], undef) }

sub compare_refs { refaddr($_[0]) eq refaddr($_[1]) }

# User-facing methods
sub from {
  my ($self, $source) = @_;
  ::ni($source)->source_gen($self)->run;
  $self;
}

sub from_bg {
  my ($self, $source) = @_;
  die "cannot background-load a process-local io $self"
    if $self->process_local;
  $self < $source, exit unless fork;
  $self;
}

sub into {
  my ($self, $dest) = @_;
  $self->source_gen(::ni $dest)->run;
  $self;
}

sub into_bg {
  my ($self, $dest) = @_;
  die "cannot background-load a process-local io $dest"
    if $dest->process_local;
  $self > $dest, exit unless fork;
  $self;
}

}
# Data source definitions
BEGIN {
  our @data_names;
  our %data_matchers;
  our %data_transformers;

  sub defdata {
    my ($name, $matcher, $transfomer) = @_;
    die "data type $name is already defined" if exists $data_matchers{$name};
    unshift @data_names, $name;
    $data_matchers{$name}     = $matcher;
    $data_transformers{$name} = $transfomer;
  }

  sub ni_io_for {
    my ($f, @args) = @_;
    for my $n (@data_names) {
      return $data_transformers{$n}->($f, @args)
        if $data_matchers{$n}->($f, @args);
    }
    die "$f does not match any known ni::io constructor";
  }

  sub ::ni {
    my ($f, @args) = @_;
    return undef unless defined $f;
    return $f if ref $f && $f->isa('ni::io');
    return ni_io_for($f, @args);
  }

  *{"ni::ni"} = *{"::ni"};
}
# Data source/sink implementations

our %read_filters;
our %write_filters;

defdata 'file',
  sub { -e $_[0] || $_[0] =~ s/^file:// },
  sub {
    my ($f)       = @_;
    my $extension = ($f =~ /\.(\w+)$/)[0];
    my $file      = ni_file("[file $f]", "< $f", "> $f");
    exists $read_filters{$extension}
      ? ni_filter($file, $read_filters{$extension}, $write_filters{$extension})
      : $file;
  };

sub deffilter {
  my ($extension, $read, $write) = @_;
  $read_filters{$extension}  = $read;
  $write_filters{$extension} = $write;

  my $prefix_detector = qr/^$extension:/;
  defdata $extension,
    sub { $_[0] =~ s/$prefix_detector// },
    sub { ni_filter(ni($_[0]), $read, $write) };
}

deffilter 'gz',  'gzip -d',  'gzip';
deffilter 'lzo', 'lzop -d',  'lzop';
deffilter 'xz',  'xz -d',    'xz';
deffilter 'bz2', 'bzip2 -d', 'bzip2';

defdata 'ssh',
  sub { $_[0] =~ /^\w*@[^:\/]+:/ },
  sub { $_[0] =~ /^([^:@]+)@([^:]+):(.*)$/;
        my ($user, $host, $file) = ($1, $2, $3);

        };

defdata 'globfile', sub { ref $_[0] eq 'GLOB' },
                    sub { ni_file("[fh = " . fileno($_[0]) . "]",
                                  $_[0], $_[0]) };
BEGIN {

use List::Util qw/min max/;
use POSIX qw/dup2/;

sub to_fh {
  return undef unless defined $_[0];
  return $_[0]->() if ref $_[0] eq 'CODE';
  return $_[0]     if ref $_[0] eq 'GLOB';
  open my $fh, $_[0] or die "failed to open $_[0]: $!";
  $fh;
}

# Partial implementations
defio 'sink_as',
sub { +{description => $_[0], f => $_[1]} },
{
  explain         => sub { "[sink as: " . ${$_[0]}{description} . "]" },
  supports_reads  => sub { 0 },
  supports_writes => sub { 1 },
  sink_gen        => sub { ${$_[0]}{f}->(@_[1..$#_]) },
};

defio 'source_as',
sub { +{description => $_[0], f => $_[1]} },
{
  explain    => sub { "[source as: " . ${$_[0]}{description} . "]" },
  source_gen => sub { ${$_[0]}{f}->(@_[1..$#_]) },
};

sub sink_as(&)   { ni_sink_as("[anonymous sink]", @_) }
sub source_as(&) { ni_source_as("[anonymous source]", @_) }

# Bidirectional filehandle IO with lazy creation
defio 'file',
sub {
  die "ni_file() requires three constructor arguments (got @_)" unless @_ == 3;
  +{description => $_[0], reader => $_[1], writer => $_[2]}
},
{
  explain => sub { ${$_[0]}{description} },

  reader_fh => sub {
    my ($self) = @_;
    die "io not configured for reading" unless $self->supports_reads;
    $$self{reader} = to_fh $$self{reader};
  },

  writer_fh => sub {
    my ($self) = @_;
    die "io not configured for writing" unless $self->supports_writes;
    $$self{writer} = to_fh $$self{writer};
  },

  supports_reads  => sub { defined ${$_[0]}{reader} },
  supports_writes => sub { defined ${$_[0]}{writer} },
  has_reader_fh   => sub { ${$_[0]}->supports_reads },
  has_writer_fh   => sub { ${$_[0]}->supports_writes },

  source_gen => sub {
    my ($self, $destination) = @_;
    gen 'file_source:V', {fh   => $self->reader_fh,
                          body => $destination->sink_gen('L')},
      q{ while (<%:fh>) {
           chomp;
           @_ = split /\t/;
           %@body
         } };
  },

  sink_gen => sub {
    my ($self, $type) = @_;
    gen 'file_sink:L', {fh => $self->writer_fh},
      q{ print %:fh join("\t", @_) . "\n"; };
  },

  close => sub { close $_[0]->writer_fh; $_[0] },
};

# An array of stuff in memory
defio 'memory',
sub { [@_] },
{
  explain => sub {
    "[memory io of " . scalar(@{$_[0]}) . " element(s): "
                     . "[" . join(', ', @{$_[0]}[0 .. min(3, $#{$_[0]})],
                                        @{$_[0]} > 4 ? ("...") : ()) . "]]";
  },

  supports_writes => sub { 1 },
  process_local   => sub { 1 },

  source_gen => sub {
    my ($self, $destination) = @_;
    gen 'memory_source:VV', {xs   => $self,
                             body => $destination->sink_gen('O')},
      q{ for (@{%:xs}) {
           @_ = ($_);
           %@body
         } };
  },

  sink_gen => sub {
    my ($self) = @_;
    gen 'memory_sink:FV', {xs => $self}, q{ push @{%:xs}, @_; };
  },
};

# A ring buffer of a specified size
defio 'ring',
sub { die "ring must contain at least one element" unless $_[0] > 0;
      my $n = 0;
      +{xs       => [map undef, 1..$_[0]],
        overflow => $_[1],
        n        => \$n} },
{
  explain => sub {
    my ($self) = @_;
    "[ring io of " . min(${$$self{n}}, scalar @{$$self{xs}})
                   . " element(s)"
                   . ($$self{overflow} ? ", > $$self{overflow}]"
                                       : "]");
  },

  supports_writes => sub { 1 },
  process_local   => sub { 1 },

  source_gen => sub {
    my ($self, $destination) = @_;
    my $i     = ${$$self{n}};
    my $size  = @{$$self{xs}};
    my $start = max 0, $i - $size;

    # Emit two loops, one before and one after the break. This way we won't end
    # up doing a modulus per loop iteration.
    gen 'ring_source:VV', {xs    => $$self{xs},
                           n     => $size,
                           end   => $i % $size,
                           i     => $start % $size,
                           body  => $destination->sink_gen('O')},
      q{ while (%:i < %@n) {
           @_ = (${%:xs}[%:i++]);
           %@body
         }
         %:i = 0;
         while (%:i < %@end) {
           @_ = (${%:xs}[%:i++]);
           %@body
         } };
  },

  sink_gen => sub {
    my ($self, $type) = @_;
    if (defined $$self{overflow}) {
      gen "ring_sink:${type}V", {xs   => $$self{xs},
                                 size => scalar(@{$$self{xs}}),
                                 body => $$self{overflow}->sink_gen('O'),
                                 n    => $$self{n},
                                 e    => $type eq 'F' ? '[@_]' : '$_',
                                 v    => 0,
                                 i    => 0},
        q{ %:v = $_;
           %:i = ${%:n} % %@size;
           if (${%:n}++ >= %@size) {
             $_ = ${%:xs}[%:i];
             %@body
           }
           ${%:xs}[%:i] = %:v; };
    } else {
      gen "ring_sink:${type}V", {xs   => $$self{xs},
                                 size => scalar(@{$$self{xs}}),
                                 n    => $$self{n},
                                 e    => $type eq 'F' ? '[@_]' : '$_'},
        q{ ${%:xs}[${%:n}++ % %@size] = %@e; };
    }
  },
};

# Infinite source of repeated function application
defio 'iterate', sub { +{f => $_[0], x => $_[1]} },
{
  # TODO
};

# Empty source, null sink
defio 'null', sub { +{} },
{
  explain         => sub { '[null io]' },
  supports_writes => sub { 1 },
  source_gen      => sub { gen 'empty', {}, '' },
  sink_gen        => sub { gen "null_sink:$_[1]V", {}, '' },
};

# Sum of multiple IOs
defio 'sum',
sub { [map $_->flatten, @_] },
{
  explain => sub {
    "[sum: " . join(' + ', @{$_[0]}) . "]";
  },

  transform  => sub {
    my ($self, $f) = @_;
    my $x = $f->($self);
    $x eq $self ? ni_sum(map $_->transform($f), @$self)
                : $x;
  },

  flatten    => sub { @{$_[0]} },
  source_gen => sub {
    my ($self, $destination) = @_;
    return gen 'empty', {}, '' unless @$self;
    gen_seq 'sum_source:VV', map $_->source_gen($destination), @$self;
  },
};

# Concatenation of an IO of IOs
defio 'cat',
sub { \$_[0] },
{
  explain => sub {
    "[cat ${$_[0]}]";
  },

  source_gen => sub {
    my ($self, $destination) = @_;
    $$self->source_gen(sink_as {
      my ($type) = @_;
      with_input_type $type,
        gen 'cat_source:OV',
            {dest => $destination},
            q{ $_ > %:dest; }});
  },
};

# Introduces arbitrary indirection into an IO's code stream
defio 'bind',
sub {
  die "code transform must be [description, f]" unless ref $_[1] eq 'ARRAY';
  +{ base => $_[0], code_transform => $_[1] }
},
{
  explain => sub {
    my ($self) = @_;
    "$$self{base} >>= $$self{code_transform}[0]";
  },

  supports_reads  => sub { ${$_[0]}{base}->supports_reads },
  supports_writes => sub { ${$_[0]}{base}->supports_writes },

  transform => sub {
    my ($self, $f) = @_;
    my $x = $f->($self);
    $x eq $self ? ni_bind($$self{base}->transform($f), $$self{code_transform})
                : $x;
  },

  sink_gen => sub {
    my ($self, $type) = @_;
    $$self{code_transform}[1]->($$self{base}, $type);
  },

  source_gen => sub {
    my ($self, $destination) = @_;
    $$self{base}->source_gen(sink_as {
      my ($type) = @_;
      $$self{code_transform}[1]->($destination, $type);
    });
  },

  close => sub { ${$_[0]}{base}->close; $_[0] },
};

# A file-descriptor pipe
defioproxy 'pipe', sub {
  pipe my $out, my $in or die "pipe failed: $!";
  ni_file("[pipe in = " . fileno($in) . ", out = " . fileno($out). "]",
          $out, $in);
};

# Stdin/stdout of an external process with stdin, stdout, neither, or both
# redirected to the specified ios. If you don't specify them, this function
# creates pipes and returns a lazy io wrapping them.
defioproxy 'process', sub {
  my ($command, $stdin_fh, $stdout_fh) = @_;
  my $stdin  = undef;
  my $stdout = undef;

  unless (defined $stdin_fh) {
    $stdin    = ni_pipe();
    $stdin_fh = $stdin->reader_fh;
  }

  unless (defined $stdout_fh) {
    $stdout    = ni_pipe();
    $stdout_fh = $stdout->writer_fh;
  }

  my $pid = undef;
  my $create_process = sub {
    return if defined $pid;
    unless ($pid = fork) {
      close STDIN;  close $stdin->writer_fh  if defined $stdin;
      close STDOUT; close $stdout->reader_fh if defined $stdout;
      dup2 fileno $stdin_fh,  0 or die "dup2 failed: $!";
      dup2 fileno $stdout_fh, 1 or die "dup2 failed: $!";
      exec $command or exit;
    }
  };

  ni_file(
    "[process $command, stdin = $stdin, stdout = $stdout]",
    sub { $create_process->(); defined $stdout ? $stdout->reader_fh : undef },
    sub { $create_process->(); defined $stdin  ? $stdin->writer_fh  : undef });
};

# Filtered through shell processes
defioproxy 'filter', sub {
  my ($base, $read_filter, $write_filter) = @_;
  ni_file(
    "[filter $base, read = $read_filter, write = $write_filter]",
    $base->supports_reads && defined $read_filter
      ? sub {ni_process($read_filter, $base->reader_fh, undef)->reader_fh}
      : undef,
    $base->supports_writes && defined $write_filter
      ? sub {ni_process($write_filter, undef, $base->writer_fh)->writer_fh}
      : undef);
};

}
sub invocation {
  my ($f, @args) = @_;
  if (@args || ref $f eq 'CODE' || $f =~ s/^;//) {
    # We need to generate a function call.
    @args
      ? gen('fn:FF', {f => compile($f), args => [@args]},
            q{ %:f->(@_, @{%:args}) })
      : gen('fn:FF', {f => compile($f)}, q{ %:f->(@_) });
  } else {
    # We can inline the expression to avoid function call overhead.
    gen('fn:FF', {f => $f}, q{ (%@f) });
  }
}

# Bindings for common transformations
sub flatmap_binding {
  my $i  = invocation @_;
  my $is = input_sig $i;
  ["flatmap $i", sub {
    my ($into, $type) = @_;
    with_input_type $type,
      gen "flatmap:${is}V", {invocation => $i,
                             body       => $into->sink_gen('R')},
        q{ for (%@invocation) {
             %@body
           } };
  }];
}

sub mapone_binding {
  my $i  = invocation @_;
  my $is = input_sig $i;
  ["mapone $i", sub {
    my ($into, $type) = @_;
    with_input_type $type,
      gen "mapone:${is}V", {invocation => $i,
                            body       => $into->sink_gen('F')},
        q{ if (@_ = %@invocation) {
             %@body
           } };
  }];
}

sub grep_binding {
  my $i  = invocation @_;
  my $is = input_sig $i;
  ["grep $i", sub {
    my ($into, $type) = @_;
    with_input_type $type,
      gen "grep:${is}V", {invocation => $i,
                          body       => $into->sink_gen($is)},
        q{ if (%@invocation) {
             %@body
           } };
  }];
}

sub reduce_binding {
  my ($f, $init) = @_;
  $f = compile $f;
  ["reduce $f, $init", sub {
    my ($into, $type) = @_;
    with_input_type $type,
      gen 'reduce:FV', {f    => $f,
                        init => $init,
                        body => $into->sink_gen('R')},
        q{ (%:init, @_) = %:f->(%:init, @_);
           for (@_) {
             %@body
           } };
  }];
}

# Stream manipulation
sub tee_binding {
  my ($tee) = @_;
  ["tee $tee", sub {
    my ($into, $type) = @_;
    my $init    = gen 'tee_init', {x => []},
                      $type eq 'F' ? q{ @{%:x} = @_ } : q{ %:x = $_ };

    my $recover = gen('tee_recover', {x => []},
                      $type eq 'F' ? q{ @_ = @{%:x} } : q{ $_ = %:x })
                  ->inherit_gensyms_from($init);

    gen_seq "tee:${type}V", $init,    $tee->sink_gen($type),
                            $recover, $into->sink_gen($type);
  }];
}

sub take_binding {
  my ($n) = @_;
  die "must take a positive number of things" unless $n > 0;
  ["take $n", sub {
    my ($into, $type) = @_;
    gen "take:${type}V", {body      => $into->sink_gen($type),
                          remaining => $n},
      q{ %@body;
         return if --%:remaining <= 0; };
  }];
}

sub drop_binding {
  my ($n) = @_;
  ["drop $n", sub {
    my ($into, $type) = @_;
    gen "take:${type}V", {body      => $into->sink_gen($type),
                          remaining => $n},
      q{ if (--%:remaining < 0) {
           %@body
         }};
  }];
}
# Extra IO functions

# Eagerly reads N items, returning (buffer, rest) both as IOs.
sub ni::io::peek {
  my ($self, $n) = @_;
  my $buffer = ni_memory();
  ($buffer < $self->bind(take_binding($n)), $self);
}
# High-level pipe operations, each of which corresponds to a command-line
# option. They can also be used from compiled code.

our %op_shorthand_lookups;      # keyed by short
our %op_shorthands;             # keyed by long
our %op_formats;                # ditto
our %op_usage;                  # ditto
our %op_fns;                    # ditto

sub long_op_method  { "--$_[0]" =~ s/-/_/gr }
sub short_op_method { "_$_[0]" }

sub defop {
  my ($long, $short, $format, $usage, $fn) = @_;
  if (defined $short) {
    $op_shorthands{$long}         = $short;
    $op_shorthand_lookups{$short} = "--$long";
  }
  $op_formats{$long} = $format;
  $op_usage{$long}   = $usage;
  $op_fns{$long}     = $fn;

  my $long_method_name = long_op_method $long;
  my $short_method_name =
    defined $short ? short_op_method $short : undef;

  die "operator $long already exists (possibly as a method rather than an op)"
    if exists $ni::io::{$long_method_name}
    or defined $short_method_name && exists $ni::io::{$short_method_name};

  # Enable programmatic access
  *{"ni::io::$short_method_name"} = $fn if defined $short_method_name;
  *{"ni::io::$long_method_name"}  = $fn;
}

our %format_matchers = (
  a => qr/^[a-zA-Z]+$/,
  d => qr/^[-+\.0-9]+$/,
  s => qr/^.*$/,
  v => qr/^[^-].*$/,
);

sub apply_format {
  my ($format, @args) = @_;
  my @format = split //, $format;
  my @parsed;

  for (@format) {
    die "too few arguments for $format" if !@args && !/[A-Z]/;
    my $a = shift @args;
    if ($a =~ /$format_matchers{lc $_}/) {
      push @parsed, $a;
    } else {
      die "failed to match format $format" unless /[A-Z]/;
      push @parsed, undef;
    }
  }

  [@parsed], @args;
}

sub file_opt { ['plus', ni $_[0]] }
sub parse_commands {
  my @parsed;
  for (my $o; defined($o = shift @_);) {
    return @parsed, map file_opt($_), @_ if $o eq '--';
    if ($o =~ /^--/) {
      my $c = $o =~ s/^--//r;
      die "unknown long command: $o" unless exists $op_fns{$c};
      my ($args, @rest) = apply_format $op_formats{$c}, @_;
      push @parsed, [$c, @$args];
      @_ = @rest;
    } elsif ($o =~ s/^-//) {
      my ($op, @stuff) = grep length,
                         split /([:+^=%\/]?[a-zA-Z]|[-+\.0-9]+)/, $o;
      die "undefined short op: $op" unless exists $op_shorthand_lookups{$op};
      unshift @_, map $op_shorthand_lookups{$_} // $_, $op, @stuff;
    } else {
      push @parsed, file_opt $o;
    }
  }
  @parsed;
}
# Operator implementations

use B::Deparse;
use File::Temp qw/tmpnam/;

# Meta
defop 'self', undef, '',
  'adds the source code of ni',
  sub { $_[0] + ni_memory(self) };

defop 'explain-stream', undef, '',
  'explains the current stream',
  sub { ni_memory($_[0]->explain) };

defop 'explain-compilation', undef, '',
  'shows the compiled output for the current stream',
  sub {
    my $gen = $_[0]->source_gen(sink_as {
      with_input_type $_[0],
        gen 'print:LV', {}, "print STDOUT \$_;"});
    my $deparser = B::Deparse->new;
    my ($f, $refs) = $gen->compile_to_sub;
    delete $$refs{$_} for keys %$refs;
    ni_memory($deparser->coderef2text($f));
  };

defop 'defined-methods', undef, '',
  'lists defined long and short methods on IO objects',
  sub { ni_memory(map "$_\n", grep /^_/, sort keys %{ni::io::}) };

defop 'debug-compile', undef, '',
  'shows the compiled code generated for the given io',
  sub {
    my $gen = $_[0]->source_gen(sink_as {
                with_input_type $_[0],
                  gen 'print:LV', {}, "print STDOUT \$_;"});
    ni_memory("\nCOMPILED\n" . $gen->compile,
              "\n",
              "\nDEBUG\n"    . $gen->debug_to_string);
  };

# Stream transforms
defop 'plus', undef, '',
  'adds two streams together (implied for files)',
  sub { $_[0] + $_[1] };

defop 'tee', undef, 's',
  'tees current output into the specified io',
  sub { $_[0] >>= tee_binding(ni $_[1]) };

defop 'take', undef, 'd',
  'takes the first or last N records from the specified io',
  sub { $_[1] > 0 ? $_[0] >>= take_binding($_[1])
                  : ni_ring(-$_[1]) < $_[0] };

defop 'drop', undef, 'd',
  'drops the first or last N records from the specified io',
  sub {
    my ($self, $n) = @_;
    $n >= 0
      ? $self->bind(drop_binding($n))
      : ni_source_as("$self >>= drop " . -$n . "]", sub {
          my ($destination) = @_;
          $self->source_gen(ni_ring(-$n, $destination));
        });
  };

defop 'zip', 'z', 's',
  'zips lines together with those from the specified IO',
  sub { $_[0] >>= zip_binding(ni $_[1]) };

# Functional transforms
defop 'map', 'm', 's',
  'transforms each record using the specified function',
  sub { $_[0] * $_[1] };

defop 'keep', 'k', 's',
  'keeps records for which the function returns true',
  sub { $_[0] % $_[1] };

defop 'transform', 'M', 's',
  'transforms the stream as an object using the specified function',
  sub { compile($_[1])->($_[0]) };

defop 'deref', 'r', '',
  'interprets each record as a data source and emits it',
  sub { ni_cat($_[0] * \&ni) };

defop 'ref', 'R', 'V',
  'collects data into a file and emits the filename',
  sub { my ($self, $f) = @_;
        $self > ni($f //= "file:" . tmpnam);
        ni_memory($f) };

defop 'branch', 'b', 's',
  'splits input by its first field, forwarding to subprocesses',
  sub {
    my ($in, $subprocesses) = @_;
    my @subs = unpack_branch_map $subprocesses;
    my $fifo = ni::io::fifo->new->from(map ${$_}[1], @subs);

    unless (fork) {
      my $line;
      while (defined($line = <$in>)) {
        my ($k, $v) = split /\t/, $line, 2;
        for my $s (@subs) {
          if ($s->[0]->($k)) {
            $s->[1]->enqueue($line);
            last;
          }
        }
      }
      exit;
    }
    $fifo;
  };

# Sorting (shells out to command-line sort)
sub sort_options {
  my @fieldspec = split //, $_[0] // '';
  # TODO
}

defop 'order', 'o', 'AD',
  'order {n|N|g|G|l|L|u|U|m} [fields]',
  sub {
    my ($in, $flags, $fields) = @_;
    $in | 'sort';
  };
# Preprocess command line, collapsing stuff into array and hash references as
# appropriate.

use POSIX qw/dup2/;

sub preprocess_cli {
  my @preprocessed;
  for (my $o; defined($o = shift @_);) {
    if ($o =~ s/\[$//) {
      my @xs;
      my $depth = 1;
      for (@_) {
        last unless $depth -= /^\]$/;
        $depth += /\[$/;
        push @xs, $_;
      }
      push @preprocessed, bless [@xs], $o;
    } elsif ($o =~ s/\{$//) {
      my @xs;
      my $depth = 1;
      for (@_) {
        last unless $depth -= /^\}$/;
        $depth += /\{$/;
        push @xs, $_;
      }
      push @preprocessed, bless {@xs}, $o;
    } else {
      push @preprocessed, $o;
    }
  }
  @preprocessed;
}

sub stream_for {
  my ($stream, @options) = @_;
  $stream //= -t STDIN ? ni_sum() : ni_file('[stdin]', \*STDIN, undef);
  for (parse_commands @options) {
    my ($command, @args) = @$_;
    eval {$stream = $ni::io::{long_op_method $command}($stream, @args)};
    die "failed to apply stream command $command [@args] "
      . "(method: " . long_op_method($command) . "): $@" if $@;
  }
  $stream;
}

sub stream_to_process {
  my ($stream, @process_alternatives) = @_;
  my $fh = $stream->reader_fh;
  if (fileno $fh) {
    close STDIN;
    dup2 fileno $fh, 0 or die "dup2 failed: $!";
  }
  exec $_ for @process_alternatives;
}

sub main {
  $|++;
  my $data = stream_for undef, preprocess_cli @_;
  if (-t STDOUT && !exists $ENV{NI_NO_PAGER}) {
    # Use a pager rather than writing straight to the terminal
    stream_to_process $data, $ENV{NI_PAGER} // $ENV{PAGER} // 'less',
                             'more';

    # Ok, we're out of options; just write to the terminal after all
    print STDERR "ni: couldn't exec any pagers, writing to the terminal\n";
    print STDERR "ni: (sorry about this; if you set \$PAGER it should work)\n";
    print STDERR "\n";
    print while <>;
  } else {
    $data > \*STDOUT;
  }
}

END { main @ARGV }

}
__END__
