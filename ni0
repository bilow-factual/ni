#!/bin/sh
# Self-modifying ni image: https://github.com/spencertipping/ni
module_0='newline="$(printf "\\n ")" && newline="${newline% }"
module() {
  [ $# -eq 2 ] && module_v="$2" || module_v="$(cat)"
  eval "module_$module_index=\"\$module_v\""
  [ ${1%.sh} = $1 ] || eval "eval \"\$module_v\"" || echo "in module $1" >&2
  modules="$modules$newline$1"
  module_index=$((module_index + 1))
}
module_index=1
modules=boot.sh'
eval "$module_0"
module 'self/fs.sh' <<'EOF'
# Filesystem interop

# Usage: tmpdir destination_var
# Returns the original tmpdir if the destination var is already populated and
# exists.
tmpdir() {
  eval "[ -e \"\$${1:-self_tmpdir}/.this-is-a-ni-tmpdir\" ]" && return
  tmpdir_prefix="${TMPDIR:-/tmp}/ni-$$"
  tmpdir_index=0
  until mkdir "$tmpdir_prefix-$tmpdir_index" 2>/dev/null; do
    tmpdir_prefix=$((tmpdir_prefix + 1))
  done
  touch "$tmpdir_prefix-$tmpdir_index/.this-is-a-ni-tmpdir"
  eval "${1:-self_tmpdir}=\$tmpdir_prefix-\$tmpdir_index"
}

tmpdir_free() {
  [ $# -eq 0 ] && set -- "$self_tmpdir"
  if [ ! -e "$1/.this-is-a-ni-tmpdir" ]; then
    verb "ni: trying to clean up a tmpdir ($1)" \
         "    but this tmpdir doesn't appear to have been created by ni" \
         "    in this case, not doing anything" >&2
    return 1
  fi
  rm -r "$1"
}
EOF
module 'self/image.sh' <<'EOF'
# Safe echo: works around the POSIX statement that "echo" is allowed to
# interpret its arguments
verb() {
  for verb_arg; do
    printf "%s\n" "$verb_arg"
  done
}

# Retrieves a module's text by name
# Usage: module_get destination_var module/name
# Does nothing if the variable is already set, which makes it possible to use
# this function repeatedly without a performance hit.
module_get() {
  eval "[ -n \"\$$1\" ]" && return
  module_get_old_ifs="$IFS"
  IFS="$newline"
  module_get_i=0
  for module_get_name in $modules; do
    if [ "$2" = "$module_get_name" ]; then
      eval "$1=\"\$module_$module_get_i\""
      IFS="$module_get_old_ifs"
      return 0
    fi
    module_get_i=$((module_get_i + 1))
  done
  IFS="$module_get_old_ifs"
}

# The current image
self() {
  verb "#!/bin/sh" \
       "# Self-modifying ni image: https://github.com/spencertipping/ni" \
       "module_0='$module_0'" \
       'eval "$module_0"'

  self_old_ifs="$IFS"
  IFS="$newline"
  self_i=0
  for self_m in $modules; do
    if [ $self_m != boot.sh ]; then
      verb "module '$self_m' <<'EOF'"
      eval "verb \"\$module_$self_i\""
      verb "EOF"
    fi
    self_i=$((self_i + 1))
  done
  IFS="$self_old_ifs"
  verb 'main "$@"'
}
EOF
module 'self/sha3.sh' <<'EOF'
# Support for hashing arbitrary data through the jit-C interface
sha3() { sha3_setup; "$sha3_jit"; }
sha3_setup() {
  [ -n "$sha3_jit" ] && return
  module_get sha3_source bin/sha3.c
  sha3_jit="$(verb "$sha3_source" | jit_c)"
  unset sha3_source
}
EOF
module 'bin/sha3.c' <<'EOF'
/* Calculates the SHA3-256 of stdin and argv. This is used throughout ni to
 * cache intermediate results.
 *
 * Code from https://github.com/gvanas/KeccakCodePackage/blob/master/Standalone/CompactFIPS202/Keccak-more-compact.c;
 * modified here to read from a file descriptor and to alias pointers for a
 * speedup of about 4x */

#include <unistd.h>
#include <sys/types.h>

#define FOR(i,n) for(i=0; i<n; ++i)
typedef unsigned char u8;
typedef unsigned long long int u64;
typedef unsigned int ui;

void Keccak(ui r, ui c, const u8 *in, u64 inLen, u8 sfx, u8 *out, u64 outLen);

int LFSR86540(u8 *R) { (*R)=((*R)<<1)^(((*R)&0x80)?0x71:0); return ((*R)&2)>>1; }
#define ROL(a,o) ((((u64)a)<<o)^(((u64)a)>>(64-o)))
#define rL(x,y) (*(u64*)((u8*)s+8*(x+5*y)))
#define wL(x,y,l) (*(u64*)((u8*)s+8*(x+5*y))=(l))
#define XL(x,y,l) (*(u64*)((u8*)s+8*(x+5*y))^=(l))
void KeccakF1600(void *s)
{
    ui r,x,y,i,j,Y; u8 R=0x01; u64 C[5],D;
    for(i=0; i<24; i++) {
        /*θ*/ FOR(x,5) C[x]=rL(x,0)^rL(x,1)^rL(x,2)^rL(x,3)^rL(x,4); FOR(x,5) { D=C[(x+4)%5]^ROL(C[(x+1)%5],1); FOR(y,5) XL(x,y,D); }
        /*ρπ*/ x=1; y=r=0; D=rL(x,y); FOR(j,24) { r+=j+1; Y=(2*x+3*y)%5; x=y; y=Y; C[0]=rL(x,y); wL(x,y,ROL(D,r%64)); D=C[0]; }
        /*χ*/ FOR(y,5) { FOR(x,5) C[x]=rL(x,y); FOR(x,5) wL(x,y,C[x]^((~C[(x+1)%5])&C[(x+2)%5])); }
        /*ι*/ FOR(j,7) if (LFSR86540(&R)) XL(0,0,(u64)1<<((1<<j)-1));
    }
}
int main()
{
    /*initialize*/ u8 ia[65536], *in = ia, oa[32], *out = oa; u64 inLen; u8 s[200]; ui R=1088/8; ui i,b=0; u64 outLen=32; FOR(i,200) s[i]=0;
    /*absorb*/ while ((inLen = read(0, in = ia, 65536)) > 0) while(inLen>0) { b=(inLen<R)?inLen:R; FOR(i,b) s[i]^=in[i]; in+=b; inLen-=b; if (b==R) { KeccakF1600(s); b=0; } }
    /*pad*/ s[b]^=6; if((6&0x80)&&(b==(R-1))) KeccakF1600(s); s[R-1]^=0x80; KeccakF1600(s);
    /*squeeze*/ while(outLen>0) { b=(outLen<R)?outLen:R; FOR(i,b) out[i]=s[i]; out+=b; outLen-=b; if(outLen>0) KeccakF1600(s); }

    u8 oh[65], *hex="0123456789abcdef"; FOR(i, 32) { oh[i<<1]=hex[oa[i]>>4]; oh[i<<1|1]=hex[oa[i]&15]; }
    oh[64]='\n'; write(1, oh, 65); return 0;
}
EOF
module 'main.sh' <<'EOF'
main() {
  tmpdir
  sha3
  tmpdir_free
}
EOF
module 'jit/jit-c.sh' <<'EOF'
# JIT support for C99 programs
# Calling convention is like this:
#
# jit_c jit_program <<'EOF'
# #include <stdio.h>
# int main() {
#   printf("hello world\n");
#   return 0;
# }
# EOF
#
# $jit_program "$@"             # to execute the program
#
# Later on, you can free the jit context like this:
# jit_c_free $jit_program

jit_c_index=0
jit_c() {
  tmpdir
  jit_c_result="$1"
  shift
  jit_c_index=$((jit_c_index + 1))
  jit_c_source="$self_tmpdir/jit-c-$jit_c_index.c"
  cat "$@" > "$jit_c_source"
  c99 "$jit_c_source" -o "${jit_c_source%.c}"
  eval "$jit_c_result=\${jit_c_source%.c}"
}

jit_c_free() rm "$1" "$1.c"
EOF
module 'jit/jit-mvn.sh' <<'EOF'
# JVM JIT using maven as the frontend
# (this makes it easy to include dependencies)

# Takes a series of -D options -- basically everything after the first two
# given to jit_mvn -- and produces a POM XML file to stdout.
mvn_pom() {
  : TODO
}

# Usage: jit_mvn jit_program Foobar [-Dgroup/artifact=version ...] ... <<'EOF'
# public class Foobar {
#   public static void main(String[] args) {
#     System.out.println("hello world!");
#   }
# }
# EOF
#
# $jit_program "$@"
#
# jit_mvn_free $jit_program
jit_mvn() {
  jit_mvn_result=$1
  jit_mvn_main=$2
}
EOF
main "$@"
