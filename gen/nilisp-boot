#!/usr/bin/env perl
# ni lisp reader
# Produces a tree of blessed references representing the specified
# s-expression. Syntactically:
#
#   'foo\nbar'          string with a literal backslash-n in it
#   "foo\tbar"          string with tab character
#   foo                 quoted atom (analogous to 'foo in lisp)
#   $foo                variable reference (analogous to foo in lisp)
#   3.0                 numeric atom
#   [3 4 5]             array
#   {foo bar}           hash

{

package ni::lisp;

# NB: these are not perl OO constructors in the usual sense (i.e. they can't be
# called indirectly)
sub list   { bless \@_, "ni::lisp::list" }
sub array  { bless \@_, "ni::lisp::array" }
sub hash   { bless \@_, "ni::lisp::hash" }

sub qstr   { bless \$_[0], "ni::lisp::qstr" }
sub str    { bless \$_[0], "ni::lisp::str" }
sub symbol { bless \$_[0], "ni::lisp::symbol" }
sub number { bless \$_[0], "ni::lisp::number" }

our @parse_types = qw/ list array hash qstr str symbol number /;
our %overloads   = qw/ "" str /;

for (@parse_types) {
  eval "package ni::lisp::$_; use overload qw#" . join(' ', %overloads) . "#;";
  die $@ if $@;
}

push @{"ni::lisp::${_}::ISA"}, "ni::lisp::val" for @parse_types;

sub deftypemethod {
  my ($name, %alternatives) = @_;
  *{"ni::lisp::${_}::$name"} = $alternatives{$_} // sub { 0 } for @parse_types;
}

deftypemethod 'str',
  list   => sub { '(' . join(' ', @{$_[0]}) . ')' },
  array  => sub { '[' . join(' ', @{$_[0]}) . ']' },
  hash   => sub { '{' . join(' ', @{$_[0]}) . '}' },
  qstr   => sub { "'" . ${$_[0]} . "'" },
  str    => sub { '"' . ${$_[0]} . '"' },
  symbol => sub { length ${$_[0]} ? ${$_[0]} : '<ESYM>' },
  number => sub { ${$_[0]} };

our %bracket_types = (
  ')' => \&ni::lisp::list,
  ']' => \&ni::lisp::array,
  '}' => \&ni::lisp::hash,
);

sub parse {
  local $_;
  my @stack = [];
  while ($_[0] =~ / \G (?: (?<comment> \#.*)
                         | (?<ws>      [\s,]+)
                         | '(?<qstr>   (?:[^\\']|\\.)*)'
                         | "(?<str>    (?:[^\\"]|\\.)*)"
                         | (?<number>  (?: [-+]?[0-9]*\.[0-9]+([eE][0-9]+)?
                                         | 0x[0-9a-fA-F]+
                                         | 0[0-7]+
                                         | [1-9][0-9]*))
                         | (?<symbol>  [^"()\[\]{}\s,]+)
                         | (?<opener>  [(\[{])
                         | (?<closer>  [)\]}])) /gx) {
    next if exists $+{comment} || exists $+{ws};
    if ($+{opener}) {
      push @stack, [];
    } elsif ($+{closer}) {
      my $last = pop @stack;
      die "too many closing brackets" unless @stack;
      push @{$stack[-1]}, $bracket_types{$+{closer}}->(@$last);
    } else {
      my @types = keys %+;
      my $v     = $+{$types[0]};
      die "FIXME: got @types" unless @types == 1;
      push @{$stack[-1]}, &{"ni::lisp::$types[0]"}($v);
    }
  }
  die "unbalanced brackets: " . scalar(@stack) . " != 1"
    unless @stack == 1;
  @{$stack[0]};
}

}
# A very literal encoding of CPS into Perl lambdas. Not fast at all. This
# literal encoding means we don't need to do our own lexical scope analysis or
# write a GC.

{

package ni::lisp;

use constant DEBUG => 1;

sub compile_list;
sub array_literal;
sub hash_literal;
sub qstr_literal;
sub str_literal;
sub var_reference;
sub num_literal;
sub function_call;

our $gensym_id = 0;
sub gensym { ($_[0] // 'gensym') . ++$gensym_id }

sub perlize_name { $_[0] =~ s/([^A-Za-z_])/"_".ord($1)/egr }

deftypemethod 'compile',
  list   => sub { compile_list  @{$_[0]} },
  array  => sub { array_literal map $_->compile, @{$_[0]} },
  hash   => sub { hash_literal  map $_->compile, @{$_[0]} },
  qstr   => sub { qstr_literal  ${$_[0]} },
  str    => sub { str_literal   ${$_[0]} },
  symbol => sub { var_reference ${$_[0]} },
  number => sub { num_literal   ${$_[0]} };

# CPS transformation happens at the macroexpansion level, so by this point the
# whole program is represented in terms of CPS lambdas and associated special
# forms.
our %special_forms = (
  'fn*' => sub {
    my ($formals, $body) = @_;
    die "formals must be specified as an array or symbol (got $formals)"
      unless ref $formals eq 'ni::lisp::array'
          || ref $formals eq 'ni::lisp::symbol';

    my $formal_binding =
      ref $formals eq 'ni::lisp::array'
        ? "my (" . join(', ', map "\$" . perlize_name($$_), @$formals)
                 . ") = \@_"
        : "my \$" . perlize_name($$formals) . " = \\\@_";
    my $compiled_body  = $body->compile;
    my $result_gensym  = gensym 'result';

    DEBUG ? qq{ sub {
              $formal_binding;
              my \$$result_gensym = eval {
                $compiled_body;
              };
              die q{((fn* $formals $body) }.join(" ", \@_).qq{): \$@} if \$@;
              \$$result_gensym;
            } }
          : qq{ sub {
              $formal_binding;
              $compiled_body;
            } };
  },

  'nth*' => sub {
    my ($k, $n, @vs) = map $_->compile, @_;
    my $v_options    = join ', ', @vs;
    qq{ ($k)->(($v_options)[$n]) };
  },

  # We have no concurrency in the bootstrap layer, so just execute each
  # continuation in sequence and collect results. This implementation is
  # semantically correct up to GC properties.
  'co*' => sub {
    my ($k, @fs) = map $_->compile, @_;
    my $k_gs     = gensym 'k';
    my $i_gs     = gensym 'indexes';
    my $n        = @fs;
    my @ks       = map qq[ sub { \$$i_gs]."{$_}".qq[ = \$_[0];
                                 \$$k_gs->(map \$$i_gs]."{\$_}".qq[, 0..$#_)
                                   if scalar(keys \%$i_gs) == $n; }],
                       0..$#fs;

    my $calls    = join "\n", map qq{ ($fs[$_])->($ks[$_]); }, 0..$#fs;

    qq{
      my \$$k_gs = $k;
      my \%$i_gs;
      $calls;
    };
  },

  # For now, choose the first alternative every time. Others don't need to even
  # be compiled because they're all semantically equivalent.
  'amb*' => sub {
    my ($k, $f) = map $_->compile, @_;
    qq{ ($f)->($k); };
  },
);

sub compile_list {
  my ($h, @xs) = @_;
  ref $h eq 'ni::lisp::symbol' && exists $special_forms{$$h}
    ? $special_forms{$$h}->(@xs)
    : function_call($h, @xs);
}

sub array_literal { "[" . join(', ', @_) . "]" }
sub hash_literal  { "{" . join(', ', @_) . "}" }
sub qstr_literal  { "'$_[0]'" }
sub str_literal   { "\"$_[0]\"" }
sub var_reference { "\$" . perlize_name($_[0]) }
sub num_literal   { $_[0] }

sub function_call {
  my ($f, @xs) = map $_->compile, @_;
  $f . "->(" . join(", ", @xs) . ")";
}

# I don't want to write the following in CPS, so here's a Perl-hosted version.
# This method assumes that your form has already been macroexpanded, and is not
# idempotent at all (!!!).
sub cps_wrap {
  my $k_gensym = symbol gensym 'k';
  list symbol('fn*'), array($k_gensym), $_[0]->cps_convert($k_gensym);
}

our %cps_special_forms = (
  'fn*' => sub {
    my ($k_form, $formals, $body) = @_;
    my $k_gensym = symbol gensym 'k';

    # Two possibilities. If the function is variadic, then we need to generate
    # runtime code that splits the continuation off the end and saves it.
    if (ref $formals eq 'ni::lisp::array') {
      # Easy case: just add an extra formal for the continuation.
      list $k_form,
           list symbol('fn*'),
                array($k_gensym, @$formals),
                $body->cps_convert($k_gensym);
    } else {
      # Hard case: generate CPS-converted runtime code.
      my $formals_gensym = symbol gensym 'kf';
      list $k_form,
           list symbol('fn*'),
                $formals_gensym,
                list symbol('uncons'),
                     list(symbol('fn*'),
                          array($k_gensym, $formals),
                          $body->cps_convert($k_gensym)),
                     $formals_gensym;
    }
  },

  'nth*' => sub {
    my $k_form = shift @_;
    my @gensyms = map symbol(gensym 'x'), @_;
    list symbol('co*'),
         list(symbol('fn*'),
              array(@gensyms),
              list symbol('nth*'), $k_form, @gensyms),
         map(cps_wrap($_), @_);
  },

  'co*' => sub {
    my $k_form = shift @_;
    list symbol('co*'), $k_form, map cps_wrap($_), @_;
  },

  'amb*' => sub {
    my $k_form = shift @_;
    list symbol('amb*'), $k_form, map cps_wrap($_), @_;
  },
);

sub cps_convert_call {
  my ($k_form, $f, @xs) = @_;
  my $f_gensym = symbol gensym(ref $f eq 'ni::lisp::symbol' ? $$f : 'f');
  my @gensyms = map symbol(gensym 'x'), @xs;
  list symbol('co*'),
       list(symbol('fn*'),
            array($f_gensym, @gensyms),
            list $f_gensym, $k_form, @gensyms),
       map cps_wrap($_), $f, @xs;
}

sub cps_constant {
  my ($self, $k_form) = @_;
  list $k_form, $self;
}

deftypemethod 'cps_convert',
  list => sub {
    my ($self, $k_form) = @_;
    my ($h, @xs) = @$self;
    ref $h eq 'ni::lisp::symbol' && exists $cps_special_forms{$$h}
      ? $cps_special_forms{$$h}->($k_form, @xs)
      : cps_convert_call $k_form, $h, @xs;
  },
  array => sub {
    my ($self, $k_form) = @_;
    my @gensyms = map symbol(gensym 'x'), @$self;
    list symbol('co*'),
         list(symbol('fn*'),
              array(@gensyms),
              list $k_form, array(@gensyms)),
         map cps_wrap($_), @$self;
  },
  hash => sub {
    my ($self, $k_form) = @_;
    my @gensyms = map symbol(gensym 'x'), @$self;
    list symbol('co*'),
         list(symbol('fn*'),
              array(@gensyms),
              list $k_form, hash(@gensyms)),
         map cps_wrap($_), @$self;
  },
  qstr   => \&cps_constant,
  str    => \&cps_constant,
  symbol => \&cps_constant,
  number => \&cps_constant;

}
# Really simple macroexpander
{

package ni::lisp;

%ni::lisp::macros = ();

deftypemethod 'macroexpand',
  list => sub {
    my ($self, $macros) = @_;
    my ($h, @xs) = @$self;
    $macros //= \%ni::lisp::macros;

    unless (ref $h eq 'ni::lisp::symbol' && exists $$macros{$$h}) {
      my @macroexpanded = eval { map $_->macroexpand($macros), @$self };
      die "failed to macroexpand $self: $@" if $@;
      ni::lisp::list @macroexpanded;
    } else {
      my $return;
      $$macros{$$h}->(sub { $return = $_[0] }, @xs);
      $return->macroexpand($macros);
    }
  },

  array  => sub { ni::lisp::array map $_->macroexpand($_[1]), @{$_[0]} },
  hash   => sub { ni::lisp::hash  map $_->macroexpand($_[1]), @{$_[0]} },
  qstr   => sub { $_[0] },
  str    => sub { $_[0] },
  symbol => sub { $_[0] },
  number => sub { $_[0] };

}
# Takes a regular Perl sub and makes it work with CPS
sub cps {
  my ($f) = @_;
  sub {
    my ($k, @xs) = @_;
    $k->($f->(@xs));
  };
}

sub defcps { ${ni::lisp::perlize_name $_[0]} = cps $_[1] }

defcps 'gensym',  sub { ni::lisp::symbol ni::lisp::gensym @_ };
defcps 'sym-str', sub { ni::lisp::str ${$_[0]} };
defcps 'str-sym', sub { ni::lisp::symbol $_[0] };

defcps 'to-array', sub { ni::lisp::array @{$_[0]} };
defcps 'to-hash',  sub { ni::lisp::hash  @{$_[0]} };
defcps 'to-list',  sub { ni::lisp::list  @{$_[0]} };

defcps 'aget', sub { $_[0]->[$_[1]] };

defcps 'type', sub { ref($_[0]) =~ s/.*:://r };

defcps 'car',    sub { my ($l) = @_; $$l[0] };
defcps 'cdr',    sub { my ($l) = @_; ni::lisp::list(@$l[1..$#{$l}]) };
defcps 'cons',   sub { my ($a, $d) = @_; ni::lisp::list($a, @$d) };
defcps 'uncons', sub { my ($l) = @_; ($$l[0], ni::lisp::list(@$l[1..$#{$l}])) };
defcps 'list',   sub { ni::lisp::list(@_) };
defcps 'nil',    sub { ni::lisp::list() };
defcps 'count',  sub { scalar(@{$_[0]}) };
defcps '=',      sub { "$_[0]" eq "$_[1]" ? 1 : 0 };
defcps '>',      sub { $_[0] > $_[1] ? 1 : 0 };
defcps 'not',    sub { $_[0] ? 0 : 1 };
defcps 'print',  sub { print join(' ', @_), "\n" };

defcps 'macroexpand', sub { $_[0]->macroexpand };
defcps 'eval',        sub { my $c = $_[0]->compile;
                            my $r = eval $c;
                            die "failed to eval $_[0] -> $c: $@" if $@;
                            $r };

defcps 'defcps*', sub {
  my ($name, $value) = @_;
  ${ni::lisp::perlize_name $name} = $value;
  $name;
};

defcps 'defmacrocps*', sub {
  my ($name, $value) = @_;
  $ni::lisp::macros{$name} = $value;
  $name;
};

defcps 'cps-convert', sub { $_[0]->cps_convert($_[1]) };
use B::Deparse;
my $deparser = B::Deparse->new;

for my $f (ni::lisp::parse join '', <>) {
  my $m = eval { $f->macroexpand };
  die "error macroexpanding $f: $@" if $@;

  my $c        = $m->compile;
  my $coderef  = eval "sub{\n$c\n}";
  die "error compiling coderef $c: $@" if $@;
  my $readable = $deparser->coderef2text($coderef);
  my $r = eval $c;
  die "error evaluating compilation for $f -> $m -> $readable: $@" if $@;
  print STDERR "> $f\n= $r\n";
}
