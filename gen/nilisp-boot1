#!/usr/bin/env perl
# ni lisp reader
# Produces a tree of blessed references representing the specified
# s-expression. Syntactically:
#
#   'foo\nbar'          string with a literal backslash-n in it
#   "foo\tbar"          string with tab character
#   foo                 quoted atom (analogous to 'foo in lisp)
#   $foo                variable reference (analogous to foo in lisp)
#   3.0                 numeric atom
#   [3 4 5]             array
#   {foo bar}           hash

{

package ni::lisp;

# NB: these are not perl OO constructors in the usual sense (i.e. they can't be
# called indirectly)
sub list   { bless \@_, "ni::lisp::list" }
sub array  { bless \@_, "ni::lisp::array" }
sub hash   { bless \@_, "ni::lisp::hash" }

sub qstr   { bless \$_[0], "ni::lisp::qstr" }
sub str    { bless \$_[0], "ni::lisp::str" }
sub symbol { bless \$_[0], "ni::lisp::symbol" }
sub number { bless \$_[0], "ni::lisp::number" }

our @parse_types = qw/ list array hash qstr str symbol number /;
our %overloads   = qw/ "" str /;

for (@parse_types) {
  eval "package ni::lisp::$_; use overload qw#" . join(' ', %overloads) . "#;";
  die $@ if $@;
}

push @{"ni::lisp::${_}::ISA"}, "ni::lisp::val" for @parse_types;

sub deftypemethod {
  my ($name, %alternatives) = @_;
  *{"ni::lisp::${_}::$name"} = $alternatives{$_} // sub { 0 } for @parse_types;
}

deftypemethod 'str',
  list   => sub { '(' . join(' ', @{$_[0]}) . ')' },
  array  => sub { '[' . join(' ', @{$_[0]}) . ']' },
  hash   => sub { '{' . join(' ', @{$_[0]}) . '}' },
  qstr   => sub { "'" . ${$_[0]} . "'" },
  str    => sub { '"' . ${$_[0]} . '"' },
  symbol => sub { length ${$_[0]} ? ${$_[0]} : '<ESYM>' },
  number => sub { ${$_[0]} };

sub indent { '  ' x $_[0] }
deftypemethod 'pprint',
  list   => sub { indent($_[1]) .
                  (length($_[0]->str) > 80 - 2 * $_[1]
                    ? "(\n"
                      . join("\n", map $_->pprint($_[1] + 1), @{$_[0]})
                      . ")"
                    : $_[0]->str) },

  array  => sub { indent($_[1]) .
                  (length($_[0]->str) > 80 - 2 * $_[1]
                    ? "[\n"
                      . join("\n", map $_->pprint($_[1] + 1), @{$_[0]})
                      . "]"
                    : $_[0]->str) },

  hash   => sub { indent($_[1]) .
                  (length($_[0]->str) > 80 - 2 * $_[1]
                    ? "{\n"
                      . join("\n", map $_->pprint($_[1] + 1), @{$_[0]})
                      . "}"
                    : $_[0]->str) },

  qstr   => sub { indent($_[1]) . $_[0] },
  str    => sub { indent($_[1]) . $_[0] },
  symbol => sub { indent($_[1]) . $_[0] },
  number => sub { indent($_[1]) . $_[0] };

our %bracket_types = (
  ')' => \&ni::lisp::list,
  ']' => \&ni::lisp::array,
  '}' => \&ni::lisp::hash,
);

sub parse {
  local $_;
  my @stack = [];
  while ($_[0] =~ / \G (?: (?<comment> \#.*)
                         | (?<ws>      [\s,]+)
                         | '(?<qstr>   (?:[^\\']|\\.)*)'
                         | "(?<str>    (?:[^\\"]|\\.)*)"
                         | (?<number>  (?: [-+]?[0-9]*\.[0-9]+([eE][0-9]+)?
                                         | 0x[0-9a-fA-F]+
                                         | 0[0-7]+
                                         | [1-9][0-9]*
                                         | 0))
                         | (?<symbol>  [^"()\[\]{}\s,]+)
                         | (?<opener>  [(\[{])
                         | (?<closer>  [)\]}])) /gx) {
    next if exists $+{comment} || exists $+{ws};
    if ($+{opener}) {
      push @stack, [];
    } elsif ($+{closer}) {
      my $last = pop @stack;
      die "too many closing brackets" unless @stack;
      push @{$stack[-1]}, $bracket_types{$+{closer}}->(@$last);
    } else {
      my @types = keys %+;
      my $v     = $+{$types[0]};
      die "FIXME: got @types" unless @types == 1;
      push @{$stack[-1]}, &{"ni::lisp::$types[0]"}($v);
    }
  }
  die "unbalanced brackets: " . scalar(@stack) . " != 1"
    unless @stack == 1;
  @{$stack[0]};
}

}
# A very literal encoding of CPS into Perl lambdas. Not fast at all. This
# literal encoding means we don't need to do our own lexical scope analysis or
# write a GC.

{

package ni::lisp;

use constant DEBUG => 0;

sub compile_list;
sub array_literal;
sub hash_literal;
sub qstr_literal;
sub str_literal;
sub var_reference;
sub num_literal;
sub function_call;

our $gensym_id = 0;
sub gensym { ($_[0] // 'gensym') . ++$gensym_id }

sub perlize_name { $_[0] =~ s/([^A-Za-z0-9_])/"_".ord($1)/egr }

deftypemethod 'compile',
  list   => sub { compile_list  @{$_[0]} },
  array  => sub { array_literal map $_->compile, @{$_[0]} },
  hash   => sub { hash_literal  map $_->compile, @{$_[0]} },
  qstr   => sub { qstr_literal  ${$_[0]} },
  str    => sub { str_literal   ${$_[0]} },
  symbol => sub { var_reference ${$_[0]} },
  number => sub { num_literal   ${$_[0]} };

# CPS transformation happens at the macroexpansion level, so by this point the
# whole program is represented in terms of CPS lambdas and associated special
# forms.
our %special_forms = (
  'fn*' => sub {
    my ($formals, $body) = @_;
    die "formals must be specified as an array or symbol (got $formals)"
      unless ref $formals eq 'ni::lisp::array'
          || ref $formals eq 'ni::lisp::symbol';

    my $formal_binding =
      ref $formals eq 'ni::lisp::array'
        ? "my (" . join(', ', map "\$" . perlize_name($$_), @$formals)
                 . ") = \@_"
        : "my \$" . perlize_name($$formals) . " = \\\@_";
    my $compiled_body  = $body->compile;
    my $result_gensym  = gensym 'result';

    DEBUG ? qq{ sub {
              $formal_binding;
              my \$$result_gensym = eval {
                $compiled_body;
              };
              die q{((fn* $formals $body) }.join(" ", \@_).qq{): \$@} if \$@;
              \$$result_gensym;
            } }
          : qq{ sub {
              $formal_binding;
              $compiled_body;
            } };
  },

  'nth*' => sub {
    my ($k, $n, @vs) = map $_->compile, @_;
    my $v_options    = join ', ', @vs;
    qq{ ($k)->(($v_options)[$n]) };
  },

  # We have no concurrency in the bootstrap layer, so just execute each
  # continuation in sequence and collect results. This implementation is
  # semantically correct up to GC properties.
  'co*' => sub {
    my ($k, @fs) = map $_->compile, @_;
    my $k_gs     = gensym 'k';
    my $i_gs     = gensym 'indexes';
    my $n        = @fs;
    my @ks       = map qq[ sub { \$$i_gs]."{$_}".qq[ = \$_[0];
                                 \$$k_gs->(map \$$i_gs]."{\$_}".qq[, 0..$#_)
                                   if scalar(keys \%$i_gs) == $n; }],
                       0..$#fs;

    my $calls    = join "\n", map qq{ ($fs[$_])->($ks[$_]); }, 0..$#fs;

    qq{
      my \$$k_gs = $k;
      my \%$i_gs;
      $calls;
    };
  },

  # For now, choose the first alternative every time. Others don't need to even
  # be compiled because they're all semantically equivalent.
  'amb*' => sub {
    my ($k, $f) = map $_->compile, @_;
    qq{ ($f)->($k); };
  },
);

sub compile_list {
  my ($h, @xs) = @_;
  ref $h eq 'ni::lisp::symbol' && exists $special_forms{$$h}
    ? $special_forms{$$h}->(@xs)
    : function_call($h, @xs);
}

sub array_literal { "[" . join(', ', @_) . "]" }
sub hash_literal  { "{" . join(', ', @_) . "}" }
sub qstr_literal  { "'$_[0]'" }
sub str_literal   { "\"$_[0]\"" }
sub var_reference { "\$" . perlize_name($_[0]) }
sub num_literal   { $_[0] }

sub function_call {
  my ($f, @xs) = map $_->compile, @_;
  $f . "->(" . join(", ", @xs) . ")";
}

# I don't want to write the following in CPS, so here's a Perl-hosted version.
# This method assumes that your form has already been macroexpanded, and is not
# idempotent at all (!!!).
sub cps_wrap {
  my $k_gensym = symbol gensym 'k';
  list symbol('fn*'), array($k_gensym), $_[0]->cps_convert($k_gensym);
}

our %cps_special_forms = (
  'fn*' => sub {
    my ($k_form, $formals, $body) = @_;
    my $k_gensym = symbol gensym 'k';

    # Two possibilities. If the function is variadic, then we need to generate
    # runtime code that splits the continuation off the end and saves it.
    if (ref $formals eq 'ni::lisp::array') {
      # Easy case: just add an extra formal for the continuation.
      list $k_form,
           list symbol('fn*'),
                array($k_gensym, @$formals),
                $body->cps_convert($k_gensym);
    } else {
      # Hard case: generate CPS-converted runtime code.
      my $formals_gensym = symbol gensym 'kf';
      list $k_form,
           list symbol('fn*'),
                $formals_gensym,
                list symbol('uncons'),
                     list(symbol('fn*'),
                          array($k_gensym, $formals),
                          $body->cps_convert($k_gensym)),
                     $formals_gensym;
    }
  },

  'nth*' => sub {
    my $k_form = shift @_;
    my @gensyms = map symbol(gensym 'x'), @_;
    list symbol('co*'),
         list(symbol('fn*'),
              array(@gensyms),
              list symbol('nth*'), $k_form, @gensyms),
         map(cps_wrap($_), @_);
  },

  'co*' => sub {
    my $k_form = shift @_;
    list symbol('co*'), $k_form, map cps_wrap($_), @_;
  },

  'amb*' => sub {
    my $k_form = shift @_;
    list symbol('amb*'), $k_form, map cps_wrap($_), @_;
  },
);

sub cps_convert_call {
  my ($k_form, $f, @xs) = @_;
  my $f_gensym = symbol gensym(ref $f eq 'ni::lisp::symbol' ? $$f : 'f');
  my @gensyms = map symbol(gensym 'x'), @xs;
  list symbol('co*'),
       list(symbol('fn*'),
            array($f_gensym, @gensyms),
            list $f_gensym, $k_form, @gensyms),
       map cps_wrap($_), $f, @xs;
}

sub cps_constant {
  my ($self, $k_form) = @_;
  list $k_form, $self;
}

deftypemethod 'cps_convert',
  list => sub {
    my ($self, $k_form) = @_;
    my ($h, @xs) = @$self;
    ref $h eq 'ni::lisp::symbol' && exists $cps_special_forms{$$h}
      ? $cps_special_forms{$$h}->($k_form, @xs)
      : cps_convert_call $k_form, $h, @xs;
  },
  array => sub {
    my ($self, $k_form) = @_;
    my @gensyms = map symbol(gensym 'x'), @$self;
    list symbol('co*'),
         list(symbol('fn*'),
              array(@gensyms),
              list $k_form, array(@gensyms)),
         map cps_wrap($_), @$self;
  },
  hash => sub {
    my ($self, $k_form) = @_;
    my @gensyms = map symbol(gensym 'x'), @$self;
    list symbol('co*'),
         list(symbol('fn*'),
              array(@gensyms),
              list $k_form, hash(@gensyms)),
         map cps_wrap($_), @$self;
  },
  qstr   => \&cps_constant,
  str    => \&cps_constant,
  symbol => \&cps_constant,
  number => \&cps_constant;

}
# Really simple macroexpander
{

package ni::lisp;

%ni::lisp::macros = ();

deftypemethod 'macroexpand',
  list => sub {
    my ($self, $macros) = @_;
    my ($h, @xs) = @$self;
    $macros //= \%ni::lisp::macros;

    unless (ref $h eq 'ni::lisp::symbol' && exists $$macros{$$h}) {
      my @macroexpanded = eval { map $_->macroexpand($macros), @$self };
      die "failed to macroexpand $self: $@" if $@;
      ni::lisp::list @macroexpanded;
    } else {
      my $return;
      $$macros{$$h}->(sub { $return = $_[0] }, @xs);
      $return->macroexpand($macros);
    }
  },

  array  => sub { ni::lisp::array map $_->macroexpand($_[1]), @{$_[0]} },
  hash   => sub { ni::lisp::hash  map $_->macroexpand($_[1]), @{$_[0]} },
  qstr   => sub { $_[0] },
  str    => sub { $_[0] },
  symbol => sub { $_[0] },
  number => sub { $_[0] };

}
# Takes a regular Perl sub and makes it work with CPS
sub cps {
  my ($f) = @_;
  sub { $_[0]->($f->(@_[1..$#_])) };
}

sub defcps { ${ni::lisp::perlize_name $_[0]} = cps $_[1] }

defcps 'gensym',  sub { ni::lisp::symbol ni::lisp::gensym @_ };
defcps 'sym-str', sub { ni::lisp::str ${$_[0]} };
defcps 'str-sym', sub { ni::lisp::symbol $_[0] };

defcps 'to-array', sub { ni::lisp::array @{$_[0]} };
defcps 'to-hash',  sub { ni::lisp::hash  @{$_[0]} };
defcps 'to-list',  sub { ni::lisp::list  @{$_[0]} };

defcps 'aget',   sub { $_[0]->[$_[1]] };
defcps 'type',   sub { ref($_[0]) =~ s/.*:://r };

defcps 'car',    sub { my ($l) = @_; $$l[0] };
defcps 'cdr',    sub { my ($l) = @_; ni::lisp::list(@$l[1..$#{$l}]) };
defcps 'cons',   sub { my ($a, $d) = @_; ni::lisp::list($a, @$d) };
defcps 'uncons', sub { my ($l) = @_; ($$l[0], ni::lisp::list(@$l[1..$#{$l}])) };
defcps 'list',   sub { ni::lisp::list(@_) };
defcps 'nil',    sub { ni::lisp::list() };
defcps 'count',  sub { scalar(@{$_[0]}) };
defcps '=',      sub { "$_[0]" eq "$_[1]" ? 1 : 0 };
defcps '>',      sub { $_[0] > $_[1] ? 1 : 0 };
defcps 'not',    sub { $_[0] ? 0 : 1 };
defcps 'print',  sub { print STDERR join(' ', @_), "\n" };
defcps 'apply',  sub { $_[0]->(@_[1..$#_]) };

defcps $_, eval "sub { \$_[0] $_ \$_[1] }" for qw# + - * / % ** << >> ^ & | #;

defcps 'macroexpand', sub { $_[0]->macroexpand };
defcps 'eval',        sub { my $c = $_[0]->compile;
                            my $r = eval $c;
                            die "failed to eval $_[0] -> $c: $@" if $@;
                            $r };

defcps 'defcps*', sub {
  my ($name, $value) = @_;
  ${ni::lisp::perlize_name $name} = $value;
  $name;
};

defcps 'defmacrocps*', sub {
  my ($name, $value) = @_;
  $ni::lisp::macros{$name} = $value;
  $name;
};

defcps 'cps-convert', sub { $_[0]->cps_convert($_[1]) };


=begin comment

(defcps* (fn* [x] x) 'id*' (fn* [x] x))

=end comment

=cut

$defcps_42->( sub {
 my ($x) = @_;
 $x;
 } , 'id*', sub {
 my ($x) = @_;
 $x;
 } );


=begin comment

(defcps* id* 'call/cc' (fn* [k f] (f k k)))

=end comment

=cut

$defcps_42->($id_42, 'call/cc', sub {
 my ($k, $f) = @_;
 $f->($k, $k);
 } );


=begin comment

(
  defmacrocps*
  id*
  'cps*'
  (
    fn*
    [k form]
    (
      macroexpand
      (
        fn*
        [mform]
        (
          co*
          (
            fn*
            [fnsym xsym xsymarray]
            (
              list
              (fn* [k-form] (cps-convert k mform k-form))
              fnsym
              xsymarray
              xsym))
          (fn* [k1] (str-sym k1 'fn*' k1))
          (fn* [k2] (str-sym k2 'x' k2))
          (
            fn*
            [k3]
            (
              str-sym
              (fn* [xsym] (list (fn* [xsymlist] (to-array k3 xsymlist)) xsym))
              'x'))))
      form)))

=end comment

=cut

$defmacrocps_42->($id_42, 'cps*', sub {
 my ($k, $form) = @_;
 $macroexpand->( sub {
 my ($mform) = @_;
 
 my $k11 = sub {
 my ($fnsym, $xsym, $xsymarray) = @_;
 $list->( sub {
 my ($k_45form) = @_;
 $cps_45convert->($k, $mform, $k_45form);
 } , $fnsym, $xsymarray, $xsym);
 } ;
 my %indexes12;
 ( sub {
 my ($k1) = @_;
 $str_45sym->($k1, 'fn*', $k1);
 } )->( sub { $indexes12{0} = $_[0];
 $k11->(map $indexes12{$_}, 0..3)
 if scalar(keys %indexes12) == 3; }); 
 ( sub {
 my ($k2) = @_;
 $str_45sym->($k2, 'x', $k2);
 } )->( sub { $indexes12{1} = $_[0];
 $k11->(map $indexes12{$_}, 0..3)
 if scalar(keys %indexes12) == 3; }); 
 ( sub {
 my ($k3) = @_;
 $str_45sym->( sub {
 my ($xsym) = @_;
 $list->( sub {
 my ($xsymlist) = @_;
 $to_45array->($k3, $xsymlist);
 } , $xsym);
 } , 'x');
 } )->( sub { $indexes12{2} = $_[0];
 $k11->(map $indexes12{$_}, 0..3)
 if scalar(keys %indexes12) == 3; }); ;
 ;
 } , $form);
 } );


=begin comment

(
  defmacrocps*
  id*
  'defmacro'
  (
    (fn* [x] x)
    (
      fn*
      [k15 name f]
      (
        co*
        (fn* [list16 x17 x18 x19 x20] (list16 k15 x17 x18 x19 x20))
        (fn* [k21] (k21 list))
        (
          fn*
          [k22]
          (
            co*
            (fn* [str-sym23 x24] (str-sym23 k22 x24))
            (fn* [k25] (k25 str-sym))
            (fn* [k26] (k26 'defmacrocps*'))))
        (
          fn*
          [k27]
          (
            co*
            (fn* [str-sym28 x29] (str-sym28 k27 x29))
            (fn* [k30] (k30 str-sym))
            (fn* [k31] (k31 'id*'))))
        (
          fn*
          [k32]
          (
            co*
            (fn* [sym-str33 x34] (sym-str33 k32 x34))
            (fn* [k35] (k35 sym-str))
            (fn* [k36] (k36 name))))
        (
          fn*
          [k37]
          (
            co*
            (fn* [list38 x39 x40] (list38 k37 x39 x40))
            (fn* [k41] (k41 list))
            (
              fn*
              [k42]
              (
                co*
                (fn* [str-sym43 x44] (str-sym43 k42 x44))
                (fn* [k45] (k45 str-sym))
                (fn* [k46] (k46 'cps*'))))
            (fn* [k47] (k47 f))))))))

=end comment

=cut

$defmacrocps_42->($id_42, 'defmacro', sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k15, $name, $f) = @_;
 
 my $k81 = sub {
 my ($list16, $x17, $x18, $x19, $x20) = @_;
 $list16->($k15, $x17, $x18, $x19, $x20);
 } ;
 my %indexes82;
 ( sub {
 my ($k21) = @_;
 $k21->($list);
 } )->( sub { $indexes82{0} = $_[0];
 $k81->(map $indexes82{$_}, 0..5)
 if scalar(keys %indexes82) == 5; }); 
 ( sub {
 my ($k22) = @_;
 
 my $k54 = sub {
 my ($str_45sym23, $x24) = @_;
 $str_45sym23->($k22, $x24);
 } ;
 my %indexes55;
 ( sub {
 my ($k25) = @_;
 $k25->($str_45sym);
 } )->( sub { $indexes55{0} = $_[0];
 $k54->(map $indexes55{$_}, 0..2)
 if scalar(keys %indexes55) == 2; }); 
 ( sub {
 my ($k26) = @_;
 $k26->('defmacrocps*');
 } )->( sub { $indexes55{1} = $_[0];
 $k54->(map $indexes55{$_}, 0..2)
 if scalar(keys %indexes55) == 2; }); ;
 ;
 } )->( sub { $indexes82{1} = $_[0];
 $k81->(map $indexes82{$_}, 0..5)
 if scalar(keys %indexes82) == 5; }); 
 ( sub {
 my ($k27) = @_;
 
 my $k60 = sub {
 my ($str_45sym28, $x29) = @_;
 $str_45sym28->($k27, $x29);
 } ;
 my %indexes61;
 ( sub {
 my ($k30) = @_;
 $k30->($str_45sym);
 } )->( sub { $indexes61{0} = $_[0];
 $k60->(map $indexes61{$_}, 0..2)
 if scalar(keys %indexes61) == 2; }); 
 ( sub {
 my ($k31) = @_;
 $k31->('id*');
 } )->( sub { $indexes61{1} = $_[0];
 $k60->(map $indexes61{$_}, 0..2)
 if scalar(keys %indexes61) == 2; }); ;
 ;
 } )->( sub { $indexes82{2} = $_[0];
 $k81->(map $indexes82{$_}, 0..5)
 if scalar(keys %indexes82) == 5; }); 
 ( sub {
 my ($k32) = @_;
 
 my $k66 = sub {
 my ($sym_45str33, $x34) = @_;
 $sym_45str33->($k32, $x34);
 } ;
 my %indexes67;
 ( sub {
 my ($k35) = @_;
 $k35->($sym_45str);
 } )->( sub { $indexes67{0} = $_[0];
 $k66->(map $indexes67{$_}, 0..2)
 if scalar(keys %indexes67) == 2; }); 
 ( sub {
 my ($k36) = @_;
 $k36->($name);
 } )->( sub { $indexes67{1} = $_[0];
 $k66->(map $indexes67{$_}, 0..2)
 if scalar(keys %indexes67) == 2; }); ;
 ;
 } )->( sub { $indexes82{3} = $_[0];
 $k81->(map $indexes82{$_}, 0..5)
 if scalar(keys %indexes82) == 5; }); 
 ( sub {
 my ($k37) = @_;
 
 my $k78 = sub {
 my ($list38, $x39, $x40) = @_;
 $list38->($k37, $x39, $x40);
 } ;
 my %indexes79;
 ( sub {
 my ($k41) = @_;
 $k41->($list);
 } )->( sub { $indexes79{0} = $_[0];
 $k78->(map $indexes79{$_}, 0..3)
 if scalar(keys %indexes79) == 3; }); 
 ( sub {
 my ($k42) = @_;
 
 my $k74 = sub {
 my ($str_45sym43, $x44) = @_;
 $str_45sym43->($k42, $x44);
 } ;
 my %indexes75;
 ( sub {
 my ($k45) = @_;
 $k45->($str_45sym);
 } )->( sub { $indexes75{0} = $_[0];
 $k74->(map $indexes75{$_}, 0..2)
 if scalar(keys %indexes75) == 2; }); 
 ( sub {
 my ($k46) = @_;
 $k46->('cps*');
 } )->( sub { $indexes75{1} = $_[0];
 $k74->(map $indexes75{$_}, 0..2)
 if scalar(keys %indexes75) == 2; }); ;
 ;
 } )->( sub { $indexes79{1} = $_[0];
 $k78->(map $indexes79{$_}, 0..3)
 if scalar(keys %indexes79) == 3; }); 
 ( sub {
 my ($k47) = @_;
 $k47->($f);
 } )->( sub { $indexes79{2} = $_[0];
 $k78->(map $indexes79{$_}, 0..3)
 if scalar(keys %indexes79) == 3; }); ;
 ;
 } )->( sub { $indexes82{4} = $_[0];
 $k81->(map $indexes82{$_}, 0..5)
 if scalar(keys %indexes82) == 5; }); ;
 ;
 } ));


=begin comment

(
  defmacrocps*
  id*
  "def"
  (
    (fn* [x] x)
    (
      fn*
      [k84 name x]
      (
        co*
        (fn* [list85 x86 x87 x88 x89] (list85 k84 x86 x87 x88 x89))
        (fn* [k90] (k90 list))
        (
          fn*
          [k91]
          (
            co*
            (fn* [str-sym92 x93] (str-sym92 k91 x93))
            (fn* [k94] (k94 str-sym))
            (fn* [k95] (k95 'defcps*'))))
        (
          fn*
          [k96]
          (
            co*
            (fn* [str-sym97 x98] (str-sym97 k96 x98))
            (fn* [k99] (k99 str-sym))
            (fn* [k100] (k100 'id*'))))
        (
          fn*
          [k101]
          (
            co*
            (fn* [sym-str102 x103] (sym-str102 k101 x103))
            (fn* [k104] (k104 sym-str))
            (fn* [k105] (k105 name))))
        (
          fn*
          [k106]
          (
            co*
            (fn* [list107 x108 x109] (list107 k106 x108 x109))
            (fn* [k110] (k110 list))
            (
              fn*
              [k111]
              (
                co*
                (fn* [str-sym112 x113] (str-sym112 k111 x113))
                (fn* [k114] (k114 str-sym))
                (fn* [k115] (k115 'cps*'))))
            (fn* [k116] (k116 x))))))))

=end comment

=cut

$defmacrocps_42->($id_42, "def", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k84, $name, $x) = @_;
 
 my $k150 = sub {
 my ($list85, $x86, $x87, $x88, $x89) = @_;
 $list85->($k84, $x86, $x87, $x88, $x89);
 } ;
 my %indexes151;
 ( sub {
 my ($k90) = @_;
 $k90->($list);
 } )->( sub { $indexes151{0} = $_[0];
 $k150->(map $indexes151{$_}, 0..5)
 if scalar(keys %indexes151) == 5; }); 
 ( sub {
 my ($k91) = @_;
 
 my $k123 = sub {
 my ($str_45sym92, $x93) = @_;
 $str_45sym92->($k91, $x93);
 } ;
 my %indexes124;
 ( sub {
 my ($k94) = @_;
 $k94->($str_45sym);
 } )->( sub { $indexes124{0} = $_[0];
 $k123->(map $indexes124{$_}, 0..2)
 if scalar(keys %indexes124) == 2; }); 
 ( sub {
 my ($k95) = @_;
 $k95->('defcps*');
 } )->( sub { $indexes124{1} = $_[0];
 $k123->(map $indexes124{$_}, 0..2)
 if scalar(keys %indexes124) == 2; }); ;
 ;
 } )->( sub { $indexes151{1} = $_[0];
 $k150->(map $indexes151{$_}, 0..5)
 if scalar(keys %indexes151) == 5; }); 
 ( sub {
 my ($k96) = @_;
 
 my $k129 = sub {
 my ($str_45sym97, $x98) = @_;
 $str_45sym97->($k96, $x98);
 } ;
 my %indexes130;
 ( sub {
 my ($k99) = @_;
 $k99->($str_45sym);
 } )->( sub { $indexes130{0} = $_[0];
 $k129->(map $indexes130{$_}, 0..2)
 if scalar(keys %indexes130) == 2; }); 
 ( sub {
 my ($k100) = @_;
 $k100->('id*');
 } )->( sub { $indexes130{1} = $_[0];
 $k129->(map $indexes130{$_}, 0..2)
 if scalar(keys %indexes130) == 2; }); ;
 ;
 } )->( sub { $indexes151{2} = $_[0];
 $k150->(map $indexes151{$_}, 0..5)
 if scalar(keys %indexes151) == 5; }); 
 ( sub {
 my ($k101) = @_;
 
 my $k135 = sub {
 my ($sym_45str102, $x103) = @_;
 $sym_45str102->($k101, $x103);
 } ;
 my %indexes136;
 ( sub {
 my ($k104) = @_;
 $k104->($sym_45str);
 } )->( sub { $indexes136{0} = $_[0];
 $k135->(map $indexes136{$_}, 0..2)
 if scalar(keys %indexes136) == 2; }); 
 ( sub {
 my ($k105) = @_;
 $k105->($name);
 } )->( sub { $indexes136{1} = $_[0];
 $k135->(map $indexes136{$_}, 0..2)
 if scalar(keys %indexes136) == 2; }); ;
 ;
 } )->( sub { $indexes151{3} = $_[0];
 $k150->(map $indexes151{$_}, 0..5)
 if scalar(keys %indexes151) == 5; }); 
 ( sub {
 my ($k106) = @_;
 
 my $k147 = sub {
 my ($list107, $x108, $x109) = @_;
 $list107->($k106, $x108, $x109);
 } ;
 my %indexes148;
 ( sub {
 my ($k110) = @_;
 $k110->($list);
 } )->( sub { $indexes148{0} = $_[0];
 $k147->(map $indexes148{$_}, 0..3)
 if scalar(keys %indexes148) == 3; }); 
 ( sub {
 my ($k111) = @_;
 
 my $k143 = sub {
 my ($str_45sym112, $x113) = @_;
 $str_45sym112->($k111, $x113);
 } ;
 my %indexes144;
 ( sub {
 my ($k114) = @_;
 $k114->($str_45sym);
 } )->( sub { $indexes144{0} = $_[0];
 $k143->(map $indexes144{$_}, 0..2)
 if scalar(keys %indexes144) == 2; }); 
 ( sub {
 my ($k115) = @_;
 $k115->('cps*');
 } )->( sub { $indexes144{1} = $_[0];
 $k143->(map $indexes144{$_}, 0..2)
 if scalar(keys %indexes144) == 2; }); ;
 ;
 } )->( sub { $indexes148{1} = $_[0];
 $k147->(map $indexes148{$_}, 0..3)
 if scalar(keys %indexes148) == 3; }); 
 ( sub {
 my ($k116) = @_;
 $k116->($x);
 } )->( sub { $indexes148{2} = $_[0];
 $k147->(map $indexes148{$_}, 0..3)
 if scalar(keys %indexes148) == 3; }); ;
 ;
 } )->( sub { $indexes151{4} = $_[0];
 $k150->(map $indexes151{$_}, 0..5)
 if scalar(keys %indexes151) == 5; }); ;
 ;
 } ));


=begin comment

(
  defmacrocps*
  id*
  "let*"
  (
    (fn* [x] x)
    (
      fn*
      [k153 n v body]
      (
        co*
        (fn* [list154 x155 x156] (list154 k153 x155 x156))
        (fn* [k157] (k157 list))
        (
          fn*
          [k158]
          (
            co*
            (fn* [list159 x160 x161 x162] (list159 k158 x160 x161 x162))
            (fn* [k163] (k163 list))
            (
              fn*
              [k164]
              (
                co*
                (fn* [str-sym165 x166] (str-sym165 k164 x166))
                (fn* [k167] (k167 str-sym))
                (fn* [k168] (k168 'fn*'))))
            (
              fn*
              [k169]
              (
                co*
                (fn* [to-array170 x171] (to-array170 k169 x171))
                (fn* [k172] (k172 to-array))
                (
                  fn*
                  [k173]
                  (
                    co*
                    (fn* [list174 x175] (list174 k173 x175))
                    (fn* [k176] (k176 list))
                    (fn* [k177] (k177 n))))))
            (fn* [k178] (k178 body))))
        (fn* [k179] (k179 v))))))

=end comment

=cut

$defmacrocps_42->($id_42, "let*", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k153, $n, $v, $body) = @_;
 
 my $k207 = sub {
 my ($list154, $x155, $x156) = @_;
 $list154->($k153, $x155, $x156);
 } ;
 my %indexes208;
 ( sub {
 my ($k157) = @_;
 $k157->($list);
 } )->( sub { $indexes208{0} = $_[0];
 $k207->(map $indexes208{$_}, 0..3)
 if scalar(keys %indexes208) == 3; }); 
 ( sub {
 my ($k158) = @_;
 
 my $k203 = sub {
 my ($list159, $x160, $x161, $x162) = @_;
 $list159->($k158, $x160, $x161, $x162);
 } ;
 my %indexes204;
 ( sub {
 my ($k163) = @_;
 $k163->($list);
 } )->( sub { $indexes204{0} = $_[0];
 $k203->(map $indexes204{$_}, 0..4)
 if scalar(keys %indexes204) == 4; }); 
 ( sub {
 my ($k164) = @_;
 
 my $k188 = sub {
 my ($str_45sym165, $x166) = @_;
 $str_45sym165->($k164, $x166);
 } ;
 my %indexes189;
 ( sub {
 my ($k167) = @_;
 $k167->($str_45sym);
 } )->( sub { $indexes189{0} = $_[0];
 $k188->(map $indexes189{$_}, 0..2)
 if scalar(keys %indexes189) == 2; }); 
 ( sub {
 my ($k168) = @_;
 $k168->('fn*');
 } )->( sub { $indexes189{1} = $_[0];
 $k188->(map $indexes189{$_}, 0..2)
 if scalar(keys %indexes189) == 2; }); ;
 ;
 } )->( sub { $indexes204{1} = $_[0];
 $k203->(map $indexes204{$_}, 0..4)
 if scalar(keys %indexes204) == 4; }); 
 ( sub {
 my ($k169) = @_;
 
 my $k199 = sub {
 my ($to_45array170, $x171) = @_;
 $to_45array170->($k169, $x171);
 } ;
 my %indexes200;
 ( sub {
 my ($k172) = @_;
 $k172->($to_45array);
 } )->( sub { $indexes200{0} = $_[0];
 $k199->(map $indexes200{$_}, 0..2)
 if scalar(keys %indexes200) == 2; }); 
 ( sub {
 my ($k173) = @_;
 
 my $k196 = sub {
 my ($list174, $x175) = @_;
 $list174->($k173, $x175);
 } ;
 my %indexes197;
 ( sub {
 my ($k176) = @_;
 $k176->($list);
 } )->( sub { $indexes197{0} = $_[0];
 $k196->(map $indexes197{$_}, 0..2)
 if scalar(keys %indexes197) == 2; }); 
 ( sub {
 my ($k177) = @_;
 $k177->($n);
 } )->( sub { $indexes197{1} = $_[0];
 $k196->(map $indexes197{$_}, 0..2)
 if scalar(keys %indexes197) == 2; }); ;
 ;
 } )->( sub { $indexes200{1} = $_[0];
 $k199->(map $indexes200{$_}, 0..2)
 if scalar(keys %indexes200) == 2; }); ;
 ;
 } )->( sub { $indexes204{2} = $_[0];
 $k203->(map $indexes204{$_}, 0..4)
 if scalar(keys %indexes204) == 4; }); 
 ( sub {
 my ($k178) = @_;
 $k178->($body);
 } )->( sub { $indexes204{3} = $_[0];
 $k203->(map $indexes204{$_}, 0..4)
 if scalar(keys %indexes204) == 4; }); ;
 ;
 } )->( sub { $indexes208{1} = $_[0];
 $k207->(map $indexes208{$_}, 0..3)
 if scalar(keys %indexes208) == 3; }); 
 ( sub {
 my ($k179) = @_;
 $k179->($v);
 } )->( sub { $indexes208{2} = $_[0];
 $k207->(map $indexes208{$_}, 0..3)
 if scalar(keys %indexes208) == 3; }); ;
 ;
 } ));


=begin comment

(
  defmacrocps*
  id*
  "if"
  (
    (fn* [x] x)
    (
      fn*
      [k210 cond then else]
      (
        co*
        (fn* [list211 x212] (list211 k210 x212))
        (fn* [k213] (k213 list))
        (
          fn*
          [k214]
          (
            co*
            (
              fn*
              [list215 x216 x217 x218 x219]
              (list215 k214 x216 x217 x218 x219))
            (fn* [k220] (k220 list))
            (
              fn*
              [k221]
              (
                co*
                (fn* [str-sym222 x223] (str-sym222 k221 x223))
                (fn* [k224] (k224 str-sym))
                (fn* [k225] (k225 'nth*'))))
            (
              fn*
              [k226]
              (
                co*
                (fn* [list227 x228 x229] (list227 k226 x228 x229))
                (fn* [k230] (k230 list))
                (
                  fn*
                  [k231]
                  (
                    co*
                    (fn* [str-sym232 x233] (str-sym232 k231 x233))
                    (fn* [k234] (k234 str-sym))
                    (fn* [k235] (k235 'not'))))
                (fn* [k236] (k236 cond))))
            (
              fn*
              [k237]
              (
                co*
                (fn* [list238 x239 x240 x241] (list238 k237 x239 x240 x241))
                (fn* [k242] (k242 list))
                (
                  fn*
                  [k243]
                  (
                    co*
                    (fn* [str-sym244 x245] (str-sym244 k243 x245))
                    (fn* [k246] (k246 str-sym))
                    (fn* [k247] (k247 'fn*'))))
                (
                  fn*
                  [k248]
                  (
                    co*
                    (fn* [to-array249 x250] (to-array249 k248 x250))
                    (fn* [k251] (k251 to-array))
                    (
                      fn*
                      [k252]
                      (co* (fn* [nil253] (nil253 k252)) (fn* [k254] (k254 nil))))))
                (fn* [k255] (k255 then))))
            (
              fn*
              [k256]
              (
                co*
                (fn* [list257 x258 x259 x260] (list257 k256 x258 x259 x260))
                (fn* [k261] (k261 list))
                (
                  fn*
                  [k262]
                  (
                    co*
                    (fn* [str-sym263 x264] (str-sym263 k262 x264))
                    (fn* [k265] (k265 str-sym))
                    (fn* [k266] (k266 'fn*'))))
                (
                  fn*
                  [k267]
                  (
                    co*
                    (fn* [to-array268 x269] (to-array268 k267 x269))
                    (fn* [k270] (k270 to-array))
                    (
                      fn*
                      [k271]
                      (co* (fn* [nil272] (nil272 k271)) (fn* [k273] (k273 nil))))))
                (fn* [k274] (k274 else))))))))))

=end comment

=cut

$defmacrocps_42->($id_42, "if", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k210, $cond, $then, $else) = @_;
 
 my $k345 = sub {
 my ($list211, $x212) = @_;
 $list211->($k210, $x212);
 } ;
 my %indexes346;
 ( sub {
 my ($k213) = @_;
 $k213->($list);
 } )->( sub { $indexes346{0} = $_[0];
 $k345->(map $indexes346{$_}, 0..2)
 if scalar(keys %indexes346) == 2; }); 
 ( sub {
 my ($k214) = @_;
 
 my $k342 = sub {
 my ($list215, $x216, $x217, $x218, $x219) = @_;
 $list215->($k214, $x216, $x217, $x218, $x219);
 } ;
 my %indexes343;
 ( sub {
 my ($k220) = @_;
 $k220->($list);
 } )->( sub { $indexes343{0} = $_[0];
 $k342->(map $indexes343{$_}, 0..5)
 if scalar(keys %indexes343) == 5; }); 
 ( sub {
 my ($k221) = @_;
 
 my $k283 = sub {
 my ($str_45sym222, $x223) = @_;
 $str_45sym222->($k221, $x223);
 } ;
 my %indexes284;
 ( sub {
 my ($k224) = @_;
 $k224->($str_45sym);
 } )->( sub { $indexes284{0} = $_[0];
 $k283->(map $indexes284{$_}, 0..2)
 if scalar(keys %indexes284) == 2; }); 
 ( sub {
 my ($k225) = @_;
 $k225->('nth*');
 } )->( sub { $indexes284{1} = $_[0];
 $k283->(map $indexes284{$_}, 0..2)
 if scalar(keys %indexes284) == 2; }); ;
 ;
 } )->( sub { $indexes343{1} = $_[0];
 $k342->(map $indexes343{$_}, 0..5)
 if scalar(keys %indexes343) == 5; }); 
 ( sub {
 my ($k226) = @_;
 
 my $k295 = sub {
 my ($list227, $x228, $x229) = @_;
 $list227->($k226, $x228, $x229);
 } ;
 my %indexes296;
 ( sub {
 my ($k230) = @_;
 $k230->($list);
 } )->( sub { $indexes296{0} = $_[0];
 $k295->(map $indexes296{$_}, 0..3)
 if scalar(keys %indexes296) == 3; }); 
 ( sub {
 my ($k231) = @_;
 
 my $k291 = sub {
 my ($str_45sym232, $x233) = @_;
 $str_45sym232->($k231, $x233);
 } ;
 my %indexes292;
 ( sub {
 my ($k234) = @_;
 $k234->($str_45sym);
 } )->( sub { $indexes292{0} = $_[0];
 $k291->(map $indexes292{$_}, 0..2)
 if scalar(keys %indexes292) == 2; }); 
 ( sub {
 my ($k235) = @_;
 $k235->('not');
 } )->( sub { $indexes292{1} = $_[0];
 $k291->(map $indexes292{$_}, 0..2)
 if scalar(keys %indexes292) == 2; }); ;
 ;
 } )->( sub { $indexes296{1} = $_[0];
 $k295->(map $indexes296{$_}, 0..3)
 if scalar(keys %indexes296) == 3; }); 
 ( sub {
 my ($k236) = @_;
 $k236->($cond);
 } )->( sub { $indexes296{2} = $_[0];
 $k295->(map $indexes296{$_}, 0..3)
 if scalar(keys %indexes296) == 3; }); ;
 ;
 } )->( sub { $indexes343{2} = $_[0];
 $k342->(map $indexes343{$_}, 0..5)
 if scalar(keys %indexes343) == 5; }); 
 ( sub {
 my ($k237) = @_;
 
 my $k317 = sub {
 my ($list238, $x239, $x240, $x241) = @_;
 $list238->($k237, $x239, $x240, $x241);
 } ;
 my %indexes318;
 ( sub {
 my ($k242) = @_;
 $k242->($list);
 } )->( sub { $indexes318{0} = $_[0];
 $k317->(map $indexes318{$_}, 0..4)
 if scalar(keys %indexes318) == 4; }); 
 ( sub {
 my ($k243) = @_;
 
 my $k303 = sub {
 my ($str_45sym244, $x245) = @_;
 $str_45sym244->($k243, $x245);
 } ;
 my %indexes304;
 ( sub {
 my ($k246) = @_;
 $k246->($str_45sym);
 } )->( sub { $indexes304{0} = $_[0];
 $k303->(map $indexes304{$_}, 0..2)
 if scalar(keys %indexes304) == 2; }); 
 ( sub {
 my ($k247) = @_;
 $k247->('fn*');
 } )->( sub { $indexes304{1} = $_[0];
 $k303->(map $indexes304{$_}, 0..2)
 if scalar(keys %indexes304) == 2; }); ;
 ;
 } )->( sub { $indexes318{1} = $_[0];
 $k317->(map $indexes318{$_}, 0..4)
 if scalar(keys %indexes318) == 4; }); 
 ( sub {
 my ($k248) = @_;
 
 my $k313 = sub {
 my ($to_45array249, $x250) = @_;
 $to_45array249->($k248, $x250);
 } ;
 my %indexes314;
 ( sub {
 my ($k251) = @_;
 $k251->($to_45array);
 } )->( sub { $indexes314{0} = $_[0];
 $k313->(map $indexes314{$_}, 0..2)
 if scalar(keys %indexes314) == 2; }); 
 ( sub {
 my ($k252) = @_;
 
 my $k310 = sub {
 my ($nil253) = @_;
 $nil253->($k252);
 } ;
 my %indexes311;
 ( sub {
 my ($k254) = @_;
 $k254->($nil);
 } )->( sub { $indexes311{0} = $_[0];
 $k310->(map $indexes311{$_}, 0..1)
 if scalar(keys %indexes311) == 1; }); ;
 ;
 } )->( sub { $indexes314{1} = $_[0];
 $k313->(map $indexes314{$_}, 0..2)
 if scalar(keys %indexes314) == 2; }); ;
 ;
 } )->( sub { $indexes318{2} = $_[0];
 $k317->(map $indexes318{$_}, 0..4)
 if scalar(keys %indexes318) == 4; }); 
 ( sub {
 my ($k255) = @_;
 $k255->($then);
 } )->( sub { $indexes318{3} = $_[0];
 $k317->(map $indexes318{$_}, 0..4)
 if scalar(keys %indexes318) == 4; }); ;
 ;
 } )->( sub { $indexes343{3} = $_[0];
 $k342->(map $indexes343{$_}, 0..5)
 if scalar(keys %indexes343) == 5; }); 
 ( sub {
 my ($k256) = @_;
 
 my $k339 = sub {
 my ($list257, $x258, $x259, $x260) = @_;
 $list257->($k256, $x258, $x259, $x260);
 } ;
 my %indexes340;
 ( sub {
 my ($k261) = @_;
 $k261->($list);
 } )->( sub { $indexes340{0} = $_[0];
 $k339->(map $indexes340{$_}, 0..4)
 if scalar(keys %indexes340) == 4; }); 
 ( sub {
 my ($k262) = @_;
 
 my $k325 = sub {
 my ($str_45sym263, $x264) = @_;
 $str_45sym263->($k262, $x264);
 } ;
 my %indexes326;
 ( sub {
 my ($k265) = @_;
 $k265->($str_45sym);
 } )->( sub { $indexes326{0} = $_[0];
 $k325->(map $indexes326{$_}, 0..2)
 if scalar(keys %indexes326) == 2; }); 
 ( sub {
 my ($k266) = @_;
 $k266->('fn*');
 } )->( sub { $indexes326{1} = $_[0];
 $k325->(map $indexes326{$_}, 0..2)
 if scalar(keys %indexes326) == 2; }); ;
 ;
 } )->( sub { $indexes340{1} = $_[0];
 $k339->(map $indexes340{$_}, 0..4)
 if scalar(keys %indexes340) == 4; }); 
 ( sub {
 my ($k267) = @_;
 
 my $k335 = sub {
 my ($to_45array268, $x269) = @_;
 $to_45array268->($k267, $x269);
 } ;
 my %indexes336;
 ( sub {
 my ($k270) = @_;
 $k270->($to_45array);
 } )->( sub { $indexes336{0} = $_[0];
 $k335->(map $indexes336{$_}, 0..2)
 if scalar(keys %indexes336) == 2; }); 
 ( sub {
 my ($k271) = @_;
 
 my $k332 = sub {
 my ($nil272) = @_;
 $nil272->($k271);
 } ;
 my %indexes333;
 ( sub {
 my ($k273) = @_;
 $k273->($nil);
 } )->( sub { $indexes333{0} = $_[0];
 $k332->(map $indexes333{$_}, 0..1)
 if scalar(keys %indexes333) == 1; }); ;
 ;
 } )->( sub { $indexes336{1} = $_[0];
 $k335->(map $indexes336{$_}, 0..2)
 if scalar(keys %indexes336) == 2; }); ;
 ;
 } )->( sub { $indexes340{2} = $_[0];
 $k339->(map $indexes340{$_}, 0..4)
 if scalar(keys %indexes340) == 4; }); 
 ( sub {
 my ($k274) = @_;
 $k274->($else);
 } )->( sub { $indexes340{3} = $_[0];
 $k339->(map $indexes340{$_}, 0..4)
 if scalar(keys %indexes340) == 4; }); ;
 ;
 } )->( sub { $indexes343{4} = $_[0];
 $k342->(map $indexes343{$_}, 0..5)
 if scalar(keys %indexes343) == 5; }); ;
 ;
 } )->( sub { $indexes346{1} = $_[0];
 $k345->(map $indexes346{$_}, 0..2)
 if scalar(keys %indexes346) == 2; }); ;
 ;
 } ));


=begin comment

(
  defcps*
  id*
  "listgen"
  (
    (fn* [x] x)
    (
      fn*
      [k348 xs]
      (
        co*
        (fn* [f349] (f349 k348))
        (
          fn*
          [k350]
          (
            co*
            (fn* [x351 x352 x353] (nth* k350 x351 x352 x353))
            (
              fn*
              [k354]
              (
                co*
                (fn* [not355 x356] (not355 k354 x356))
                (fn* [k357] (k357 not))
                (
                  fn*
                  [k358]
                  (
                    co*
                    (fn* [count359 x360] (count359 k358 x360))
                    (fn* [k361] (k361 count))
                    (fn* [k362] (k362 xs))))))
            (
              fn*
              [k363]
              (
                k363
                (
                  fn*
                  [k364]
                  (
                    k364
                    (
                      fn*
                      [k365 k]
                      (
                        co*
                        (fn* [k366 x367 x368] (k366 k365 x367 x368))
                        (fn* [k369] (k369 k))
                        (
                          fn*
                          [k370]
                          (
                            co*
                            (fn* [car371 x372] (car371 k370 x372))
                            (fn* [k373] (k373 car))
                            (fn* [k374] (k374 xs))))
                        (
                          fn*
                          [k375]
                          (
                            co*
                            (fn* [listgen376 x377] (listgen376 k375 x377))
                            (fn* [k378] (k378 listgen))
                            (
                              fn*
                              [k379]
                              (
                                co*
                                (fn* [cdr380 x381] (cdr380 k379 x381))
                                (fn* [k382] (k382 cdr))
                                (fn* [k383] (k383 xs))))))))))))
            (
              fn*
              [k384]
              (
                k384
                (
                  fn*
                  [k385]
                  (
                    k385
                    (
                      fn*
                      [k386 k]
                      (co* (fn* [k387] (k387 k386)) (fn* [k388] (k388 k))))))))))))))

=end comment

=cut

$defcps_42->($id_42, "listgen", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k348, $xs) = @_;
 
 my $k437 = sub {
 my ($f349) = @_;
 $f349->($k348);
 } ;
 my %indexes438;
 ( sub {
 my ($k350) = @_;
 
 my $k434 = sub {
 my ($x351, $x352, $x353) = @_;
 ($k350)->(($x352, $x353)[$x351]) ;
 } ;
 my %indexes435;
 ( sub {
 my ($k354) = @_;
 
 my $k400 = sub {
 my ($not355, $x356) = @_;
 $not355->($k354, $x356);
 } ;
 my %indexes401;
 ( sub {
 my ($k357) = @_;
 $k357->($not);
 } )->( sub { $indexes401{0} = $_[0];
 $k400->(map $indexes401{$_}, 0..2)
 if scalar(keys %indexes401) == 2; }); 
 ( sub {
 my ($k358) = @_;
 
 my $k397 = sub {
 my ($count359, $x360) = @_;
 $count359->($k358, $x360);
 } ;
 my %indexes398;
 ( sub {
 my ($k361) = @_;
 $k361->($count);
 } )->( sub { $indexes398{0} = $_[0];
 $k397->(map $indexes398{$_}, 0..2)
 if scalar(keys %indexes398) == 2; }); 
 ( sub {
 my ($k362) = @_;
 $k362->($xs);
 } )->( sub { $indexes398{1} = $_[0];
 $k397->(map $indexes398{$_}, 0..2)
 if scalar(keys %indexes398) == 2; }); ;
 ;
 } )->( sub { $indexes401{1} = $_[0];
 $k400->(map $indexes401{$_}, 0..2)
 if scalar(keys %indexes401) == 2; }); ;
 ;
 } )->( sub { $indexes435{0} = $_[0];
 $k434->(map $indexes435{$_}, 0..3)
 if scalar(keys %indexes435) == 3; }); 
 ( sub {
 my ($k363) = @_;
 $k363->( sub {
 my ($k364) = @_;
 $k364->( sub {
 my ($k365, $k) = @_;
 
 my $k422 = sub {
 my ($k366, $x367, $x368) = @_;
 $k366->($k365, $x367, $x368);
 } ;
 my %indexes423;
 ( sub {
 my ($k369) = @_;
 $k369->($k);
 } )->( sub { $indexes423{0} = $_[0];
 $k422->(map $indexes423{$_}, 0..3)
 if scalar(keys %indexes423) == 3; }); 
 ( sub {
 my ($k370) = @_;
 
 my $k408 = sub {
 my ($car371, $x372) = @_;
 $car371->($k370, $x372);
 } ;
 my %indexes409;
 ( sub {
 my ($k373) = @_;
 $k373->($car);
 } )->( sub { $indexes409{0} = $_[0];
 $k408->(map $indexes409{$_}, 0..2)
 if scalar(keys %indexes409) == 2; }); 
 ( sub {
 my ($k374) = @_;
 $k374->($xs);
 } )->( sub { $indexes409{1} = $_[0];
 $k408->(map $indexes409{$_}, 0..2)
 if scalar(keys %indexes409) == 2; }); ;
 ;
 } )->( sub { $indexes423{1} = $_[0];
 $k422->(map $indexes423{$_}, 0..3)
 if scalar(keys %indexes423) == 3; }); 
 ( sub {
 my ($k375) = @_;
 
 my $k419 = sub {
 my ($listgen376, $x377) = @_;
 $listgen376->($k375, $x377);
 } ;
 my %indexes420;
 ( sub {
 my ($k378) = @_;
 $k378->($listgen);
 } )->( sub { $indexes420{0} = $_[0];
 $k419->(map $indexes420{$_}, 0..2)
 if scalar(keys %indexes420) == 2; }); 
 ( sub {
 my ($k379) = @_;
 
 my $k416 = sub {
 my ($cdr380, $x381) = @_;
 $cdr380->($k379, $x381);
 } ;
 my %indexes417;
 ( sub {
 my ($k382) = @_;
 $k382->($cdr);
 } )->( sub { $indexes417{0} = $_[0];
 $k416->(map $indexes417{$_}, 0..2)
 if scalar(keys %indexes417) == 2; }); 
 ( sub {
 my ($k383) = @_;
 $k383->($xs);
 } )->( sub { $indexes417{1} = $_[0];
 $k416->(map $indexes417{$_}, 0..2)
 if scalar(keys %indexes417) == 2; }); ;
 ;
 } )->( sub { $indexes420{1} = $_[0];
 $k419->(map $indexes420{$_}, 0..2)
 if scalar(keys %indexes420) == 2; }); ;
 ;
 } )->( sub { $indexes423{2} = $_[0];
 $k422->(map $indexes423{$_}, 0..3)
 if scalar(keys %indexes423) == 3; }); ;
 ;
 } );
 } );
 } )->( sub { $indexes435{1} = $_[0];
 $k434->(map $indexes435{$_}, 0..3)
 if scalar(keys %indexes435) == 3; }); 
 ( sub {
 my ($k384) = @_;
 $k384->( sub {
 my ($k385) = @_;
 $k385->( sub {
 my ($k386, $k) = @_;
 
 my $k429 = sub {
 my ($k387) = @_;
 $k387->($k386);
 } ;
 my %indexes430;
 ( sub {
 my ($k388) = @_;
 $k388->($k);
 } )->( sub { $indexes430{0} = $_[0];
 $k429->(map $indexes430{$_}, 0..1)
 if scalar(keys %indexes430) == 1; }); ;
 ;
 } );
 } );
 } )->( sub { $indexes435{2} = $_[0];
 $k434->(map $indexes435{$_}, 0..3)
 if scalar(keys %indexes435) == 3; }); ;
 ;
 } )->( sub { $indexes438{0} = $_[0];
 $k437->(map $indexes438{$_}, 0..1)
 if scalar(keys %indexes438) == 1; }); ;
 ;
 } ));


=begin comment

(
  defcps*
  id*
  "lreduce*"
  (
    (fn* [x] x)
    (
      fn*
      [k440 f init generator]
      (
        co*
        (fn* [generator441 x442] (generator441 k440 x442))
        (fn* [k443] (k443 generator))
        (
          fn*
          [k444]
          (
            k444
            (
              fn*
              kf446
              (
                uncons
                (
                  fn*
                  [k445 xs]
                  (
                    co*
                    (fn* [f447] (f447 k445))
                    (
                      fn*
                      [k448]
                      (
                        co*
                        (fn* [x449 x450 x451] (nth* k448 x449 x450 x451))
                        (
                          fn*
                          [k452]
                          (
                            co*
                            (fn* [not453 x454] (not453 k452 x454))
                            (fn* [k455] (k455 not))
                            (
                              fn*
                              [k456]
                              (
                                co*
                                (fn* [count457 x458] (count457 k456 x458))
                                (fn* [k459] (k459 count))
                                (fn* [k460] (k460 xs))))))
                        (
                          fn*
                          [k461]
                          (
                            k461
                            (
                              fn*
                              [k462]
                              (
                                co*
                                (
                                  fn*
                                  [lreduce*463 x464 x465 x466]
                                  (lreduce*463 k462 x464 x465 x466))
                                (fn* [k467] (k467 lreduce*))
                                (fn* [k468] (k468 f))
                                (
                                  fn*
                                  [k469]
                                  (
                                    co*
                                    (fn* [f470 x471 x472] (f470 k469 x471 x472))
                                    (fn* [k473] (k473 f))
                                    (fn* [k474] (k474 init))
                                    (
                                      fn*
                                      [k475]
                                      (
                                        co*
                                        (
                                          fn*
                                          [aget476 x477 x478]
                                          (aget476 k475 x477 x478))
                                        (fn* [k479] (k479 aget))
                                        (fn* [k480] (k480 xs))
                                        (fn* [k481] (k481 0))))))
                                (
                                  fn*
                                  [k482]
                                  (
                                    co*
                                    (
                                      fn*
                                      [aget483 x484 x485]
                                      (aget483 k482 x484 x485))
                                    (fn* [k486] (k486 aget))
                                    (fn* [k487] (k487 xs))
                                    (fn* [k488] (k488 1))))))))
                        (fn* [k489] (k489 (fn* [k490] (k490 init))))))))
                kf446))))))))

=end comment

=cut

$defcps_42->($id_42, "lreduce*", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k440, $f, $init, $generator) = @_;
 
 my $k544 = sub {
 my ($generator441, $x442) = @_;
 $generator441->($k440, $x442);
 } ;
 my %indexes545;
 ( sub {
 my ($k443) = @_;
 $k443->($generator);
 } )->( sub { $indexes545{0} = $_[0];
 $k544->(map $indexes545{$_}, 0..2)
 if scalar(keys %indexes545) == 2; }); 
 ( sub {
 my ($k444) = @_;
 $k444->( sub {
 my $kf446 = \@_;
 $uncons->( sub {
 my ($k445, $xs) = @_;
 
 my $k539 = sub {
 my ($f447) = @_;
 $f447->($k445);
 } ;
 my %indexes540;
 ( sub {
 my ($k448) = @_;
 
 my $k536 = sub {
 my ($x449, $x450, $x451) = @_;
 ($k448)->(($x450, $x451)[$x449]) ;
 } ;
 my %indexes537;
 ( sub {
 my ($k452) = @_;
 
 my $k504 = sub {
 my ($not453, $x454) = @_;
 $not453->($k452, $x454);
 } ;
 my %indexes505;
 ( sub {
 my ($k455) = @_;
 $k455->($not);
 } )->( sub { $indexes505{0} = $_[0];
 $k504->(map $indexes505{$_}, 0..2)
 if scalar(keys %indexes505) == 2; }); 
 ( sub {
 my ($k456) = @_;
 
 my $k501 = sub {
 my ($count457, $x458) = @_;
 $count457->($k456, $x458);
 } ;
 my %indexes502;
 ( sub {
 my ($k459) = @_;
 $k459->($count);
 } )->( sub { $indexes502{0} = $_[0];
 $k501->(map $indexes502{$_}, 0..2)
 if scalar(keys %indexes502) == 2; }); 
 ( sub {
 my ($k460) = @_;
 $k460->($xs);
 } )->( sub { $indexes502{1} = $_[0];
 $k501->(map $indexes502{$_}, 0..2)
 if scalar(keys %indexes502) == 2; }); ;
 ;
 } )->( sub { $indexes505{1} = $_[0];
 $k504->(map $indexes505{$_}, 0..2)
 if scalar(keys %indexes505) == 2; }); ;
 ;
 } )->( sub { $indexes537{0} = $_[0];
 $k536->(map $indexes537{$_}, 0..3)
 if scalar(keys %indexes537) == 3; }); 
 ( sub {
 my ($k461) = @_;
 $k461->( sub {
 my ($k462) = @_;
 
 my $k530 = sub {
 my ($lreduce_42463, $x464, $x465, $x466) = @_;
 $lreduce_42463->($k462, $x464, $x465, $x466);
 } ;
 my %indexes531;
 ( sub {
 my ($k467) = @_;
 $k467->($lreduce_42);
 } )->( sub { $indexes531{0} = $_[0];
 $k530->(map $indexes531{$_}, 0..4)
 if scalar(keys %indexes531) == 4; }); 
 ( sub {
 my ($k468) = @_;
 $k468->($f);
 } )->( sub { $indexes531{1} = $_[0];
 $k530->(map $indexes531{$_}, 0..4)
 if scalar(keys %indexes531) == 4; }); 
 ( sub {
 my ($k469) = @_;
 
 my $k520 = sub {
 my ($f470, $x471, $x472) = @_;
 $f470->($k469, $x471, $x472);
 } ;
 my %indexes521;
 ( sub {
 my ($k473) = @_;
 $k473->($f);
 } )->( sub { $indexes521{0} = $_[0];
 $k520->(map $indexes521{$_}, 0..3)
 if scalar(keys %indexes521) == 3; }); 
 ( sub {
 my ($k474) = @_;
 $k474->($init);
 } )->( sub { $indexes521{1} = $_[0];
 $k520->(map $indexes521{$_}, 0..3)
 if scalar(keys %indexes521) == 3; }); 
 ( sub {
 my ($k475) = @_;
 
 my $k517 = sub {
 my ($aget476, $x477, $x478) = @_;
 $aget476->($k475, $x477, $x478);
 } ;
 my %indexes518;
 ( sub {
 my ($k479) = @_;
 $k479->($aget);
 } )->( sub { $indexes518{0} = $_[0];
 $k517->(map $indexes518{$_}, 0..3)
 if scalar(keys %indexes518) == 3; }); 
 ( sub {
 my ($k480) = @_;
 $k480->($xs);
 } )->( sub { $indexes518{1} = $_[0];
 $k517->(map $indexes518{$_}, 0..3)
 if scalar(keys %indexes518) == 3; }); 
 ( sub {
 my ($k481) = @_;
 $k481->(0);
 } )->( sub { $indexes518{2} = $_[0];
 $k517->(map $indexes518{$_}, 0..3)
 if scalar(keys %indexes518) == 3; }); ;
 ;
 } )->( sub { $indexes521{2} = $_[0];
 $k520->(map $indexes521{$_}, 0..3)
 if scalar(keys %indexes521) == 3; }); ;
 ;
 } )->( sub { $indexes531{2} = $_[0];
 $k530->(map $indexes531{$_}, 0..4)
 if scalar(keys %indexes531) == 4; }); 
 ( sub {
 my ($k482) = @_;
 
 my $k527 = sub {
 my ($aget483, $x484, $x485) = @_;
 $aget483->($k482, $x484, $x485);
 } ;
 my %indexes528;
 ( sub {
 my ($k486) = @_;
 $k486->($aget);
 } )->( sub { $indexes528{0} = $_[0];
 $k527->(map $indexes528{$_}, 0..3)
 if scalar(keys %indexes528) == 3; }); 
 ( sub {
 my ($k487) = @_;
 $k487->($xs);
 } )->( sub { $indexes528{1} = $_[0];
 $k527->(map $indexes528{$_}, 0..3)
 if scalar(keys %indexes528) == 3; }); 
 ( sub {
 my ($k488) = @_;
 $k488->(1);
 } )->( sub { $indexes528{2} = $_[0];
 $k527->(map $indexes528{$_}, 0..3)
 if scalar(keys %indexes528) == 3; }); ;
 ;
 } )->( sub { $indexes531{3} = $_[0];
 $k530->(map $indexes531{$_}, 0..4)
 if scalar(keys %indexes531) == 4; }); ;
 ;
 } );
 } )->( sub { $indexes537{1} = $_[0];
 $k536->(map $indexes537{$_}, 0..3)
 if scalar(keys %indexes537) == 3; }); 
 ( sub {
 my ($k489) = @_;
 $k489->( sub {
 my ($k490) = @_;
 $k490->($init);
 } );
 } )->( sub { $indexes537{2} = $_[0];
 $k536->(map $indexes537{$_}, 0..3)
 if scalar(keys %indexes537) == 3; }); ;
 ;
 } )->( sub { $indexes540{0} = $_[0];
 $k539->(map $indexes540{$_}, 0..1)
 if scalar(keys %indexes540) == 1; }); ;
 ;
 } , $kf446);
 } );
 } )->( sub { $indexes545{1} = $_[0];
 $k544->(map $indexes545{$_}, 0..2)
 if scalar(keys %indexes545) == 2; }); ;
 ;
 } ));


=begin comment

(
  defcps*
  id*
  "rreduce*"
  (
    (fn* [x] x)
    (
      fn*
      [k547 f end generator]
      (
        co*
        (fn* [generator548 x549] (generator548 k547 x549))
        (fn* [k550] (k550 generator))
        (
          fn*
          [k551]
          (
            k551
            (
              fn*
              kf553
              (
                uncons
                (
                  fn*
                  [k552 xs]
                  (
                    co*
                    (fn* [f554] (f554 k552))
                    (
                      fn*
                      [k555]
                      (
                        co*
                        (fn* [x556 x557 x558] (nth* k555 x556 x557 x558))
                        (
                          fn*
                          [k559]
                          (
                            co*
                            (fn* [not560 x561] (not560 k559 x561))
                            (fn* [k562] (k562 not))
                            (
                              fn*
                              [k563]
                              (
                                co*
                                (fn* [count564 x565] (count564 k563 x565))
                                (fn* [k566] (k566 count))
                                (fn* [k567] (k567 xs))))))
                        (
                          fn*
                          [k568]
                          (
                            k568
                            (
                              fn*
                              [k569]
                              (
                                co*
                                (fn* [f570 x571 x572] (f570 k569 x571 x572))
                                (fn* [k573] (k573 f))
                                (
                                  fn*
                                  [k574]
                                  (
                                    co*
                                    (
                                      fn*
                                      [aget575 x576 x577]
                                      (aget575 k574 x576 x577))
                                    (fn* [k578] (k578 aget))
                                    (fn* [k579] (k579 xs))
                                    (fn* [k580] (k580 0))))
                                (
                                  fn*
                                  [k581]
                                  (
                                    co*
                                    (
                                      fn*
                                      [rreduce*582 x583 x584 x585]
                                      (rreduce*582 k581 x583 x584 x585))
                                    (fn* [k586] (k586 rreduce*))
                                    (fn* [k587] (k587 f))
                                    (fn* [k588] (k588 end))
                                    (
                                      fn*
                                      [k589]
                                      (
                                        co*
                                        (
                                          fn*
                                          [aget590 x591 x592]
                                          (aget590 k589 x591 x592))
                                        (fn* [k593] (k593 aget))
                                        (fn* [k594] (k594 xs))
                                        (fn* [k595] (k595 1))))))))))
                        (fn* [k596] (k596 (fn* [k597] (k597 end))))))))
                kf553))))))))

=end comment

=cut

$defcps_42->($id_42, "rreduce*", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k547, $f, $end, $generator) = @_;
 
 my $k651 = sub {
 my ($generator548, $x549) = @_;
 $generator548->($k547, $x549);
 } ;
 my %indexes652;
 ( sub {
 my ($k550) = @_;
 $k550->($generator);
 } )->( sub { $indexes652{0} = $_[0];
 $k651->(map $indexes652{$_}, 0..2)
 if scalar(keys %indexes652) == 2; }); 
 ( sub {
 my ($k551) = @_;
 $k551->( sub {
 my $kf553 = \@_;
 $uncons->( sub {
 my ($k552, $xs) = @_;
 
 my $k646 = sub {
 my ($f554) = @_;
 $f554->($k552);
 } ;
 my %indexes647;
 ( sub {
 my ($k555) = @_;
 
 my $k643 = sub {
 my ($x556, $x557, $x558) = @_;
 ($k555)->(($x557, $x558)[$x556]) ;
 } ;
 my %indexes644;
 ( sub {
 my ($k559) = @_;
 
 my $k611 = sub {
 my ($not560, $x561) = @_;
 $not560->($k559, $x561);
 } ;
 my %indexes612;
 ( sub {
 my ($k562) = @_;
 $k562->($not);
 } )->( sub { $indexes612{0} = $_[0];
 $k611->(map $indexes612{$_}, 0..2)
 if scalar(keys %indexes612) == 2; }); 
 ( sub {
 my ($k563) = @_;
 
 my $k608 = sub {
 my ($count564, $x565) = @_;
 $count564->($k563, $x565);
 } ;
 my %indexes609;
 ( sub {
 my ($k566) = @_;
 $k566->($count);
 } )->( sub { $indexes609{0} = $_[0];
 $k608->(map $indexes609{$_}, 0..2)
 if scalar(keys %indexes609) == 2; }); 
 ( sub {
 my ($k567) = @_;
 $k567->($xs);
 } )->( sub { $indexes609{1} = $_[0];
 $k608->(map $indexes609{$_}, 0..2)
 if scalar(keys %indexes609) == 2; }); ;
 ;
 } )->( sub { $indexes612{1} = $_[0];
 $k611->(map $indexes612{$_}, 0..2)
 if scalar(keys %indexes612) == 2; }); ;
 ;
 } )->( sub { $indexes644{0} = $_[0];
 $k643->(map $indexes644{$_}, 0..3)
 if scalar(keys %indexes644) == 3; }); 
 ( sub {
 my ($k568) = @_;
 $k568->( sub {
 my ($k569) = @_;
 
 my $k637 = sub {
 my ($f570, $x571, $x572) = @_;
 $f570->($k569, $x571, $x572);
 } ;
 my %indexes638;
 ( sub {
 my ($k573) = @_;
 $k573->($f);
 } )->( sub { $indexes638{0} = $_[0];
 $k637->(map $indexes638{$_}, 0..3)
 if scalar(keys %indexes638) == 3; }); 
 ( sub {
 my ($k574) = @_;
 
 my $k620 = sub {
 my ($aget575, $x576, $x577) = @_;
 $aget575->($k574, $x576, $x577);
 } ;
 my %indexes621;
 ( sub {
 my ($k578) = @_;
 $k578->($aget);
 } )->( sub { $indexes621{0} = $_[0];
 $k620->(map $indexes621{$_}, 0..3)
 if scalar(keys %indexes621) == 3; }); 
 ( sub {
 my ($k579) = @_;
 $k579->($xs);
 } )->( sub { $indexes621{1} = $_[0];
 $k620->(map $indexes621{$_}, 0..3)
 if scalar(keys %indexes621) == 3; }); 
 ( sub {
 my ($k580) = @_;
 $k580->(0);
 } )->( sub { $indexes621{2} = $_[0];
 $k620->(map $indexes621{$_}, 0..3)
 if scalar(keys %indexes621) == 3; }); ;
 ;
 } )->( sub { $indexes638{1} = $_[0];
 $k637->(map $indexes638{$_}, 0..3)
 if scalar(keys %indexes638) == 3; }); 
 ( sub {
 my ($k581) = @_;
 
 my $k634 = sub {
 my ($rreduce_42582, $x583, $x584, $x585) = @_;
 $rreduce_42582->($k581, $x583, $x584, $x585);
 } ;
 my %indexes635;
 ( sub {
 my ($k586) = @_;
 $k586->($rreduce_42);
 } )->( sub { $indexes635{0} = $_[0];
 $k634->(map $indexes635{$_}, 0..4)
 if scalar(keys %indexes635) == 4; }); 
 ( sub {
 my ($k587) = @_;
 $k587->($f);
 } )->( sub { $indexes635{1} = $_[0];
 $k634->(map $indexes635{$_}, 0..4)
 if scalar(keys %indexes635) == 4; }); 
 ( sub {
 my ($k588) = @_;
 $k588->($end);
 } )->( sub { $indexes635{2} = $_[0];
 $k634->(map $indexes635{$_}, 0..4)
 if scalar(keys %indexes635) == 4; }); 
 ( sub {
 my ($k589) = @_;
 
 my $k631 = sub {
 my ($aget590, $x591, $x592) = @_;
 $aget590->($k589, $x591, $x592);
 } ;
 my %indexes632;
 ( sub {
 my ($k593) = @_;
 $k593->($aget);
 } )->( sub { $indexes632{0} = $_[0];
 $k631->(map $indexes632{$_}, 0..3)
 if scalar(keys %indexes632) == 3; }); 
 ( sub {
 my ($k594) = @_;
 $k594->($xs);
 } )->( sub { $indexes632{1} = $_[0];
 $k631->(map $indexes632{$_}, 0..3)
 if scalar(keys %indexes632) == 3; }); 
 ( sub {
 my ($k595) = @_;
 $k595->(1);
 } )->( sub { $indexes632{2} = $_[0];
 $k631->(map $indexes632{$_}, 0..3)
 if scalar(keys %indexes632) == 3; }); ;
 ;
 } )->( sub { $indexes635{3} = $_[0];
 $k634->(map $indexes635{$_}, 0..4)
 if scalar(keys %indexes635) == 4; }); ;
 ;
 } )->( sub { $indexes638{2} = $_[0];
 $k637->(map $indexes638{$_}, 0..3)
 if scalar(keys %indexes638) == 3; }); ;
 ;
 } );
 } )->( sub { $indexes644{1} = $_[0];
 $k643->(map $indexes644{$_}, 0..3)
 if scalar(keys %indexes644) == 3; }); 
 ( sub {
 my ($k596) = @_;
 $k596->( sub {
 my ($k597) = @_;
 $k597->($end);
 } );
 } )->( sub { $indexes644{2} = $_[0];
 $k643->(map $indexes644{$_}, 0..3)
 if scalar(keys %indexes644) == 3; }); ;
 ;
 } )->( sub { $indexes647{0} = $_[0];
 $k646->(map $indexes647{$_}, 0..1)
 if scalar(keys %indexes647) == 1; }); ;
 ;
 } , $kf553);
 } );
 } )->( sub { $indexes652{1} = $_[0];
 $k651->(map $indexes652{$_}, 0..2)
 if scalar(keys %indexes652) == 2; }); ;
 ;
 } ));


=begin comment

(
  defcps*
  id*
  "gen"
  (
    (fn* [x] x)
    (
      fn*
      [k654 xs]
      (
        co*
        (fn* [f655] (f655 k654))
        (
          fn*
          [k656]
          (
            co*
            (fn* [x657 x658 x659] (nth* k656 x657 x658 x659))
            (
              fn*
              [k660]
              (
                co*
                (fn* [not661 x662] (not661 k660 x662))
                (fn* [k663] (k663 not))
                (
                  fn*
                  [k664]
                  (
                    co*
                    (fn* [=665 x666 x667] (=665 k664 x666 x667))
                    (fn* [k668] (k668 =))
                    (
                      fn*
                      [k669]
                      (
                        co*
                        (fn* [type670 x671] (type670 k669 x671))
                        (fn* [k672] (k672 type))
                        (fn* [k673] (k673 xs))))
                    (fn* [k674] (k674 'list'))))))
            (
              fn*
              [k675]
              (
                k675
                (
                  fn*
                  [k676]
                  (
                    co*
                    (fn* [listgen677 x678] (listgen677 k676 x678))
                    (fn* [k679] (k679 listgen))
                    (fn* [k680] (k680 xs))))))
            (
              fn*
              [k681]
              (
                k681
                (
                  fn*
                  [k682]
                  (
                    co*
                    (fn* [listgen683 x684] (listgen683 k682 x684))
                    (fn* [k685] (k685 listgen))
                    (
                      fn*
                      [k686]
                      (
                        co*
                        (fn* [to-list687 x688] (to-list687 k686 x688))
                        (fn* [k689] (k689 to-list))
                        (fn* [k690] (k690 xs))))))))))))))

=end comment

=cut

$defcps_42->($id_42, "gen", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k654, $xs) = @_;
 
 my $k733 = sub {
 my ($f655) = @_;
 $f655->($k654);
 } ;
 my %indexes734;
 ( sub {
 my ($k656) = @_;
 
 my $k730 = sub {
 my ($x657, $x658, $x659) = @_;
 ($k656)->(($x658, $x659)[$x657]) ;
 } ;
 my %indexes731;
 ( sub {
 my ($k660) = @_;
 
 my $k708 = sub {
 my ($not661, $x662) = @_;
 $not661->($k660, $x662);
 } ;
 my %indexes709;
 ( sub {
 my ($k663) = @_;
 $k663->($not);
 } )->( sub { $indexes709{0} = $_[0];
 $k708->(map $indexes709{$_}, 0..2)
 if scalar(keys %indexes709) == 2; }); 
 ( sub {
 my ($k664) = @_;
 
 my $k705 = sub {
 my ($_61665, $x666, $x667) = @_;
 $_61665->($k664, $x666, $x667);
 } ;
 my %indexes706;
 ( sub {
 my ($k668) = @_;
 $k668->($_61);
 } )->( sub { $indexes706{0} = $_[0];
 $k705->(map $indexes706{$_}, 0..3)
 if scalar(keys %indexes706) == 3; }); 
 ( sub {
 my ($k669) = @_;
 
 my $k701 = sub {
 my ($type670, $x671) = @_;
 $type670->($k669, $x671);
 } ;
 my %indexes702;
 ( sub {
 my ($k672) = @_;
 $k672->($type);
 } )->( sub { $indexes702{0} = $_[0];
 $k701->(map $indexes702{$_}, 0..2)
 if scalar(keys %indexes702) == 2; }); 
 ( sub {
 my ($k673) = @_;
 $k673->($xs);
 } )->( sub { $indexes702{1} = $_[0];
 $k701->(map $indexes702{$_}, 0..2)
 if scalar(keys %indexes702) == 2; }); ;
 ;
 } )->( sub { $indexes706{1} = $_[0];
 $k705->(map $indexes706{$_}, 0..3)
 if scalar(keys %indexes706) == 3; }); 
 ( sub {
 my ($k674) = @_;
 $k674->('list');
 } )->( sub { $indexes706{2} = $_[0];
 $k705->(map $indexes706{$_}, 0..3)
 if scalar(keys %indexes706) == 3; }); ;
 ;
 } )->( sub { $indexes709{1} = $_[0];
 $k708->(map $indexes709{$_}, 0..2)
 if scalar(keys %indexes709) == 2; }); ;
 ;
 } )->( sub { $indexes731{0} = $_[0];
 $k730->(map $indexes731{$_}, 0..3)
 if scalar(keys %indexes731) == 3; }); 
 ( sub {
 my ($k675) = @_;
 $k675->( sub {
 my ($k676) = @_;
 
 my $k714 = sub {
 my ($listgen677, $x678) = @_;
 $listgen677->($k676, $x678);
 } ;
 my %indexes715;
 ( sub {
 my ($k679) = @_;
 $k679->($listgen);
 } )->( sub { $indexes715{0} = $_[0];
 $k714->(map $indexes715{$_}, 0..2)
 if scalar(keys %indexes715) == 2; }); 
 ( sub {
 my ($k680) = @_;
 $k680->($xs);
 } )->( sub { $indexes715{1} = $_[0];
 $k714->(map $indexes715{$_}, 0..2)
 if scalar(keys %indexes715) == 2; }); ;
 ;
 } );
 } )->( sub { $indexes731{1} = $_[0];
 $k730->(map $indexes731{$_}, 0..3)
 if scalar(keys %indexes731) == 3; }); 
 ( sub {
 my ($k681) = @_;
 $k681->( sub {
 my ($k682) = @_;
 
 my $k726 = sub {
 my ($listgen683, $x684) = @_;
 $listgen683->($k682, $x684);
 } ;
 my %indexes727;
 ( sub {
 my ($k685) = @_;
 $k685->($listgen);
 } )->( sub { $indexes727{0} = $_[0];
 $k726->(map $indexes727{$_}, 0..2)
 if scalar(keys %indexes727) == 2; }); 
 ( sub {
 my ($k686) = @_;
 
 my $k723 = sub {
 my ($to_45list687, $x688) = @_;
 $to_45list687->($k686, $x688);
 } ;
 my %indexes724;
 ( sub {
 my ($k689) = @_;
 $k689->($to_45list);
 } )->( sub { $indexes724{0} = $_[0];
 $k723->(map $indexes724{$_}, 0..2)
 if scalar(keys %indexes724) == 2; }); 
 ( sub {
 my ($k690) = @_;
 $k690->($xs);
 } )->( sub { $indexes724{1} = $_[0];
 $k723->(map $indexes724{$_}, 0..2)
 if scalar(keys %indexes724) == 2; }); ;
 ;
 } )->( sub { $indexes727{1} = $_[0];
 $k726->(map $indexes727{$_}, 0..2)
 if scalar(keys %indexes727) == 2; }); ;
 ;
 } );
 } )->( sub { $indexes731{2} = $_[0];
 $k730->(map $indexes731{$_}, 0..3)
 if scalar(keys %indexes731) == 3; }); ;
 ;
 } )->( sub { $indexes734{0} = $_[0];
 $k733->(map $indexes734{$_}, 0..1)
 if scalar(keys %indexes734) == 1; }); ;
 ;
 } ));


=begin comment

(
  defcps*
  id*
  "map"
  (
    (fn* [x] x)
    (
      fn*
      [k736 f xs]
      (
        co*
        (fn* [rreduce*737 x738 x739 x740] (rreduce*737 k736 x738 x739 x740))
        (fn* [k741] (k741 rreduce*))
        (
          fn*
          [k742]
          (
            k742
            (
              fn*
              [k743 x r]
              (
                co*
                (fn* [cons744 x745 x746] (cons744 k743 x745 x746))
                (fn* [k747] (k747 cons))
                (
                  fn*
                  [k748]
                  (
                    co*
                    (fn* [f749 x750] (f749 k748 x750))
                    (fn* [k751] (k751 f))
                    (fn* [k752] (k752 x))))
                (fn* [k753] (k753 r))))))
        (fn* [k754] (co* (fn* [nil755] (nil755 k754)) (fn* [k756] (k756 nil))))
        (
          fn*
          [k757]
          (
            co*
            (fn* [gen758 x759] (gen758 k757 x759))
            (fn* [k760] (k760 gen))
            (fn* [k761] (k761 xs))))))))

=end comment

=cut

$defcps_42->($id_42, "map", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k736, $f, $xs) = @_;
 
 my $k789 = sub {
 my ($rreduce_42737, $x738, $x739, $x740) = @_;
 $rreduce_42737->($k736, $x738, $x739, $x740);
 } ;
 my %indexes790;
 ( sub {
 my ($k741) = @_;
 $k741->($rreduce_42);
 } )->( sub { $indexes790{0} = $_[0];
 $k789->(map $indexes790{$_}, 0..4)
 if scalar(keys %indexes790) == 4; }); 
 ( sub {
 my ($k742) = @_;
 $k742->( sub {
 my ($k743, $x, $r) = @_;
 
 my $k774 = sub {
 my ($cons744, $x745, $x746) = @_;
 $cons744->($k743, $x745, $x746);
 } ;
 my %indexes775;
 ( sub {
 my ($k747) = @_;
 $k747->($cons);
 } )->( sub { $indexes775{0} = $_[0];
 $k774->(map $indexes775{$_}, 0..3)
 if scalar(keys %indexes775) == 3; }); 
 ( sub {
 my ($k748) = @_;
 
 my $k770 = sub {
 my ($f749, $x750) = @_;
 $f749->($k748, $x750);
 } ;
 my %indexes771;
 ( sub {
 my ($k751) = @_;
 $k751->($f);
 } )->( sub { $indexes771{0} = $_[0];
 $k770->(map $indexes771{$_}, 0..2)
 if scalar(keys %indexes771) == 2; }); 
 ( sub {
 my ($k752) = @_;
 $k752->($x);
 } )->( sub { $indexes771{1} = $_[0];
 $k770->(map $indexes771{$_}, 0..2)
 if scalar(keys %indexes771) == 2; }); ;
 ;
 } )->( sub { $indexes775{1} = $_[0];
 $k774->(map $indexes775{$_}, 0..3)
 if scalar(keys %indexes775) == 3; }); 
 ( sub {
 my ($k753) = @_;
 $k753->($r);
 } )->( sub { $indexes775{2} = $_[0];
 $k774->(map $indexes775{$_}, 0..3)
 if scalar(keys %indexes775) == 3; }); ;
 ;
 } );
 } )->( sub { $indexes790{1} = $_[0];
 $k789->(map $indexes790{$_}, 0..4)
 if scalar(keys %indexes790) == 4; }); 
 ( sub {
 my ($k754) = @_;
 
 my $k780 = sub {
 my ($nil755) = @_;
 $nil755->($k754);
 } ;
 my %indexes781;
 ( sub {
 my ($k756) = @_;
 $k756->($nil);
 } )->( sub { $indexes781{0} = $_[0];
 $k780->(map $indexes781{$_}, 0..1)
 if scalar(keys %indexes781) == 1; }); ;
 ;
 } )->( sub { $indexes790{2} = $_[0];
 $k789->(map $indexes790{$_}, 0..4)
 if scalar(keys %indexes790) == 4; }); 
 ( sub {
 my ($k757) = @_;
 
 my $k786 = sub {
 my ($gen758, $x759) = @_;
 $gen758->($k757, $x759);
 } ;
 my %indexes787;
 ( sub {
 my ($k760) = @_;
 $k760->($gen);
 } )->( sub { $indexes787{0} = $_[0];
 $k786->(map $indexes787{$_}, 0..2)
 if scalar(keys %indexes787) == 2; }); 
 ( sub {
 my ($k761) = @_;
 $k761->($xs);
 } )->( sub { $indexes787{1} = $_[0];
 $k786->(map $indexes787{$_}, 0..2)
 if scalar(keys %indexes787) == 2; }); ;
 ;
 } )->( sub { $indexes790{3} = $_[0];
 $k789->(map $indexes790{$_}, 0..4)
 if scalar(keys %indexes790) == 4; }); ;
 ;
 } ));


=begin comment

(
  defcps*
  id*
  "filter"
  (
    (fn* [x] x)
    (
      fn*
      [k792 f xs]
      (
        co*
        (fn* [rreduce*793 x794 x795 x796] (rreduce*793 k792 x794 x795 x796))
        (fn* [k797] (k797 rreduce*))
        (
          fn*
          [k798]
          (
            k798
            (
              fn*
              [k799 x r]
              (
                co*
                (fn* [f800] (f800 k799))
                (
                  fn*
                  [k801]
                  (
                    co*
                    (fn* [x802 x803 x804] (nth* k801 x802 x803 x804))
                    (
                      fn*
                      [k805]
                      (
                        co*
                        (fn* [not806 x807] (not806 k805 x807))
                        (fn* [k808] (k808 not))
                        (
                          fn*
                          [k809]
                          (
                            co*
                            (fn* [f810 x811] (f810 k809 x811))
                            (fn* [k812] (k812 f))
                            (fn* [k813] (k813 x))))))
                    (
                      fn*
                      [k814]
                      (
                        k814
                        (
                          fn*
                          [k815]
                          (
                            co*
                            (fn* [cons816 x817 x818] (cons816 k815 x817 x818))
                            (fn* [k819] (k819 cons))
                            (fn* [k820] (k820 x))
                            (fn* [k821] (k821 r))))))
                    (fn* [k822] (k822 (fn* [k823] (k823 r))))))))))
        (fn* [k824] (co* (fn* [nil825] (nil825 k824)) (fn* [k826] (k826 nil))))
        (
          fn*
          [k827]
          (
            co*
            (fn* [gen828 x829] (gen828 k827 x829))
            (fn* [k830] (k830 gen))
            (fn* [k831] (k831 xs))))))))

=end comment

=cut

$defcps_42->($id_42, "filter", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k792, $f, $xs) = @_;
 
 my $k876 = sub {
 my ($rreduce_42793, $x794, $x795, $x796) = @_;
 $rreduce_42793->($k792, $x794, $x795, $x796);
 } ;
 my %indexes877;
 ( sub {
 my ($k797) = @_;
 $k797->($rreduce_42);
 } )->( sub { $indexes877{0} = $_[0];
 $k876->(map $indexes877{$_}, 0..4)
 if scalar(keys %indexes877) == 4; }); 
 ( sub {
 my ($k798) = @_;
 $k798->( sub {
 my ($k799, $x, $r) = @_;
 
 my $k861 = sub {
 my ($f800) = @_;
 $f800->($k799);
 } ;
 my %indexes862;
 ( sub {
 my ($k801) = @_;
 
 my $k858 = sub {
 my ($x802, $x803, $x804) = @_;
 ($k801)->(($x803, $x804)[$x802]) ;
 } ;
 my %indexes859;
 ( sub {
 my ($k805) = @_;
 
 my $k845 = sub {
 my ($not806, $x807) = @_;
 $not806->($k805, $x807);
 } ;
 my %indexes846;
 ( sub {
 my ($k808) = @_;
 $k808->($not);
 } )->( sub { $indexes846{0} = $_[0];
 $k845->(map $indexes846{$_}, 0..2)
 if scalar(keys %indexes846) == 2; }); 
 ( sub {
 my ($k809) = @_;
 
 my $k842 = sub {
 my ($f810, $x811) = @_;
 $f810->($k809, $x811);
 } ;
 my %indexes843;
 ( sub {
 my ($k812) = @_;
 $k812->($f);
 } )->( sub { $indexes843{0} = $_[0];
 $k842->(map $indexes843{$_}, 0..2)
 if scalar(keys %indexes843) == 2; }); 
 ( sub {
 my ($k813) = @_;
 $k813->($x);
 } )->( sub { $indexes843{1} = $_[0];
 $k842->(map $indexes843{$_}, 0..2)
 if scalar(keys %indexes843) == 2; }); ;
 ;
 } )->( sub { $indexes846{1} = $_[0];
 $k845->(map $indexes846{$_}, 0..2)
 if scalar(keys %indexes846) == 2; }); ;
 ;
 } )->( sub { $indexes859{0} = $_[0];
 $k858->(map $indexes859{$_}, 0..3)
 if scalar(keys %indexes859) == 3; }); 
 ( sub {
 my ($k814) = @_;
 $k814->( sub {
 my ($k815) = @_;
 
 my $k852 = sub {
 my ($cons816, $x817, $x818) = @_;
 $cons816->($k815, $x817, $x818);
 } ;
 my %indexes853;
 ( sub {
 my ($k819) = @_;
 $k819->($cons);
 } )->( sub { $indexes853{0} = $_[0];
 $k852->(map $indexes853{$_}, 0..3)
 if scalar(keys %indexes853) == 3; }); 
 ( sub {
 my ($k820) = @_;
 $k820->($x);
 } )->( sub { $indexes853{1} = $_[0];
 $k852->(map $indexes853{$_}, 0..3)
 if scalar(keys %indexes853) == 3; }); 
 ( sub {
 my ($k821) = @_;
 $k821->($r);
 } )->( sub { $indexes853{2} = $_[0];
 $k852->(map $indexes853{$_}, 0..3)
 if scalar(keys %indexes853) == 3; }); ;
 ;
 } );
 } )->( sub { $indexes859{1} = $_[0];
 $k858->(map $indexes859{$_}, 0..3)
 if scalar(keys %indexes859) == 3; }); 
 ( sub {
 my ($k822) = @_;
 $k822->( sub {
 my ($k823) = @_;
 $k823->($r);
 } );
 } )->( sub { $indexes859{2} = $_[0];
 $k858->(map $indexes859{$_}, 0..3)
 if scalar(keys %indexes859) == 3; }); ;
 ;
 } )->( sub { $indexes862{0} = $_[0];
 $k861->(map $indexes862{$_}, 0..1)
 if scalar(keys %indexes862) == 1; }); ;
 ;
 } );
 } )->( sub { $indexes877{1} = $_[0];
 $k876->(map $indexes877{$_}, 0..4)
 if scalar(keys %indexes877) == 4; }); 
 ( sub {
 my ($k824) = @_;
 
 my $k867 = sub {
 my ($nil825) = @_;
 $nil825->($k824);
 } ;
 my %indexes868;
 ( sub {
 my ($k826) = @_;
 $k826->($nil);
 } )->( sub { $indexes868{0} = $_[0];
 $k867->(map $indexes868{$_}, 0..1)
 if scalar(keys %indexes868) == 1; }); ;
 ;
 } )->( sub { $indexes877{2} = $_[0];
 $k876->(map $indexes877{$_}, 0..4)
 if scalar(keys %indexes877) == 4; }); 
 ( sub {
 my ($k827) = @_;
 
 my $k873 = sub {
 my ($gen828, $x829) = @_;
 $gen828->($k827, $x829);
 } ;
 my %indexes874;
 ( sub {
 my ($k830) = @_;
 $k830->($gen);
 } )->( sub { $indexes874{0} = $_[0];
 $k873->(map $indexes874{$_}, 0..2)
 if scalar(keys %indexes874) == 2; }); 
 ( sub {
 my ($k831) = @_;
 $k831->($xs);
 } )->( sub { $indexes874{1} = $_[0];
 $k873->(map $indexes874{$_}, 0..2)
 if scalar(keys %indexes874) == 2; }); ;
 ;
 } )->( sub { $indexes877{3} = $_[0];
 $k876->(map $indexes877{$_}, 0..4)
 if scalar(keys %indexes877) == 4; }); ;
 ;
 } ));


=begin comment

(
  defcps*
  id*
  "append"
  (
    (fn* [x] x)
    (
      fn*
      [k879 xs ys]
      (
        co*
        (fn* [rreduce*880 x881 x882 x883] (rreduce*880 k879 x881 x882 x883))
        (fn* [k884] (k884 rreduce*))
        (fn* [k885] (k885 cons))
        (fn* [k886] (k886 ys))
        (
          fn*
          [k887]
          (
            co*
            (fn* [gen888 x889] (gen888 k887 x889))
            (fn* [k890] (k890 gen))
            (fn* [k891] (k891 xs))))))))

=end comment

=cut

$defcps_42->($id_42, "append", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my ($k879, $xs, $ys) = @_;
 
 my $k903 = sub {
 my ($rreduce_42880, $x881, $x882, $x883) = @_;
 $rreduce_42880->($k879, $x881, $x882, $x883);
 } ;
 my %indexes904;
 ( sub {
 my ($k884) = @_;
 $k884->($rreduce_42);
 } )->( sub { $indexes904{0} = $_[0];
 $k903->(map $indexes904{$_}, 0..4)
 if scalar(keys %indexes904) == 4; }); 
 ( sub {
 my ($k885) = @_;
 $k885->($cons);
 } )->( sub { $indexes904{1} = $_[0];
 $k903->(map $indexes904{$_}, 0..4)
 if scalar(keys %indexes904) == 4; }); 
 ( sub {
 my ($k886) = @_;
 $k886->($ys);
 } )->( sub { $indexes904{2} = $_[0];
 $k903->(map $indexes904{$_}, 0..4)
 if scalar(keys %indexes904) == 4; }); 
 ( sub {
 my ($k887) = @_;
 
 my $k900 = sub {
 my ($gen888, $x889) = @_;
 $gen888->($k887, $x889);
 } ;
 my %indexes901;
 ( sub {
 my ($k890) = @_;
 $k890->($gen);
 } )->( sub { $indexes901{0} = $_[0];
 $k900->(map $indexes901{$_}, 0..2)
 if scalar(keys %indexes901) == 2; }); 
 ( sub {
 my ($k891) = @_;
 $k891->($xs);
 } )->( sub { $indexes901{1} = $_[0];
 $k900->(map $indexes901{$_}, 0..2)
 if scalar(keys %indexes901) == 2; }); ;
 ;
 } )->( sub { $indexes904{3} = $_[0];
 $k903->(map $indexes904{$_}, 0..4)
 if scalar(keys %indexes904) == 4; }); ;
 ;
 } ));


=begin comment

(
  defmacrocps*
  id*
  "cond"
  (
    (fn* [x] x)
    (
      fn*
      kf907
      (
        uncons
        (
          fn*
          [k906 cases]
          (
            co*
            (fn* [f908] (f908 k906))
            (
              fn*
              [k909]
              (
                co*
                (fn* [x910 x911 x912] (nth* k909 x910 x911 x912))
                (
                  fn*
                  [k913]
                  (
                    co*
                    (fn* [not914 x915] (not914 k913 x915))
                    (fn* [k916] (k916 not))
                    (
                      fn*
                      [k917]
                      (
                        co*
                        (fn* [count918 x919] (count918 k917 x919))
                        (fn* [k920] (k920 count))
                        (fn* [k921] (k921 cases))))))
                (
                  fn*
                  [k922]
                  (
                    k922
                    (
                      fn*
                      [k923]
                      (
                        co*
                        (
                          fn*
                          [list924 x925 x926 x927 x928]
                          (list924 k923 x925 x926 x927 x928))
                        (fn* [k929] (k929 list))
                        (
                          fn*
                          [k930]
                          (
                            co*
                            (fn* [str-sym931 x932] (str-sym931 k930 x932))
                            (fn* [k933] (k933 str-sym))
                            (fn* [k934] (k934 'if'))))
                        (
                          fn*
                          [k935]
                          (
                            co*
                            (fn* [car936 x937] (car936 k935 x937))
                            (fn* [k938] (k938 car))
                            (fn* [k939] (k939 cases))))
                        (
                          fn*
                          [k940]
                          (
                            co*
                            (fn* [car941 x942] (car941 k940 x942))
                            (fn* [k943] (k943 car))
                            (
                              fn*
                              [k944]
                              (
                                co*
                                (fn* [cdr945 x946] (cdr945 k944 x946))
                                (fn* [k947] (k947 cdr))
                                (fn* [k948] (k948 cases))))))
                        (
                          fn*
                          [k949]
                          (
                            co*
                            (
                              fn*
                              [append950 x951 x952]
                              (append950 k949 x951 x952))
                            (fn* [k953] (k953 append))
                            (
                              fn*
                              [k954]
                              (
                                co*
                                (fn* [list955 x956] (list955 k954 x956))
                                (fn* [k957] (k957 list))
                                (
                                  fn*
                                  [k958]
                                  (
                                    co*
                                    (
                                      fn*
                                      [str-sym959 x960]
                                      (str-sym959 k958 x960))
                                    (fn* [k961] (k961 str-sym))
                                    (fn* [k962] (k962 'cond'))))))
                            (
                              fn*
                              [k963]
                              (
                                co*
                                (fn* [cdr964 x965] (cdr964 k963 x965))
                                (fn* [k966] (k966 cdr))
                                (
                                  fn*
                                  [k967]
                                  (
                                    co*
                                    (fn* [cdr968 x969] (cdr968 k967 x969))
                                    (fn* [k970] (k970 cdr))
                                    (fn* [k971] (k971 cases))))))))))))
                (
                  fn*
                  [k972]
                  (
                    k972
                    (
                      fn*
                      [k973]
                      (
                        co*
                        (fn* [list974 x975] (list974 k973 x975))
                        (fn* [k976] (k976 list))
                        (
                          fn*
                          [k977]
                          (
                            co*
                            (fn* [str-sym978 x979] (str-sym978 k977 x979))
                            (fn* [k980] (k980 str-sym))
                            (fn* [k981] (k981 'nil'))))))))))))
        kf907))))

=end comment

=cut

$defmacrocps_42->($id_42, "cond", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my $kf907 = \@_;
 $uncons->( sub {
 my ($k906, $cases) = @_;
 
 my $k1067 = sub {
 my ($f908) = @_;
 $f908->($k906);
 } ;
 my %indexes1068;
 ( sub {
 my ($k909) = @_;
 
 my $k1064 = sub {
 my ($x910, $x911, $x912) = @_;
 ($k909)->(($x911, $x912)[$x910]) ;
 } ;
 my %indexes1065;
 ( sub {
 my ($k913) = @_;
 
 my $k993 = sub {
 my ($not914, $x915) = @_;
 $not914->($k913, $x915);
 } ;
 my %indexes994;
 ( sub {
 my ($k916) = @_;
 $k916->($not);
 } )->( sub { $indexes994{0} = $_[0];
 $k993->(map $indexes994{$_}, 0..2)
 if scalar(keys %indexes994) == 2; }); 
 ( sub {
 my ($k917) = @_;
 
 my $k990 = sub {
 my ($count918, $x919) = @_;
 $count918->($k917, $x919);
 } ;
 my %indexes991;
 ( sub {
 my ($k920) = @_;
 $k920->($count);
 } )->( sub { $indexes991{0} = $_[0];
 $k990->(map $indexes991{$_}, 0..2)
 if scalar(keys %indexes991) == 2; }); 
 ( sub {
 my ($k921) = @_;
 $k921->($cases);
 } )->( sub { $indexes991{1} = $_[0];
 $k990->(map $indexes991{$_}, 0..2)
 if scalar(keys %indexes991) == 2; }); ;
 ;
 } )->( sub { $indexes994{1} = $_[0];
 $k993->(map $indexes994{$_}, 0..2)
 if scalar(keys %indexes994) == 2; }); ;
 ;
 } )->( sub { $indexes1065{0} = $_[0];
 $k1064->(map $indexes1065{$_}, 0..3)
 if scalar(keys %indexes1065) == 3; }); 
 ( sub {
 my ($k922) = @_;
 $k922->( sub {
 my ($k923) = @_;
 
 my $k1048 = sub {
 my ($list924, $x925, $x926, $x927, $x928) = @_;
 $list924->($k923, $x925, $x926, $x927, $x928);
 } ;
 my %indexes1049;
 ( sub {
 my ($k929) = @_;
 $k929->($list);
 } )->( sub { $indexes1049{0} = $_[0];
 $k1048->(map $indexes1049{$_}, 0..5)
 if scalar(keys %indexes1049) == 5; }); 
 ( sub {
 my ($k930) = @_;
 
 my $k1001 = sub {
 my ($str_45sym931, $x932) = @_;
 $str_45sym931->($k930, $x932);
 } ;
 my %indexes1002;
 ( sub {
 my ($k933) = @_;
 $k933->($str_45sym);
 } )->( sub { $indexes1002{0} = $_[0];
 $k1001->(map $indexes1002{$_}, 0..2)
 if scalar(keys %indexes1002) == 2; }); 
 ( sub {
 my ($k934) = @_;
 $k934->('if');
 } )->( sub { $indexes1002{1} = $_[0];
 $k1001->(map $indexes1002{$_}, 0..2)
 if scalar(keys %indexes1002) == 2; }); ;
 ;
 } )->( sub { $indexes1049{1} = $_[0];
 $k1048->(map $indexes1049{$_}, 0..5)
 if scalar(keys %indexes1049) == 5; }); 
 ( sub {
 my ($k935) = @_;
 
 my $k1007 = sub {
 my ($car936, $x937) = @_;
 $car936->($k935, $x937);
 } ;
 my %indexes1008;
 ( sub {
 my ($k938) = @_;
 $k938->($car);
 } )->( sub { $indexes1008{0} = $_[0];
 $k1007->(map $indexes1008{$_}, 0..2)
 if scalar(keys %indexes1008) == 2; }); 
 ( sub {
 my ($k939) = @_;
 $k939->($cases);
 } )->( sub { $indexes1008{1} = $_[0];
 $k1007->(map $indexes1008{$_}, 0..2)
 if scalar(keys %indexes1008) == 2; }); ;
 ;
 } )->( sub { $indexes1049{2} = $_[0];
 $k1048->(map $indexes1049{$_}, 0..5)
 if scalar(keys %indexes1049) == 5; }); 
 ( sub {
 my ($k940) = @_;
 
 my $k1018 = sub {
 my ($car941, $x942) = @_;
 $car941->($k940, $x942);
 } ;
 my %indexes1019;
 ( sub {
 my ($k943) = @_;
 $k943->($car);
 } )->( sub { $indexes1019{0} = $_[0];
 $k1018->(map $indexes1019{$_}, 0..2)
 if scalar(keys %indexes1019) == 2; }); 
 ( sub {
 my ($k944) = @_;
 
 my $k1015 = sub {
 my ($cdr945, $x946) = @_;
 $cdr945->($k944, $x946);
 } ;
 my %indexes1016;
 ( sub {
 my ($k947) = @_;
 $k947->($cdr);
 } )->( sub { $indexes1016{0} = $_[0];
 $k1015->(map $indexes1016{$_}, 0..2)
 if scalar(keys %indexes1016) == 2; }); 
 ( sub {
 my ($k948) = @_;
 $k948->($cases);
 } )->( sub { $indexes1016{1} = $_[0];
 $k1015->(map $indexes1016{$_}, 0..2)
 if scalar(keys %indexes1016) == 2; }); ;
 ;
 } )->( sub { $indexes1019{1} = $_[0];
 $k1018->(map $indexes1019{$_}, 0..2)
 if scalar(keys %indexes1019) == 2; }); ;
 ;
 } )->( sub { $indexes1049{3} = $_[0];
 $k1048->(map $indexes1049{$_}, 0..5)
 if scalar(keys %indexes1049) == 5; }); 
 ( sub {
 my ($k949) = @_;
 
 my $k1045 = sub {
 my ($append950, $x951, $x952) = @_;
 $append950->($k949, $x951, $x952);
 } ;
 my %indexes1046;
 ( sub {
 my ($k953) = @_;
 $k953->($append);
 } )->( sub { $indexes1046{0} = $_[0];
 $k1045->(map $indexes1046{$_}, 0..3)
 if scalar(keys %indexes1046) == 3; }); 
 ( sub {
 my ($k954) = @_;
 
 my $k1031 = sub {
 my ($list955, $x956) = @_;
 $list955->($k954, $x956);
 } ;
 my %indexes1032;
 ( sub {
 my ($k957) = @_;
 $k957->($list);
 } )->( sub { $indexes1032{0} = $_[0];
 $k1031->(map $indexes1032{$_}, 0..2)
 if scalar(keys %indexes1032) == 2; }); 
 ( sub {
 my ($k958) = @_;
 
 my $k1028 = sub {
 my ($str_45sym959, $x960) = @_;
 $str_45sym959->($k958, $x960);
 } ;
 my %indexes1029;
 ( sub {
 my ($k961) = @_;
 $k961->($str_45sym);
 } )->( sub { $indexes1029{0} = $_[0];
 $k1028->(map $indexes1029{$_}, 0..2)
 if scalar(keys %indexes1029) == 2; }); 
 ( sub {
 my ($k962) = @_;
 $k962->('cond');
 } )->( sub { $indexes1029{1} = $_[0];
 $k1028->(map $indexes1029{$_}, 0..2)
 if scalar(keys %indexes1029) == 2; }); ;
 ;
 } )->( sub { $indexes1032{1} = $_[0];
 $k1031->(map $indexes1032{$_}, 0..2)
 if scalar(keys %indexes1032) == 2; }); ;
 ;
 } )->( sub { $indexes1046{1} = $_[0];
 $k1045->(map $indexes1046{$_}, 0..3)
 if scalar(keys %indexes1046) == 3; }); 
 ( sub {
 my ($k963) = @_;
 
 my $k1042 = sub {
 my ($cdr964, $x965) = @_;
 $cdr964->($k963, $x965);
 } ;
 my %indexes1043;
 ( sub {
 my ($k966) = @_;
 $k966->($cdr);
 } )->( sub { $indexes1043{0} = $_[0];
 $k1042->(map $indexes1043{$_}, 0..2)
 if scalar(keys %indexes1043) == 2; }); 
 ( sub {
 my ($k967) = @_;
 
 my $k1039 = sub {
 my ($cdr968, $x969) = @_;
 $cdr968->($k967, $x969);
 } ;
 my %indexes1040;
 ( sub {
 my ($k970) = @_;
 $k970->($cdr);
 } )->( sub { $indexes1040{0} = $_[0];
 $k1039->(map $indexes1040{$_}, 0..2)
 if scalar(keys %indexes1040) == 2; }); 
 ( sub {
 my ($k971) = @_;
 $k971->($cases);
 } )->( sub { $indexes1040{1} = $_[0];
 $k1039->(map $indexes1040{$_}, 0..2)
 if scalar(keys %indexes1040) == 2; }); ;
 ;
 } )->( sub { $indexes1043{1} = $_[0];
 $k1042->(map $indexes1043{$_}, 0..2)
 if scalar(keys %indexes1043) == 2; }); ;
 ;
 } )->( sub { $indexes1046{2} = $_[0];
 $k1045->(map $indexes1046{$_}, 0..3)
 if scalar(keys %indexes1046) == 3; }); ;
 ;
 } )->( sub { $indexes1049{4} = $_[0];
 $k1048->(map $indexes1049{$_}, 0..5)
 if scalar(keys %indexes1049) == 5; }); ;
 ;
 } );
 } )->( sub { $indexes1065{1} = $_[0];
 $k1064->(map $indexes1065{$_}, 0..3)
 if scalar(keys %indexes1065) == 3; }); 
 ( sub {
 my ($k972) = @_;
 $k972->( sub {
 my ($k973) = @_;
 
 my $k1060 = sub {
 my ($list974, $x975) = @_;
 $list974->($k973, $x975);
 } ;
 my %indexes1061;
 ( sub {
 my ($k976) = @_;
 $k976->($list);
 } )->( sub { $indexes1061{0} = $_[0];
 $k1060->(map $indexes1061{$_}, 0..2)
 if scalar(keys %indexes1061) == 2; }); 
 ( sub {
 my ($k977) = @_;
 
 my $k1057 = sub {
 my ($str_45sym978, $x979) = @_;
 $str_45sym978->($k977, $x979);
 } ;
 my %indexes1058;
 ( sub {
 my ($k980) = @_;
 $k980->($str_45sym);
 } )->( sub { $indexes1058{0} = $_[0];
 $k1057->(map $indexes1058{$_}, 0..2)
 if scalar(keys %indexes1058) == 2; }); 
 ( sub {
 my ($k981) = @_;
 $k981->('nil');
 } )->( sub { $indexes1058{1} = $_[0];
 $k1057->(map $indexes1058{$_}, 0..2)
 if scalar(keys %indexes1058) == 2; }); ;
 ;
 } )->( sub { $indexes1061{1} = $_[0];
 $k1060->(map $indexes1061{$_}, 0..2)
 if scalar(keys %indexes1061) == 2; }); ;
 ;
 } );
 } )->( sub { $indexes1065{2} = $_[0];
 $k1064->(map $indexes1065{$_}, 0..3)
 if scalar(keys %indexes1065) == 3; }); ;
 ;
 } )->( sub { $indexes1068{0} = $_[0];
 $k1067->(map $indexes1068{$_}, 0..1)
 if scalar(keys %indexes1068) == 1; }); ;
 ;
 } , $kf907);
 } ));


=begin comment

(
  defmacrocps*
  id*
  "->>"
  (
    (fn* [x] x)
    (
      fn*
      kf1072
      (
        uncons
        (
          fn*
          [k1071 forms]
          (
            co*
            (
              fn*
              [lreduce*1073 x1074 x1075 x1076]
              (lreduce*1073 k1071 x1074 x1075 x1076))
            (fn* [k1077] (k1077 lreduce*))
            (
              fn*
              [k1078]
              (
                k1078
                (
                  fn*
                  [k1079 x form]
                  (
                    co*
                    (
                      fn*
                      [append1080 x1081 x1082]
                      (append1080 k1079 x1081 x1082))
                    (fn* [k1083] (k1083 append))
                    (fn* [k1084] (k1084 form))
                    (
                      fn*
                      [k1085]
                      (
                        co*
                        (fn* [list1086 x1087] (list1086 k1085 x1087))
                        (fn* [k1088] (k1088 list))
                        (fn* [k1089] (k1089 x))))))))
            (
              fn*
              [k1090]
              (
                co*
                (fn* [car1091 x1092] (car1091 k1090 x1092))
                (fn* [k1093] (k1093 car))
                (fn* [k1094] (k1094 forms))))
            (
              fn*
              [k1095]
              (
                co*
                (fn* [gen1096 x1097] (gen1096 k1095 x1097))
                (fn* [k1098] (k1098 gen))
                (
                  fn*
                  [k1099]
                  (
                    co*
                    (fn* [cdr1100 x1101] (cdr1100 k1099 x1101))
                    (fn* [k1102] (k1102 cdr))
                    (fn* [k1103] (k1103 forms))))))))
        kf1072))))

=end comment

=cut

$defmacrocps_42->($id_42, "->>", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my $kf1072 = \@_;
 $uncons->( sub {
 my ($k1071, $forms) = @_;
 
 my $k1137 = sub {
 my ($lreduce_421073, $x1074, $x1075, $x1076) = @_;
 $lreduce_421073->($k1071, $x1074, $x1075, $x1076);
 } ;
 my %indexes1138;
 ( sub {
 my ($k1077) = @_;
 $k1077->($lreduce_42);
 } )->( sub { $indexes1138{0} = $_[0];
 $k1137->(map $indexes1138{$_}, 0..4)
 if scalar(keys %indexes1138) == 4; }); 
 ( sub {
 my ($k1078) = @_;
 $k1078->( sub {
 my ($k1079, $x, $form) = @_;
 
 my $k1116 = sub {
 my ($append1080, $x1081, $x1082) = @_;
 $append1080->($k1079, $x1081, $x1082);
 } ;
 my %indexes1117;
 ( sub {
 my ($k1083) = @_;
 $k1083->($append);
 } )->( sub { $indexes1117{0} = $_[0];
 $k1116->(map $indexes1117{$_}, 0..3)
 if scalar(keys %indexes1117) == 3; }); 
 ( sub {
 my ($k1084) = @_;
 $k1084->($form);
 } )->( sub { $indexes1117{1} = $_[0];
 $k1116->(map $indexes1117{$_}, 0..3)
 if scalar(keys %indexes1117) == 3; }); 
 ( sub {
 my ($k1085) = @_;
 
 my $k1113 = sub {
 my ($list1086, $x1087) = @_;
 $list1086->($k1085, $x1087);
 } ;
 my %indexes1114;
 ( sub {
 my ($k1088) = @_;
 $k1088->($list);
 } )->( sub { $indexes1114{0} = $_[0];
 $k1113->(map $indexes1114{$_}, 0..2)
 if scalar(keys %indexes1114) == 2; }); 
 ( sub {
 my ($k1089) = @_;
 $k1089->($x);
 } )->( sub { $indexes1114{1} = $_[0];
 $k1113->(map $indexes1114{$_}, 0..2)
 if scalar(keys %indexes1114) == 2; }); ;
 ;
 } )->( sub { $indexes1117{2} = $_[0];
 $k1116->(map $indexes1117{$_}, 0..3)
 if scalar(keys %indexes1117) == 3; }); ;
 ;
 } );
 } )->( sub { $indexes1138{1} = $_[0];
 $k1137->(map $indexes1138{$_}, 0..4)
 if scalar(keys %indexes1138) == 4; }); 
 ( sub {
 my ($k1090) = @_;
 
 my $k1123 = sub {
 my ($car1091, $x1092) = @_;
 $car1091->($k1090, $x1092);
 } ;
 my %indexes1124;
 ( sub {
 my ($k1093) = @_;
 $k1093->($car);
 } )->( sub { $indexes1124{0} = $_[0];
 $k1123->(map $indexes1124{$_}, 0..2)
 if scalar(keys %indexes1124) == 2; }); 
 ( sub {
 my ($k1094) = @_;
 $k1094->($forms);
 } )->( sub { $indexes1124{1} = $_[0];
 $k1123->(map $indexes1124{$_}, 0..2)
 if scalar(keys %indexes1124) == 2; }); ;
 ;
 } )->( sub { $indexes1138{2} = $_[0];
 $k1137->(map $indexes1138{$_}, 0..4)
 if scalar(keys %indexes1138) == 4; }); 
 ( sub {
 my ($k1095) = @_;
 
 my $k1134 = sub {
 my ($gen1096, $x1097) = @_;
 $gen1096->($k1095, $x1097);
 } ;
 my %indexes1135;
 ( sub {
 my ($k1098) = @_;
 $k1098->($gen);
 } )->( sub { $indexes1135{0} = $_[0];
 $k1134->(map $indexes1135{$_}, 0..2)
 if scalar(keys %indexes1135) == 2; }); 
 ( sub {
 my ($k1099) = @_;
 
 my $k1131 = sub {
 my ($cdr1100, $x1101) = @_;
 $cdr1100->($k1099, $x1101);
 } ;
 my %indexes1132;
 ( sub {
 my ($k1102) = @_;
 $k1102->($cdr);
 } )->( sub { $indexes1132{0} = $_[0];
 $k1131->(map $indexes1132{$_}, 0..2)
 if scalar(keys %indexes1132) == 2; }); 
 ( sub {
 my ($k1103) = @_;
 $k1103->($forms);
 } )->( sub { $indexes1132{1} = $_[0];
 $k1131->(map $indexes1132{$_}, 0..2)
 if scalar(keys %indexes1132) == 2; }); ;
 ;
 } )->( sub { $indexes1135{1} = $_[0];
 $k1134->(map $indexes1135{$_}, 0..2)
 if scalar(keys %indexes1135) == 2; }); ;
 ;
 } )->( sub { $indexes1138{3} = $_[0];
 $k1137->(map $indexes1138{$_}, 0..4)
 if scalar(keys %indexes1138) == 4; }); ;
 ;
 } , $kf1072);
 } ));


=begin comment

(
  defmacrocps*
  id*
  "->"
  (
    (fn* [x] x)
    (
      fn*
      kf1142
      (
        uncons
        (
          fn*
          [k1141 forms]
          (
            co*
            (
              fn*
              [lreduce*1143 x1144 x1145 x1146]
              (lreduce*1143 k1141 x1144 x1145 x1146))
            (fn* [k1147] (k1147 lreduce*))
            (
              fn*
              [k1148]
              (
                k1148
                (
                  fn*
                  [k1149 x form]
                  (
                    co*
                    (fn* [cons1150 x1151 x1152] (cons1150 k1149 x1151 x1152))
                    (fn* [k1153] (k1153 cons))
                    (
                      fn*
                      [k1154]
                      (
                        co*
                        (fn* [car1155 x1156] (car1155 k1154 x1156))
                        (fn* [k1157] (k1157 car))
                        (fn* [k1158] (k1158 form))))
                    (
                      fn*
                      [k1159]
                      (
                        co*
                        (
                          fn*
                          [cons1160 x1161 x1162]
                          (cons1160 k1159 x1161 x1162))
                        (fn* [k1163] (k1163 cons))
                        (fn* [k1164] (k1164 x))
                        (
                          fn*
                          [k1165]
                          (
                            co*
                            (fn* [cdr1166 x1167] (cdr1166 k1165 x1167))
                            (fn* [k1168] (k1168 cdr))
                            (fn* [k1169] (k1169 form))))))))))
            (
              fn*
              [k1170]
              (
                co*
                (fn* [car1171 x1172] (car1171 k1170 x1172))
                (fn* [k1173] (k1173 car))
                (fn* [k1174] (k1174 forms))))
            (
              fn*
              [k1175]
              (
                co*
                (fn* [gen1176 x1177] (gen1176 k1175 x1177))
                (fn* [k1178] (k1178 gen))
                (
                  fn*
                  [k1179]
                  (
                    co*
                    (fn* [cdr1180 x1181] (cdr1180 k1179 x1181))
                    (fn* [k1182] (k1182 cdr))
                    (fn* [k1183] (k1183 forms))))))))
        kf1142))))

=end comment

=cut

$defmacrocps_42->($id_42, "->", sub {
 my ($x) = @_;
 $x;
 } ->( sub {
 my $kf1142 = \@_;
 $uncons->( sub {
 my ($k1141, $forms) = @_;
 
 my $k1228 = sub {
 my ($lreduce_421143, $x1144, $x1145, $x1146) = @_;
 $lreduce_421143->($k1141, $x1144, $x1145, $x1146);
 } ;
 my %indexes1229;
 ( sub {
 my ($k1147) = @_;
 $k1147->($lreduce_42);
 } )->( sub { $indexes1229{0} = $_[0];
 $k1228->(map $indexes1229{$_}, 0..4)
 if scalar(keys %indexes1229) == 4; }); 
 ( sub {
 my ($k1148) = @_;
 $k1148->( sub {
 my ($k1149, $x, $form) = @_;
 
 my $k1207 = sub {
 my ($cons1150, $x1151, $x1152) = @_;
 $cons1150->($k1149, $x1151, $x1152);
 } ;
 my %indexes1208;
 ( sub {
 my ($k1153) = @_;
 $k1153->($cons);
 } )->( sub { $indexes1208{0} = $_[0];
 $k1207->(map $indexes1208{$_}, 0..3)
 if scalar(keys %indexes1208) == 3; }); 
 ( sub {
 my ($k1154) = @_;
 
 my $k1192 = sub {
 my ($car1155, $x1156) = @_;
 $car1155->($k1154, $x1156);
 } ;
 my %indexes1193;
 ( sub {
 my ($k1157) = @_;
 $k1157->($car);
 } )->( sub { $indexes1193{0} = $_[0];
 $k1192->(map $indexes1193{$_}, 0..2)
 if scalar(keys %indexes1193) == 2; }); 
 ( sub {
 my ($k1158) = @_;
 $k1158->($form);
 } )->( sub { $indexes1193{1} = $_[0];
 $k1192->(map $indexes1193{$_}, 0..2)
 if scalar(keys %indexes1193) == 2; }); ;
 ;
 } )->( sub { $indexes1208{1} = $_[0];
 $k1207->(map $indexes1208{$_}, 0..3)
 if scalar(keys %indexes1208) == 3; }); 
 ( sub {
 my ($k1159) = @_;
 
 my $k1204 = sub {
 my ($cons1160, $x1161, $x1162) = @_;
 $cons1160->($k1159, $x1161, $x1162);
 } ;
 my %indexes1205;
 ( sub {
 my ($k1163) = @_;
 $k1163->($cons);
 } )->( sub { $indexes1205{0} = $_[0];
 $k1204->(map $indexes1205{$_}, 0..3)
 if scalar(keys %indexes1205) == 3; }); 
 ( sub {
 my ($k1164) = @_;
 $k1164->($x);
 } )->( sub { $indexes1205{1} = $_[0];
 $k1204->(map $indexes1205{$_}, 0..3)
 if scalar(keys %indexes1205) == 3; }); 
 ( sub {
 my ($k1165) = @_;
 
 my $k1201 = sub {
 my ($cdr1166, $x1167) = @_;
 $cdr1166->($k1165, $x1167);
 } ;
 my %indexes1202;
 ( sub {
 my ($k1168) = @_;
 $k1168->($cdr);
 } )->( sub { $indexes1202{0} = $_[0];
 $k1201->(map $indexes1202{$_}, 0..2)
 if scalar(keys %indexes1202) == 2; }); 
 ( sub {
 my ($k1169) = @_;
 $k1169->($form);
 } )->( sub { $indexes1202{1} = $_[0];
 $k1201->(map $indexes1202{$_}, 0..2)
 if scalar(keys %indexes1202) == 2; }); ;
 ;
 } )->( sub { $indexes1205{2} = $_[0];
 $k1204->(map $indexes1205{$_}, 0..3)
 if scalar(keys %indexes1205) == 3; }); ;
 ;
 } )->( sub { $indexes1208{2} = $_[0];
 $k1207->(map $indexes1208{$_}, 0..3)
 if scalar(keys %indexes1208) == 3; }); ;
 ;
 } );
 } )->( sub { $indexes1229{1} = $_[0];
 $k1228->(map $indexes1229{$_}, 0..4)
 if scalar(keys %indexes1229) == 4; }); 
 ( sub {
 my ($k1170) = @_;
 
 my $k1214 = sub {
 my ($car1171, $x1172) = @_;
 $car1171->($k1170, $x1172);
 } ;
 my %indexes1215;
 ( sub {
 my ($k1173) = @_;
 $k1173->($car);
 } )->( sub { $indexes1215{0} = $_[0];
 $k1214->(map $indexes1215{$_}, 0..2)
 if scalar(keys %indexes1215) == 2; }); 
 ( sub {
 my ($k1174) = @_;
 $k1174->($forms);
 } )->( sub { $indexes1215{1} = $_[0];
 $k1214->(map $indexes1215{$_}, 0..2)
 if scalar(keys %indexes1215) == 2; }); ;
 ;
 } )->( sub { $indexes1229{2} = $_[0];
 $k1228->(map $indexes1229{$_}, 0..4)
 if scalar(keys %indexes1229) == 4; }); 
 ( sub {
 my ($k1175) = @_;
 
 my $k1225 = sub {
 my ($gen1176, $x1177) = @_;
 $gen1176->($k1175, $x1177);
 } ;
 my %indexes1226;
 ( sub {
 my ($k1178) = @_;
 $k1178->($gen);
 } )->( sub { $indexes1226{0} = $_[0];
 $k1225->(map $indexes1226{$_}, 0..2)
 if scalar(keys %indexes1226) == 2; }); 
 ( sub {
 my ($k1179) = @_;
 
 my $k1222 = sub {
 my ($cdr1180, $x1181) = @_;
 $cdr1180->($k1179, $x1181);
 } ;
 my %indexes1223;
 ( sub {
 my ($k1182) = @_;
 $k1182->($cdr);
 } )->( sub { $indexes1223{0} = $_[0];
 $k1222->(map $indexes1223{$_}, 0..2)
 if scalar(keys %indexes1223) == 2; }); 
 ( sub {
 my ($k1183) = @_;
 $k1183->($forms);
 } )->( sub { $indexes1223{1} = $_[0];
 $k1222->(map $indexes1223{$_}, 0..2)
 if scalar(keys %indexes1223) == 2; }); ;
 ;
 } )->( sub { $indexes1226{1} = $_[0];
 $k1225->(map $indexes1226{$_}, 0..2)
 if scalar(keys %indexes1226) == 2; }); ;
 ;
 } )->( sub { $indexes1229{3} = $_[0];
 $k1228->(map $indexes1229{$_}, 0..4)
 if scalar(keys %indexes1229) == 4; }); ;
 ;
 } , $kf1142);
 } ));
