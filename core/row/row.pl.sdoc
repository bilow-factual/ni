Row-level operations.
These reorder/drop/create entire rows without really looking at fields.

defoperator head => q{exec 'head', @_};
defoperator tail => q{exec 'tail', @_};

defoperator row_every => q{$. % $_[0] || print while <STDIN>};
defoperator row_match => q{/$_[0]/o && print while <STDIN>};
defoperator row_sample => q{
  srand $ENV{NI_SEED} || 42;
  while (<STDIN>) {
    print, $. -= -log(1 - rand()) / $_[0] if $. >= 0;
  }
};

defoperator row_sort => q{exec 'sort', @_};

our @row_alt = (
  pmap(q{tail_op '-n', $_},             pn 1, prx '\+', integer),
  pmap(q{tail_op '-n', '+' . ($_ + 1)}, pn 1, prx '-',  integer),
  pmap(q{row_every_op  $_},             pn 1, prx 'x',  number),
  pmap(q{row_match_op  $_},             pn 1, prx '/',  regex),
  pmap(q{row_sample_op $_},                   prx '\.\d+'),
  pmap(q{head_op '-n', $_},             integer));

defshort '/r', paltr @row_alt;

sub defrowalt($) {unshift @row_alt, $_[0]}

Sorting.
ni has four sorting operators, each of which can take modifiers:

| g     group: sort by byte ordering
  G     groupuniq: sort + uniq by byte ordering
  o     order: sort numeric ascending
  O     rorder: sort numeric descending

Modifiers follow the operator and dictate the column index and, optionally, the
type of sort to perform on that column (though a lot of this is already
specified by which sort operator you use). Columns are specified as A-Z, and
modifiers, which are optional, are any of these:

| g     general numeric sort (not available for all 'sort' versions)
  n     numeric sort
  r     reverse

use constant sortspec => prep pseq colspec1, popt prx '[gnr]+';

sub sort_args {'-t', "\t",
               map {my $i = ord($$_[0]) - 64;
                    my $m = defined $$_[1] ? $$_[1] : '';
                    ('-k', "$i$m,$i")} @_}

defshort '/g', pmap q{row_sort_op        sort_args @$_}, sortspec;
defshort '/G', pmap q{row_sort_op '-u',  sort_args @$_}, sortspec;
defshort '/o', pmap q{row_sort_op '-n',  sort_args @$_}, sortspec;
defshort '/O', pmap q{row_sort_op '-rn', sort_args @$_}, sortspec;

Counting.
Sorted and unsorted streaming counts.

defoperator count => q{
  my ($n, $last) = (0, undef);
  while (<STDIN>) {
    if ($_ ne $last) {
      print "$n\t$_" if defined $last;
      $n = 0;
      $last = $_;
    }
    ++$n;
  }
  print "$n\t$last" if defined $last;
};

defoperator sort_count => q{
  sicons {operate row_sort_op};
  operate count_op;
};

defshort '/c', pmap q{count_op},      pnone;
defshort '/C', pmap q{sort_count_op}, pnone;
