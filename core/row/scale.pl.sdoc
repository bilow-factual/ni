Row-based process scaling.
Allows you to alleviate process bottlenecks by distributing rows across
multiple workers.

c
BEGIN {defshort '/S', defalt 'scalealt', 'row scaling alternation list'}

Fixed scaling.
The simplest option: specify N workers and a lambda, and the lambda will be
replicated that many times. Incoming rows are broken into chunks of rows and
written to any worker that's available.

defoperator row_fixed_scale => q{
  my ($n, $f) = @_;
  $ENV{NI_NO_MONITORS} = 'yes';
  my @workers = map {siproc {exec_ni @$f}} 1..$n;
  my $ws;
  vec($ws, fileno $_, 1) = 1 for @workers;

  my $leftover;

  while (1) {
    $_ = '';
    my $nlp;
    my $n = 1;
    $n = saferead \*STDIN, $_, 65536, length
      until !$n || 0 <= ($nlp = rindex $_, "\n");

    if ($nlp >= 0) {
      $leftover = substr $_, $nlp + 1;
      $_ = substr $_, 0, $nlp + 1;
    } else {
      $leftover = '';
    }

    select undef, my $wo = $ws, undef, undef;
    for my $w (@workers) {
      if (vec $wo, fileno $w, 1) {
        safewrite $w, $_;
        last;
      }
    }

    $_ = $leftover;
    last unless $n;
  }

  close $_ for @workers;
  $_->await for @workers;
};

defscalealt pmap q{row_fixed_scale_op @$_}, pseq integer, pqfn '';
