Row-based process scaling.
Allows you to bypass process bottlenecks by distributing rows across multiple
workers.

c
BEGIN {defshort '/S', defalt 'scalealt', 'row scaling alternation list'}

Fixed scaling.
The simplest option: specify N workers and a lambda, and the lambda will be
replicated that many times. Incoming data is broken into chunks of rows and
written to any worker that's available.

defoperator row_fixed_scale => q{
  my ($n, $f) = @_;
  $ENV{NI_NO_MONITOR} = 'yes';
  my @workers = map {siproc {exec_ni @$f}} 1..$n;
  my $ws;
  my $leftover;
  my @queue;
  my $eof;

  vec($ws, fileno $_, 1) = 1 for @workers;
  until ($eof) {
    my $wn = select undef, my $wo = $ws, undef, undef;
    while (@queue < $wn && !$eof) {
      if ($eof = !saferead \*STDIN, $leftover, 8192, length $leftover) {
        push @queue, $leftover if length $leftover;
      } else {
        my $np = rindex $leftover, "\n";
        if ($np > 0) {
          push @queue, substr $leftover, 0, $np + 1;
          $leftover = substr $leftover, $np + 1;
        }
      }
    }

    @queue and vec $wo, fileno $_, 1 and safewrite $_, shift @queue
      for @workers;
  }

  close $_ for @workers;
  $_->await for @workers;
};

defscalealt pmap q{row_fixed_scale_op @$_}, pseq integer, pqfn '';
