Column manipulation operators.
In root context, ni interprets columns as being tab-delimited.

Column selection.
Normally perl is fast at text manipulation, but on most UNIX systems
`/usr/bin/cut` is at least an order of magnitude faster. We can use it if two
conditions are met:

| 1. All addressed columns are at index 8 (9 if one-based) or lower.
  2. The addressed columns are in ascending order.

sub col_cut {
  my ($floor, $rest, @fs) = @_;
  exec 'cut', '-f', join ',', $rest ? (@fs, "$floor-") : @fs;
}

our $cut_gen = gen q{chomp; @_ = split /\t/; print join("\t", @_[%is]), "\n"};

defoperator cols => q{
  # TODO: this function shouldn't be parsing column specs
  my $ind   = grep /[^A-I.]/, @_;
  my $asc   = join('', @_) eq join('', sort @_);
  my @cols  = map /^\.$/ ? -1 : ord($_) - 65, @_;
  my $floor = (sort {$b <=> $a} @cols)[0] + 1;
  return col_cut $floor, scalar(grep $_ eq '.', @_), @cols if $ind && $asc;

  my $body = $cut_gen->(is => join ',', map $_ == -1 ? "$floor..\$#_" : $_, @cols);
  eval qq{while (<STDIN>) {$body}};
};

our @col_alt = pmap q{cols_op split //, $_}, colspec;

defshort '/f', paltr @col_alt;

sub defcolalt($) {unshift @col_alt, $_[0]}

Column swapping.
This is such a common thing to do that it gets its own operator `x`. The idea
is that you're swapping the specified column(s) into the first N position(s).

sub ni_colswap(@) {
  # TODO after we do the colspec parsing refactor
}

Column splitting.
Adapters for input formats that don't have tab delimiters. Common ones are,
with their split-spec mnemonics:

| commas:       C
  pipes:        P
  whitespace:   S
  non-words:    W

You can also field-split on arbitrary regexes, or extend the %split_chalt hash
to add custom split operators.

defoperator split_chr   => q{exec 'perl', '-lnpe', "y/$_[0]/\\t/"};
defoperator split_regex => q{exec 'perl', '-lnpe', "s/$_[0]/\$1\\t/g"};
defoperator scan_regex  => q{exec 'perl', '-lne',  'print join "\t", /' . "$_[0]/g"};

our %split_dsp = (
  'C' => pmap(q{split_chr_op   ','},               pnone),
  'P' => pmap(q{split_chr_op   '|'},               pnone),
  'S' => pmap(q{split_regex_op qr/\s+/},           pnone),
  'W' => pmap(q{split_regex_op qr/[^\w\n]+/},      pnone),
  '/' => pmap(q{split_regex_op $_},                regex),
  ':' => pmap(q{split_chr_op   $_},                prx '^.'),
  'm' => pn(1, prx '^/', pmap q{scan_regex_op $_}, regex),
);

defshort '/F', pdspr %split_dsp;

sub defsplitalt($$) {$split_dsp{$_[0]} = $_[1]}
