JSPlot interop.
JSPlot is served over HTTP as a portable web interface. It requests data via
AJAX, and may request the same data multiple times to save browser memory. The
JSPlot driver buffers the data to disk to make it repeatable.

use constant jsplot_gen => gen <<'EOF';
<!doctype html>
<html>
<head>
<title>ni/jsplot</title>
<style>%css</style>
<script src='https://code.jquery.com/jquery.min.js'></script>
<script>%js</script>
</head>
<body>
<input id='i'></input>
<canvas id='c'></canvas>
</body>
</html>
EOF

use constant jsplot_html => jsplot_gen->(css => $self{'core/jsplot/jsplot.css'},
                                         js  => $self{'core/jsplot/jsplot.js'});

JSPlot data streaming.
This is the websocket connection that ni uses to stream data to the client. Any
data we receive from the client indicates that the client is canceling the
websocket request, so we need to break the pipe and kill off subprocesses.

sub jsplot_stream($$@) {
  local $_;
  my ($reply, $req, @ni_args) = @_;
  safewrite $reply, ws_header($req);
  my $ni_pipe = sni cli(@ni_args), http_websocket_encode_op;
  my $rmask   = '';
  vec($rmask, fileno $reply, 1) = 1;

  saferead $reply, $_, 8192 while select my $rout = $rmask, undef, undef, 0;

  while (saferead $ni_pipe, $_, 8192) {
    exit if select my $rout = $rmask, undef, undef, 0;
    safewrite $reply, $_;
  }
}

defoperator jsplot_server => q{
  load 'core/http/ws.pm';
  my ($port) = @_;
  chomp(my @data = <STDIN>);
  http $port, sub {
    my ($url, $req, $reply) = @_;
    return print "http://localhost:$port/\n" unless defined $reply;
    return http_reply $reply, 200, jsplot_html if $url eq '/';
    return jsplot_stream($reply, $req, @data, shell_unquote $1)
      if $url =~ /^\/ni\/(.*)/;
    http_reply $reply, 404, $url;
  };
};

defplotalt 'j', pmap q{[file_write_op, jsplot_server_op $_ || 8090]},
                popt integer;
