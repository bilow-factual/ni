JSPlot interop.
JSPlot is served over HTTP as a portable web interface. It requests data via
AJAX, and may request the same data multiple times to save browser memory. The
JSPlot driver buffers the data to disk to make it repeatable.

use constant jsplot_gen => gen $self{'core/jsplot/html'};

use constant jsplot_html =>
  jsplot_gen->(css => $self{'core/jsplot/css'},
               js  => join '', @self{qw| core/jsplot/jquery.min.js
                                         core/jsplot/jsplot.js |});

JSPlot data streaming.
This is the websocket connection that ni uses to stream data to the client. Any
data we receive from the client indicates that the client is canceling the
websocket request, so we need to break the pipe and kill off subprocesses.

sub jsplot_stream($$@) {
  local $_;
  my ($reply, $req, @ni_args) = @_;
  my ($ops) = cli @ni_args;
  safewrite $reply, ws_header($req);
  my $ni_pipe = sni cli(@ni_args), http_websocket_encode_batch_op 65536;

  my $incoming;
  my $rmask   = '';
  vec($rmask, fileno $reply, 1) = 1;

  while (saferead $ni_pipe, $_, 65536) {
    if (select my $rout = $rmask, undef, undef, 0) {
      saferead $reply, $incoming, 8192;
      return if $incoming =~ /^\x81\x80/;
    }
    safewrite $reply, $_;
  }
}

sub jsplot_server {
  my ($port) = @_;
  load 'core/http/ws.pm';
  http $port, sub {
    my ($url, $req, $reply) = @_;
    return print "http://localhost:$port/\n"             unless defined $reply;
    return http_reply $reply, 200, jsplot_html           if $url eq '/';
    return jsplot_stream($reply, $req, shell_unquote $1) if $url =~ /^\/ni\/(.*)/;
    return http_reply $reply, 404, $url;
  };
}

defclispecial '--js', q{jsplot_server $_[0] || 8090};
