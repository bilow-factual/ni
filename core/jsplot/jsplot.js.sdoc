JSPlot.
A plotting library that allows you to live-transform the data, and that
supports incremental rendering in not much space.

$(function () {
var w   = $(window);
var c   = $('#screen');
var t   = $('#transform');
var pr  = $('#preview');
var ctx = c[0].getContext('2d');
var wwl, whl;
setInterval(function () {
  var ww = w.width(), wh = w.height();
  if (ww !== wwl || wh !== whl) {
    t.css({width: ww - 2 * t.offset().left});
    c.attr({width: wwl = ww, height: whl = wh});
    refresh();
  }
}, 50);

View coordinates.
vr = view rotation, vp = view position, vs = view scaling. Everything is done
in 3D whether we're looking at 2D or 3D data.

var vr = [0, 0, 0];
var vp = [0, 0, 0];
var vs = [0, 0, 0];

AJAX data requests.
Data comes down in small pieces and is rendered as it arrives. We do this for
two reasons: first, to decrease view latency; and second, to run in constant
space. (The client does store some data, but there's an upper bound on how
much.)

t.keydown(function (e) {if (e.which === 13) refresh()});

var incoming     = '';
var anything_new = false;

var ws = null;
var refresh = function () {
  var ws_url = document.location.href.replace(/^http:/, 'ws:') + 'ni/';
  if (ws != null) ws.close();
  ws = new WebSocket(ws_url + t.val(), 'data');
  incoming = '';
  n_points = 0;
  min_x = 0, max_x = 0, min_y = 0, max_y = 0,
  min_z = 0, max_z = 0, min_w = 0, max_w = 0;

  ws.onmessage = function (e) {
    anything_new = true;
    partial = 0;
    if (incoming.length < 2048) incoming += e.data;
    collect_point(e.data.split(/\t/));
  };
};

Rendering logic.
Super simple: [x, y, z] if present. We sample points into a cache and render
everything in timed batches.

var n_points = 0;
var partial  = 0;
var parsed   = new Float32Array(4 * 262144);

var min_x = 0, max_x = 0, min_y = 0, max_y = 0,
    min_z = 0, max_z = 0, min_w = 0, max_w = 0;

var collect_point = function (p) {
  if (n_points === 0) {
    min_x = max_x = +p[0];
    min_y = max_y = +p[1];
    min_z = max_z = +p[2];
    min_w = max_w = +p[3];
  }

  min_x = Math.min(min_x, p[0] = +p[0]);
  max_x = Math.max(max_x, p[0]);
  min_y = Math.min(min_y, p[1] = +p[1]);
  max_y = Math.max(max_y, p[1]);
  min_z = Math.min(min_z, p[2] = +p[2]);
  max_z = Math.max(max_z, p[2]);
  min_w = Math.min(min_w, p[3] = +p[3]);
  max_w = Math.max(max_w, p[3]);

  if (++n_points * 4 + 4 < parsed.length) {
    parsed[n_points * 4 + 0] = p[0];
    parsed[n_points * 4 + 1] = p[1];
    parsed[n_points * 4 + 2] = p[2];
    parsed[n_points * 4 + 3] = p[3];
  } else {
    var i = Math.random() * n_points | 0;
    if (i < parsed.length / 4) {
      parsed[i * 4 + 0] = p[0];
      parsed[i * 4 + 1] = p[1];
      parsed[i * 4 + 2] = p[2];
      parsed[i * 4 + 3] = p[3];
    }
  }
};

setInterval(function () {
  if (!anything_new) return;
  if (!partial) ctx.clearRect(0, 0, wwl, whl);

  var t = +new Date;

  var sx = wwl / (max_x - min_x);
  var sy = whl / (max_y - min_y);
  var cx = (max_x + min_x) / 2;
  var cy = (max_y + min_y) / 2;

  var id = ctx.getImageData(0, 0, wwl, whl);

  for (var i = partial; i < n_points && +new Date - t < 200;) {
    var upper = Math.min(n_points, i + 4096);
    for (; i < upper; ++i) {
      var x = wwl/2 + (parsed[i * 4 + 0] - cx) * sx | 0;
      var y = whl/2 - (parsed[i * 4 + 1] - cy) * sy | 0;
      id.data[(y * id.width + x) * 4 + 0] = 255;
      id.data[(y * id.width + x) * 4 + 1] = 255;
      id.data[(y * id.width + x) * 4 + 2] = 255;
      id.data[(y * id.width + x) * 4 + 3] += 31;
    }
  }

  ctx.putImageData(id, 0, 0);

  partial = i < n_points ? i : 0;
  anything_new = i < n_points;
  pr.text(n_points + " point(s)\n" + incoming.split(/\n/).slice(0, 8).join("\n"));
}, 250);

refresh();

});
