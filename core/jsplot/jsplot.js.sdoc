JSPlot.
A plotting library that allows you to live-transform the data, and that
supports incremental rendering in not much space.

$(function () {
var tau = 2 * Math.PI;

var w  = $(window);
var c  = $('#screen');
var o  = $('#overlay');
var t  = $('#transform');
var st = $('#status');
var pr = $('#preview');

var cs = $('#controls');
var xr = $('#xrange');
var yr = $('#yrange');
var zr = $('#zrange');

var size_label = $('#sizelabel');

var ctx = c[0].getContext('2d');
var otx = o[0].getContext('2d');
var xrc = xr[0].getContext('2d');
var yrc = yr[0].getContext('2d');
var zrc = zr[0].getContext('2d');

$('canvas').attr('unselectable', 'on').css('user-select', 'none').on('selectstart', false);
$('.autohide').click(function () {$(this).toggleClass('pinned')});

xr.mousemove(function (e) {
  overlay_x = ((e.pageX - $(this).offset().left) / $(this).width() - 0.5) / settings.s[0] - settings.f[0];
  render_overlay();
}).mouseout(function () {overlay_x = null; render_overlay()});

yr.mousemove(function (e) {
  overlay_y = ((e.pageX - $(this).offset().left) / $(this).width() - 0.5) / settings.s[1] - settings.f[1];
  render_overlay();
}).mouseout(function () {overlay_y = null; render_overlay()});

zr.mousemove(function (e) {
  overlay_z = ((e.pageX - $(this).offset().left) / $(this).width() - 0.5) / settings.s[2] - settings.f[2];
  render_overlay();
}).mouseout(function () {overlay_z = null; render_overlay()});

var settings;
var save_settings = function () {
  document.location.hash = encodeURIComponent(JSON.stringify(settings));
};

var bookmark = decodeURIComponent(document.location.hash.substr(1));
try {
  settings = JSON.parse(bookmark);
} catch (e) {
  settings = {ni: bookmark || '',
              r:  [0, 0],
              s:  [1, 1, 1],
              c:  [0, 0, 0],
              f:  [0, 0, 0],
              d:  1.4};
  save_settings();
}
t.val(settings.ni);

var wwl, whl;
var resize_stuff = function () {
  var ww = w.width() - 2, wh = w.height() - 2;
  var th = t.height() + 2;
  pr.css({top: th + 1, height: wh - th - 2});
  t .css({height: 0});
  t .css({width: ww, height: t[0].scrollHeight - 2});
  if (ww !== wwl || wh !== whl) {
    c.attr({width: wwl = ww, height: whl = wh});
    o.attr({width: wwl = ww, height: whl = wh});
    xr.attr({width: xr.width(), height: xr.height()});
    yr.attr({width: yr.width(), height: yr.height()});
    zr.attr({width: zr.width(), height: zr.height()});
    anything_new = true;
  }
};

View coordinates.
Stored as a transformation matrix + a base viewport distance.

var matrix    = function () {return [1, 0, 0, 0,
                                     0, 1, 0, 0,
                                     0, 0, 1, 0,
                                     0, 0, 0, 1]};

var translate = function (x, y, z) {var r = matrix(); r[3] = x; r[7] = y; r[11] = z; return r};
var scale     = function (x, y, z) {var r = matrix(); r[0] = x; r[5] = y; r[10] = z; return r};

var rotate_x = function (t) {
  var r = matrix(), s = Math.sin(t), c = Math.cos(t);
  r[5] = r[10] = c;
  r[6] = s;
  r[9] = -s;
  return r;
};

var rotate_y = function (t) {
  var r = matrix(), s = Math.sin(t), c = Math.cos(t);
  r[0] = r[10] = c;
  r[2] = s;
  r[8] = -s;
  return r;
};

var mm = function (a, b) {
  var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (var i = 0; i < 4; ++i)
    for (var j = 0; j < 4; ++j)
      for (var k = 0; k < 4; ++k)
        r[i*4 + j] += a[i*4 + k] * b[k*4 + j];
  return r;
};

var mx = null, my = null, mshift = false, mctrl = false;

var view_matrix = function () {
  return mm(mm(translate(settings.c[0], settings.c[1], settings.c[2]),
               mm(rotate_x(-settings.r[1] * tau),
                  rotate_y(-settings.r[0] * tau))),
            mm(scale(settings.s[0], settings.s[1], settings.s[2]),
               translate(settings.f[0], settings.f[1], settings.f[2])));
};

o.mousedown(function (e) {
  mx     = e.pageX;
  my     = e.pageY;
  mshift = e.shiftKey;
  mctrl  = e.ctrlKey || e.metaKey;
});

o.mousewheel(function (e) {
  settings.d *= Math.exp(e.deltaY * -0.01);
  partial = 0;
  anything_new = true;
  save_settings();
});

xr.mousewheel(function (e) {
  var d = (e.pageX - $(this).offset().left) / $(this).width() - 0.5;

  settings.f[0] -= d / settings.s[0];
  settings.s[0] *= Math.exp(e.deltaY * 0.01);
  settings.f[0] += d / settings.s[0];

  partial = 0;
  anything_new = true;
  render_overlay();
  save_settings();
});

yr.mousewheel(function (e) {
  var d = (e.pageX - $(this).offset().left) / $(this).width() - 0.5;

  settings.f[1] -= d / settings.s[1];
  settings.s[1] *= Math.exp(e.deltaY * 0.01);
  settings.f[1] += d / settings.s[1];

  partial = 0;
  anything_new = true;
  render_overlay();
  save_settings();
});

zr.mousewheel(function (e) {
  var d = (e.pageX - $(this).offset().left) / $(this).width() - 0.5;

  settings.f[2] -= d / settings.s[2];
  settings.s[2] *= Math.exp(e.deltaY * 0.01);
  settings.f[2] += d / settings.s[2];

  partial = 0;
  anything_new = true;
  render_overlay();
  save_settings();
});

var last_mousemove = 0;
$(document).mousemove(function (e) {
  if (mx === null) return;
  if (+new Date - last_mousemove < 30) return;
  last_mousemove = +new Date;

  var hh = wwl / 2;
  var vh = whl / 2;

  if (mctrl)
    settings.d *= Math.exp(2 * (e.pageY - my) / whl);
  else if (mshift)
    settings.r = [settings.r[0] + (e.pageX - mx) / whl,
                  settings.r[1] - (e.pageY - my) / wwl];
  else
    settings.c = [settings.c[0] + (e.pageX - mx) / wwl,
                  settings.c[1] - (e.pageY - my) / whl,
                  settings.c[2]];

  mx = e.pageX;
  my = e.pageY;
  partial = 0;
  anything_new = true;
  save_settings();
});

$(document).mouseup(function (e) {
  if (mx === null) return;
  mx = my = null;
  partial = 0;
  anything_new = true;
});

AJAX data requests.
Data comes down in small pieces and is rendered as it arrives. We do this for
two reasons: first, to decrease view latency; and second, to run in constant
space. (The client does store some data, but there's an upper bound on how
much.)

t.keydown(function (e) {if (e.which === 13 && !e.shiftKey) {refresh(); return false}});
t.keyup  (function (e) {settings.ni = t.val(); save_settings()});

var anything_new = false;
var ws = null;
var refresh = function () {
  var ws_url = document.location.href.replace(/^http:/, 'ws:').replace(/#.*/, '') + 'ni/';
  if (ws != null) {
    try {ws.send('')} catch (e) {}
    ws.close();
  }
  ws = new WebSocket(ws_url + encodeURIComponent(t.val()), 'data');
  incoming = '';
  n_points = 0;
  min_x = 0, max_x = 0, min_y = 0, max_y = 0,
  min_z = 0, max_z = 0, min_w = 0, max_w = 0;

  var continuation = '';
  var size = 0;
  var incoming = '';
  var last_data_time = +new Date - 9000;
  var dim_status_timeout = null;

  ws.onmessage = function (e) {
    var m = continuation + e.data;
    if (incoming.length < 65536)
      pr.text(incoming += e.data.substr(0, 65536));

    if (+new Date - last_data_time > 10000) {
      anything_new = true;
      partial = 0;
      last_data_time = +new Date;
    }

    var lines = m.split(/\n/);
    continuation = lines.pop();
    for (var i = 0; i < lines.length; ++i)
      collect_point(lines[i].split(/\t/));

    size_label.text(n_points + " : " + ((size += e.data.length) >>> 10) + "K");
    st.addClass('active');
    dim_status_timeout == null || clearTimeout(dim_status_timeout);
    dim_status_timeout = setTimeout(function () {
      st.removeClass('active');
    }, 500);
  };

  ws.onclose = function () {
    anything_new = true;
    partial = 0;
  };
};

Rendering logic.
Super simple: [x, y, z] if present. We sample points into a cache and render
everything in timed batches.

var n_points = 0;
var partial  = 0;
var parsed   = new Float64Array(4 * 1048576);

var min_x = 0, max_x = 0, min_y = 0, max_y = 0,
    min_z = 0, max_z = 0, min_w = 0, max_w = 0;

var collect_point = function (p) {
  if (isNaN(p[0] = +p[0])) p[0] = min_x;
  if (isNaN(p[1] = +p[1])) p[1] = min_y;
  if (isNaN(p[2] = +p[2])) p[2] = min_z;
  if (isNaN(p[3] = +p[3])) p[3] = min_w;

  if (!n_points) {
    min_x = max_x = +p[0];
    min_y = max_y = +p[1];
    min_z = max_z = +p[2];
    min_w = max_w = +p[3];
  }

  min_x = Math.min(min_x, p[0]);
  max_x = Math.max(max_x, p[0]);
  min_y = Math.min(min_y, p[1]);
  max_y = Math.max(max_y, p[1]);
  min_z = Math.min(min_z, p[2]);
  max_z = Math.max(max_z, p[2]);
  min_w = Math.min(min_w, p[3]);
  max_w = Math.max(max_w, p[3]);

  if (++n_points * 4 + 4 < parsed.length) {
    parsed[n_points * 4 + 0] = p[0];
    parsed[n_points * 4 + 1] = p[1];
    parsed[n_points * 4 + 2] = p[2];
    parsed[n_points * 4 + 3] = p[3];
  } else {
    var i = Math.random() * n_points | 0;
    if (i * 4 + 4 < parsed.length) {
      parsed[i * 4 + 0] = p[0];
      parsed[i * 4 + 1] = p[1];
      parsed[i * 4 + 2] = p[2];
      parsed[i * 4 + 3] = p[3];
    }
  }
};

var project = function (x, y, z, cm) {
  var wp = 1 / (cm[12]*x + cm[13]*y + cm[14]*z + cm[15]);
  var xp = wp * (cm[0]*x + cm[1] *y + cm[2] *z + cm[3]);
  var yp = wp * (cm[4]*x + cm[5] *y + cm[6] *z + cm[7]);
  var zp = wp * (cm[8]*x + cm[9] *y + cm[10]*z + cm[11]);
  if (zp > 0) {
    zp = 1 / zp;
    return [xp*zp, yp*zp, zp];
  }
};

var overlay_x = null;
var overlay_y = null;
var overlay_z = null;

var render_scale = function () {return Math.min(whl, wwl)};

var camera_matrix = function () {
  var sx = 1 / (max_x - min_x || 1);
  var sy = 1 / (max_y - min_y || 1);
  var sz = 1 / (max_z - min_z || 1);

  var cx = (max_x + min_x) / 2;
  var cy = (max_y + min_y) / 2;
  var cz = (max_z + min_z) / 2;

  return mm(translate(0, 0, settings.d),
            mm(view_matrix(), mm(scale(sx, sy, sz),
                                 translate(-cx, -cy, -cz))));
};

var overlay_line = function (scale, p1, p2, cm) {
  var pp1 = project(p1[0], p1[1], p1[2], cm);
  var pp2 = project(p2[0], p2[1], p2[2], cm);
  if (pp1 && pp2) {
    otx.beginPath();
    otx.moveTo(wwl/2 + scale*pp1[0], whl/2 - scale*pp1[1]);
    otx.lineTo(wwl/2 + scale*pp2[0], whl/2 - scale*pp2[1]);
    otx.stroke();
  }
};

var render_overlay = function () {
  otx.clearRect(0, 0, wwl, whl);
  otx.fillStyle = otx.strokeStyle = 'rgba(255, 96, 0, 0.5)';

  var vsize       = render_scale();
  var grid_points = 100;
  var cm          = mm(translate(0, 0, settings.d), view_matrix());

  for (var i = 0; i <= grid_points; ++i) {
    var a = -0.5;
    var b =  0.5;
    var c = -0.5 + i / grid_points;

    if (overlay_x != null) {
      overlay_line(vsize, [overlay_x, a, c], [overlay_x, b, c], cm);
      overlay_line(vsize, [overlay_x, c, a], [overlay_x, c, b], cm);
    }

    if (overlay_y != null) {
      overlay_line(vsize, [a, overlay_y, c], [b, overlay_y, c], cm);
      overlay_line(vsize, [c, overlay_y, a], [c, overlay_y, b], cm);
    }

    if (overlay_z != null) {
      overlay_line(vsize, [a, c, overlay_z], [b, c, overlay_z], cm);
      overlay_line(vsize, [c, a, overlay_z], [c, b, overlay_z], cm);
    }
  }
};

var render = function () {
  requestAnimationFrame(render);
  resize_stuff();

  if (!anything_new) return;

  var t = +new Date;
  if (!partial) {
    ctx.clearRect(0, 0, wwl, whl);
    xrc.clearRect(0, 0, xr.width(), xr.height());
    yrc.clearRect(0, 0, yr.width(), yr.height());
    zrc.clearRect(0, 0, zr.width(), zr.height());
  }
  ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
  xrc.fillStyle = 'rgba(255, 255, 255, 0.1)';
  yrc.fillStyle = 'rgba(255, 255, 255, 0.1)';
  zrc.fillStyle = 'rgba(255, 255, 255, 0.1)';

  var sx = 1 / (max_x - min_x || 1);
  var sy = 1 / (max_y - min_y || 1);
  var sz = 1 / (max_z - min_z || 1);

  var osx = settings.s[0];
  var osy = settings.s[1];
  var osz = settings.s[2];

  var ocx = settings.f[0];
  var ocy = settings.f[1];
  var ocz = settings.f[2];

  var cm = camera_matrix();
  var m00 = cm[0],  m01 = cm[1],  m02 = cm[2],  m03 = cm[3],
      m10 = cm[4],  m11 = cm[5],  m12 = cm[6],  m13 = cm[7],
      m20 = cm[8],  m21 = cm[9],  m22 = cm[10], m23 = cm[11],
      m30 = cm[12], m31 = cm[13], m32 = cm[14], m33 = cm[15];

  var step = 17;
  var end  = 255 * step & 0xff;

  var vsize = render_scale();

  var range_w = xr.width();
  var range_h = xr.height();

  var n = Math.min(parsed.length / 4, n_points);
  for (var i = partial; (i &= 0xff) != end && +new Date - t < 10; i += step) {
    for (; i < n; i += 256) {
      var x = parsed[i * 4 + 0];
      var y = parsed[i * 4 + 1];
      var z = parsed[i * 4 + 2];

      xrc.fillRect((((x - min_x) * sx - 0.5 + ocx) * osx + 0.5) * range_w, Math.random() * range_h, 1, 1);
      yrc.fillRect((((y - min_y) * sy - 0.5 + ocy) * osy + 0.5) * range_w, Math.random() * range_h, 1, 1);
      zrc.fillRect((((z - min_z) * sz - 0.5 + ocz) * osz + 0.5) * range_w, Math.random() * range_h, 1, 1);

      var wp = 1 / (m30*x + m31*y + m32*z + m33);
      var xp = wp * (m00*x + m01*y + m02*z + m03);
      var yp = wp * (m10*x + m11*y + m12*z + m13);
      var zp = wp * (m20*x + m21*y + m22*z + m23);

      if (zp > 0) {
        zp = 1 / zp;
        var ps = Math.min(Math.max(zp, 0.5), 1);
        ctx.fillRect(wwl/2 + xp * zp * vsize,
                     whl/2 - yp * zp * vsize, ps, ps);
      }
    }
  }

  partial = i === end ? 0 : i;
  anything_new = i !== end;
};

requestAnimationFrame(render);

refresh();
t.focus();

});
