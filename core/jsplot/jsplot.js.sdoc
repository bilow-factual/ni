JSPlot.
A plotting library that allows you to live-transform the data, and that
supports incremental rendering in not much space.

$(function () {
var w  = $(window);
var c  = $('#screen').attr('unselectable', 'on').css('user-select', 'none').on('selectstart', false);
var t  = $('#transform');
var pr = $('#preview');

var size_label = $('#sizelabel');

t.val(decodeURIComponent(document.location.hash.substr(1)));

var ctx = c[0].getContext('2d');

var wwl, whl;
setInterval(function () {
  var ww = w.width(), wh = w.height();
  if (ww !== wwl || wh !== whl) {
    t .css({width: ww - 2 * t.offset().left});
    pr.css({width: ww, height: wh, top: t.height() + 2 * t.offset().top});
    c .attr({width: wwl = ww, height: whl = wh});
    anything_new = true;
  }
}, 50);

View coordinates.
Stored as a transformation matrix + a base viewport distance.

var matrix    = function () {return [1, 0, 0, 0,
                                     0, 1, 0, 0,
                                     0, 0, 1, 0,
                                     0, 0, 0, 1]};

var translate = function (x, y, z) {var r = matrix(); r[3] = x; r[7] = y; r[11] = z; return r};
var scale     = function (x, y, z) {var r = matrix(); r[0] = x; r[5] = y; r[10] = z; return r};

var rotate_x = function (t) {
  var r = matrix(), s = Math.sin(t), c = Math.cos(t);
  r[5] = r[10] = c;
  r[6] = s;
  r[9] = -s;
  return r;
};

var rotate_y = function (t) {
  var r = matrix(), s = Math.sin(t), c = Math.cos(t);
  r[0] = r[10] = c;
  r[2] = s;
  r[8] = -s;
  return r;
};

var mm = function (a, b) {
  var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (var i = 0; i < 4; ++i)
    for (var j = 0; j < 4; ++j)
      for (var k = 0; k < 4; ++k)
        r[i*4 + j] += a[i*4 + k] * b[k*4 + j];
  return r;
};

var vm = [1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1];

var distance = 1.4;

var mx = null, my = null, mshift = false, mctrl = false;

c.mousedown(function (e) {
  mx     = e.pageX;
  my     = e.pageY;
  mshift = e.shiftKey;
  mctrl  = e.ctrlKey;
});

var last_mousemove = 0;
$(document).mousemove(function (e) {
  if (mx === null) return;
  if (+new Date - last_mousemove < 30) return;
  last_mousemove = +new Date;

  var hh = wwl / 2;
  var vh = whl / 2;

  if (mctrl && mshift)
    vm = mm(vm, scale(Math.exp(4 * (Math.abs(e.pageX - hh) - Math.abs(mx - hh)) / wwl),
                      Math.exp(4 * (Math.abs(e.pageY - vh) - Math.abs(my - vh)) / whl), 1));
  else if (mctrl)
    distance *= Math.exp(2 * (e.pageY - my) / whl);
  else if (mshift)
    vm = mm(rotate_x((e.pageY - my) / whl * Math.PI * 2),
            mm(vm, rotate_y(-(e.pageX - mx) / wwl * Math.PI * 2)));
  else
    vm = mm(translate((e.pageX - mx) / wwl, (my - e.pageY) / whl, 0), vm);

  mx = e.pageX;
  my = e.pageY;
  partial = 0;
  anything_new = true;
});

$(document).mouseup(function (e) {
  if (mx === null) return;
  mx = my = null;
  partial = 0;
  anything_new = true;
});

AJAX data requests.
Data comes down in small pieces and is rendered as it arrives. We do this for
two reasons: first, to decrease view latency; and second, to run in constant
space. (The client does store some data, but there's an upper bound on how
much.)

t.keydown(function (e) {if (e.which === 13 && !e.shiftKey) {refresh(); return false}});
t.keyup  (function (e) {document.location.hash = encodeURIComponent(t.val())});

var incoming       = '';
var anything_new   = false;
var last_data_time = 0;

var ws = null;
var refresh = function () {
  var ws_url = document.location.href.replace(/^http:/, 'ws:').replace(/#.*/, '') + 'ni/';
  if (ws != null) {
    try {ws.send('')} catch (e) {}
    ws.close();
  }
  ws = new WebSocket(ws_url + encodeURIComponent(t.val()), 'data');
  incoming = '';
  n_points = 0;
  min_x = 0, max_x = 0, min_y = 0, max_y = 0,
  min_z = 0, max_z = 0, min_w = 0, max_w = 0;

  var continuation = '';
  var size = 0;

  ws.onmessage = function (e) {
    var m = continuation + e.data;

    if (incoming.length < 65536) {
      incoming += m;
      pr.toggle(!/^[-+\.0-9eE\s]+\t[-+\.0-9eE\s]+/.test(incoming));
      pr.text(incoming.split(/\n/).slice(0, whl / 10 | 0)
                                  .map(function (x) {return x.substr(0, wwl / 5 | 0)})
                                  .join('\n'));
    }

    if (+new Date - last_data_time > 1000) {
      anything_new = true;
      partial = 0;
      last_data_time = +new Date;
    }

    var lines = m.split(/\n/);
    continuation = lines.pop();
    for (var i = 0; i < lines.length; ++i)
      collect_point(lines[i].split(/\t/));

    size_label.text(n_points + " : " + ((size += e.data.length) >>> 10) + "K");
  };

  ws.onclose = function () {
    anything_new = true;
    partial = 0;
  };
};

Rendering logic.
Super simple: [x, y, z] if present. We sample points into a cache and render
everything in timed batches.

var n_points = 0;
var partial  = 0;
var parsed   = new Float64Array(4 * 1048576);

var min_x = 0, max_x = 0, min_y = 0, max_y = 0,
    min_z = 0, max_z = 0, min_w = 0, max_w = 0;

var collect_point = function (p) {
  if (isNaN(p[0] = +p[0])) p[0] = min_x;
  if (isNaN(p[1] = +p[1])) p[1] = min_y;
  if (isNaN(p[2] = +p[2])) p[2] = min_z;
  if (isNaN(p[3] = +p[3])) p[3] = min_w;

  if (!n_points) {
    min_x = max_x = +p[0];
    min_y = max_y = +p[1];
    min_z = max_z = +p[2];
    min_w = max_w = +p[3];
  }

  min_x = Math.min(min_x, p[0]);
  max_x = Math.max(max_x, p[0]);
  min_y = Math.min(min_y, p[1]);
  max_y = Math.max(max_y, p[1]);
  min_z = Math.min(min_z, p[2]);
  max_z = Math.max(max_z, p[2]);
  min_w = Math.min(min_w, p[3]);
  max_w = Math.max(max_w, p[3]);

  if (++n_points * 4 + 4 < parsed.length) {
    parsed[n_points * 4 + 0] = p[0];
    parsed[n_points * 4 + 1] = p[1];
    parsed[n_points * 4 + 2] = p[2];
    parsed[n_points * 4 + 3] = p[3];
  } else {
    var i = Math.random() * n_points | 0;
    if (i * 4 + 4 < parsed.length) {
      parsed[i * 4 + 0] = p[0];
      parsed[i * 4 + 1] = p[1];
      parsed[i * 4 + 2] = p[2];
      parsed[i * 4 + 3] = p[3];
    }
  }
};

var last_callin = +new Date;

var render = function () {
  requestAnimationFrame(render);
  if (!anything_new) return;

  var t = +new Date;
  if (!partial) ctx.clearRect(0, 0, wwl, whl);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';

  var sx = 1 / (max_x - min_x || 1);
  var sy = 1 / (max_y - min_y || 1);
  var sz = 1 / (max_z - min_z || 1);

  var cx = (max_x + min_x) / 2;
  var cy = (max_y + min_y) / 2;
  var cz = (max_z + min_z) / 2;

  var cm = mm(vm, mm(scale(sx, sy, sz),
                     translate(-cx, -cy, -cz)));

  var m00 = cm[0],  m01 = cm[1],  m02 = cm[2],  m03 = cm[3],
      m10 = cm[4],  m11 = cm[5],  m12 = cm[6],  m13 = cm[7],
      m20 = cm[8],  m21 = cm[9],  m22 = cm[10], m23 = cm[11] + distance,
      m30 = cm[12], m31 = cm[13], m32 = cm[14], m33 = cm[15];

  var step = 17;
  var end  = 255 * step & 0xff;

  var n = Math.min(parsed.length / 4, n_points);
  for (var i = partial; (i &= 0xff) != end && +new Date - t < 10; i += step) {
    for (; i < n; i += 256) {
      var x = parsed[i * 4 + 0];
      var y = parsed[i * 4 + 1];
      var z = parsed[i * 4 + 2];

      var wp = 1 / (m30*x + m31*y + m32*z + m33);
      var xp = wp * (m00*x + m01*y + m02*z + m03);
      var yp = wp * (m10*x + m11*y + m12*z + m13);
      var zp = wp * (m20*x + m21*y + m22*z + m23);

      if (zp > 0) {
        zp = 1 / zp;
        var ps = Math.max(zp, 0.5);
        ctx.fillRect(xp * zp * wwl + wwl/2,
                     whl/2 - yp * zp * whl,
                     ps,
                     ps);
      }
    }
  }

  partial = i === end ? 0 : i;
  anything_new = i !== end;
};

requestAnimationFrame(render);

refresh();
t.focus();

});
