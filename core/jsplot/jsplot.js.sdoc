JSPlot.
A plotting library that allows you to live-transform the data, and that
supports incremental rendering in not much space.

$(function () {
var w  = $(window);
var c  = $('#screen');
var t  = $('#transform');
var pr = $('#preview');

t.val(decodeURIComponent(document.location.hash.substr(1)));

var onscreen_ctx = c[0].getContext('2d');

var wwl, whl;
setInterval(function () {
  var ww = w.width(), wh = w.height();
  if (ww !== wwl || wh !== whl) {
    t .css({width: ww - 2 * t.offset().left});
    c .attr({width: wwl = ww, height: whl = wh});
    pr.attr({width: ww, height: wh});
    anything_new = true;
  }
}, 50);

View coordinates.
vr = view rotation, vp = view position, vs = view scaling. Everything is done
in 3D whether we're looking at 2D or 3D data.

var vr = [0, 0, 0];
var vp = [0, 0, 0];
var vs = [1, 1, 1];

var mx = null, my = null, mshift = false;

c.mousedown(function (e) {mx = e.pageX; my = e.pageY; mshift = e.shiftKey});
$(document).mousemove(function (e) {
  if (mx === null) return;

  if (mshift !== e.shiftKey) {
    mx = e.pageX;
    my = e.pageY;
    mshift = e.shiftKey;
  }

  var hh = wwl / 2;
  var vh = whl / 2;

  if (mshift) {
    vs = [vs[0] * Math.exp(4 * (Math.abs(e.pageX - hh) - Math.abs(mx - hh)) / wwl),
          vs[1] * Math.exp(4 * (Math.abs(e.pageY - vh) - Math.abs(my - vh)) / whl), 1];
  } else
    vp = [vp[0] + (e.pageX - mx) / vs[0], vp[1] + (my - e.pageY) / vs[1], 0];

  mx = e.pageX;
  my = e.pageY;
  partial = 0;
  anything_new = true;
});
$(document).mouseup(function (e) {
  if (mx === null) return;
  mx = my = null;
  partial = 0;
  anything_new = true;
});

AJAX data requests.
Data comes down in small pieces and is rendered as it arrives. We do this for
two reasons: first, to decrease view latency; and second, to run in constant
space. (The client does store some data, but there's an upper bound on how
much.)

t.keydown(function (e) {if (e.which === 13 && !e.shiftKey) {refresh(); return false}});
t.keyup  (function (e) {document.location.hash = encodeURIComponent(t.val())});

var incoming     = '';
var anything_new = false;

var ws = null;
var refresh = function () {
  var ws_url = document.location.href.replace(/^http:/, 'ws:').replace(/#.*/, '') + 'ni/';
  if (ws != null) ws.close();
  ws = new WebSocket(ws_url + encodeURIComponent(t.val()), 'data');
  incoming = '';
  n_points = 0;
  min_x = 0, max_x = 0, min_y = 0, max_y = 0,
  min_z = 0, max_z = 0, min_w = 0, max_w = 0;

  var buffer = '';
  ws.onmessage = function (e) {
    if (incoming.length < 1048576) incoming += e.data;
    pr.toggle(!/^[-+\.0-9eE\s]+\t[-+\.0-9eE\s]+/.test(incoming));
    buffer += e.data;
    anything_new = true;
    partial = 0;
    var lines = buffer.split(/\n/);
    for (var i = 0; i < lines.length - 1; ++i)
      collect_point(lines[i].split(/\t/));
    buffer = lines.pop();
  };
};

Rendering logic.
Super simple: [x, y, z] if present. We sample points into a cache and render
everything in timed batches.

var n_points = 0;
var partial  = 0;
var parsed   = new Float64Array(4 * 1048576);

var min_x = 0, max_x = 0, min_y = 0, max_y = 0,
    min_z = 0, max_z = 0, min_w = 0, max_w = 0;

var collect_point = function (p) {
  if (!n_points) {
    min_x = max_x = +p[0];
    min_y = max_y = +p[1];
    min_z = max_z = +p[2];
    min_w = max_w = +p[3];
  }

  if (isNaN(p[0] = +p[0])) p[0] = min_x;
  if (isNaN(p[1] = +p[1])) p[1] = min_y;
  if (isNaN(p[2] = +p[2])) p[2] = min_z;
  if (isNaN(p[3] = +p[3])) p[3] = min_w;

  min_x = Math.min(min_x, p[0]);
  max_x = Math.max(max_x, p[0]);
  min_y = Math.min(min_y, p[1]);
  max_y = Math.max(max_y, p[1]);
  min_z = Math.min(min_z, p[2]);
  max_z = Math.max(max_z, p[2]);
  min_w = Math.min(min_w, p[3]);
  max_w = Math.max(max_w, p[3]);

  if (++n_points * 4 + 4 < parsed.length) {
    parsed[n_points * 4 + 0] = p[0];
    parsed[n_points * 4 + 1] = p[1];
    parsed[n_points * 4 + 2] = p[2];
    parsed[n_points * 4 + 3] = p[3];
  } else {
    var i = Math.random() * n_points | 0;
    if (i * 4 + 4 < parsed.length) {
      parsed[i * 4 + 0] = p[0];
      parsed[i * 4 + 1] = p[1];
      parsed[i * 4 + 2] = p[2];
      parsed[i * 4 + 3] = p[3];
    }
  }
};

var render = function () {
  if (!anything_new) return;
  if (!partial) onscreen_ctx.clearRect(0, 0, wwl, whl);
  onscreen_ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';

  var t = +new Date;

  var sx = wwl / (max_x - min_x);
  var sy = whl / (max_y - min_y);
  var cx = (max_x + min_x) / 2;
  var cy = (max_y + min_y) / 2;

  for (var i = partial; (i &= 0xff) < 255 && +new Date - t < 30; ++i) {
    for (; i < n_points; i += 256) {
      var x = wwl/2 + ((parsed[i * 4 + 0] - cx) * sx + vp[0]) * vs[0];
      var y = whl/2 - ((parsed[i * 4 + 1] - cy) * sy + vp[1]) * vs[1];
      onscreen_ctx.fillRect(x, y, 1, 1);
    }
  }

  partial = i === 255 ? 0 : i;
  anything_new = i !== 255;
};
setInterval(render, 50);

setInterval(function () {
  if (anything_new)
    pr.text(n_points + " row(s)\n"
                     + incoming.split(/\n/).slice(0, whl / 10 | 0).join('\n'));
}, 250);

refresh();

});
