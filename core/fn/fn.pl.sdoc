Operator->operator functions.
This provides a mechanism for ni to implement aliases and other shorthands.
Internally we do this by defining a "rewrite parser" that modifies the unparsed
elements in front of it. Rewriting is namespaced: if you define a lambda in the
root context, it won't apply in other contexts.

Here's an example of a lambda that looks for manpages matching the given
filename pattern:

| defn ['/manpages', 'pattern'],
       qw[e[find /usr/share/man -name $pattern*] \<];

After this definition, ni will perform substitutions like the following:

| $ ni manpages ls
  # ni e[find /usr/share/man -name ls*] \<

Other types of definitions.
A parameter like 'pattern' will just consume a single unparsed argument, but
sometimes you want to apply parsing structure to things. You can do that by
type-tagging the results:

| defn ['/manpages-matching', condition => plcode],
       qw[e[find /usr/share/man -type f] rp$condition];

c
BEGIN {
  defparser fn_expander => '$$',
    sub {
      my ($self, @xs) = @_;
      my (undef, $formals, $positions, $expansion) = @_;
      
    };
}

sub defn($$) {
  my ($fn, $expansion) = @_;
  my ($short_spec, @args) = @$fn;
  my ($context, $name) = split /\//, $short_spec, 2;

  my @arg_parsers;
  my %arg_positions;
  if (ref $args[1]) {
    for (my $i = 0; $i < $#args - 1; $i += 2) {
      my ($k, $v) = @args[$i, $i + 1];
      $arg_positions{$k} = $i >> 1;
      push @arg_parsers, $v;
    }
  } else {
    $arg_positions{@args[0..$#args]} = 0..$#args;
    @arg_parsers = map prc '.*', @args;
  }

  defshort $short_spec,
    fn_expander [@arg_parsers], {%arg_positions}, $expansion;
}
