Streaming data sources.
Common ways to read data, most notably from files and directories. Also
included are numeric generators, shell commands, etc.

$main_operator = sub {
  -t STDIN ? close STDIN : sicons {sdecode};
  @$_ && sicons {operate @$_} for @_;
  exec 'less' or exec 'more' if -t STDOUT;
  sio;
  0;
};

use constant shell_lambda    => pn 1, prx '\[',  prep(prc '.*[^]]'), prx '\]$';
use constant shell_lambda_ws => pn 1, prc '\[$', prep(pnx '\]$'),    prc '\]$';
use constant shell_command   => palt pmap(q{shell_quote @$_}, shell_lambda),
                                     pmap(q{shell_quote @$_}, shell_lambda_ws),
                                     prx '.*';

defoperator cat  => q{my ($f) = @_; sio; scat $f};
defoperator echo => q{my ($x) = @_; sio; print "$x\n"};
defoperator sh   => q{my ($c) = @_; sh $c};

Note that we generate numbers internally rather than shelling out to `seq`
(which is ~20x faster than Perl for the purpose, incidentally). This is
deliberate: certain versions of `seq` generate floating-point numbers after a
point, which can cause unexpected results and loss of precision.

defoperator n => q{
  my ($l, $u) = @_;
  sio; for (my $i = $l; $i < $u; ++$i) {print "$i\n"};
};

defoperator number_lines => q{
  my $n = 0;
  print ++$n, "\t", $_ while <STDIN>;
};

defshort '/n', palt pmap(q{n_op 1, $_ + 1}, number),
                    pmap q{number_lines_op}, pnone;
defshort '/n0',  pmap q{n_op 0, $_}, number;
defshort '/id:', pmap q{echo_op $_}, prc '.*';

defshort '/e', pmap q{sh_op $_}, shell_command;

deflong '/fs', pmap q{cat_op $_}, filename;

Stream mixing/forking.
Append, prepend, duplicate, divert.

defoperator append => q{
  my @xs = @_;
  sio;
  my $fh = siproc {exec_ni @xs};
  close $fh;
  $fh->await;
};

defoperator prepend => q{
  my @xs = @_;
  my $fh = siproc {exec_ni @xs};
  close $fh;
  $fh->await;
  sio;
};

defoperator duplicate => q{
  my @xs = @_;
  my $fh = siproc {exec_ni @xs};
  stee \*STDIN, $fh, \*STDOUT;
  close $fh;
  $fh->await;
};

defoperator sink_null => q{1 while saferead \*STDIN, $_, 8192};
defoperator divert => q{
  my @xs = @_;
  my $fh = siproc {close STDOUT; exec_ni @xs, sink_null_op};
  stee \*STDIN, $fh, \*STDOUT;
  close $fh;
  $fh->await;
};

defshort '/+', pmap q{append_op    @$_}, pqfn '';
defshort '/^', pmap q{prepend_op   @$_}, pqfn '';
defshort '/%', pmap q{duplicate_op @$_}, pqfn '';
defshort '/=', pmap q{divert_op    @$_}, pqfn '';

Sinking.
We can sink data into a file just as easily as we can read from it. This is
done with the `>` operator, which is typically written as `\>`. The difference
between this and the shell's > operator is that \> outputs the filename; this
lets you invert the operation with the nullary \< operator.

use constant tmpdir => $ENV{TMPDIR} || "/tmp";
sub tempfile_name() {
  my $r = '/';
  $r = tmpdir . "/ni-$$-" . noise_str 8 while -e $r;
  $r;
}

defoperator file_read  => q{chomp, weval q{scat $_} while <STDIN>};
defoperator file_write => q{
  my ($file) = @_;
  $file = tempfile_name unless defined $file;
  sforward \*STDIN, swfile $file;
  print "$file\n";
};

defshort '/>', pmap q{file_write_op $_}, nefilename;
defshort '/<', pmap q{file_read_op},     pnone;

Compression and decoding.
Sometimes you want to emit compressed data, which you can do with the `Z`
operator. It defaults to gzip, but you can also specify xz, lzo, lz4, or bzip2
by adding a suffix. You can decode a stream in any of these formats using `ZD`
(though in most cases ni will automatically decode compressed formats).

our %compressors = qw/ g gzip  x xz  o lzop  4 lz4  b bzip2 /;

use constant compressor_name => prx '[gxo4b]';
use constant compressor_spec =>
  pmap q{my ($c, $level) = @$_;
         $c = $compressors{$c || 'g'};
         defined $level ? sh_op "$c -$level" : sh_op $c},
  pseq popt compressor_name, popt integer;

defoperator decode => q{sdecode};

defshort '/z',  compressor_spec;
defshort '/zn', pk sink_null_op();
defshort '/zd', pk decode_op();
