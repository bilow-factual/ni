Compressed stream support.
This provides a stdin filter you can use to read the contents of a compressed
stream as though it weren't compressed. It's implemented as a filter process so
we don't need to rely on file extensions.

We detect the following file formats:

| gzip:  1f 8b
  bzip2: BZh\0
  lzo:   89 4c 5a 4f
  lz4:   04 22 4d 18
  xz:    fd 37 7a 58 5a

Decoding works by reading enough to decode the magic, then forwarding data
into the appropriate decoding process (or doing nothing if we don't know what
the data is). By default it works on stdin, but you can pass a different file
descriptor in if you want to.

sub sdecode(;$) {
  my ($i) = (@_, \*STDIN);

  sysread $i, $_, 8192;
  my $decoder = /^\x1f\x8b/             ? "gzip -dc"
              : /^BZh\0/                ? "bzip2 -dc"
              : /^\x89\x4c\x5a\x4f/     ? "lzop -dc"
              : /^\x04\x22\x4d\x18/     ? "lz4 -dc"
              : /^\xfd\x37\x7a\x58\x5a/ ? "xz -dc" : undef;

  if (defined $decoder) {
    open my $o, "| $decoder" or die "ni_decode: failed to open '$decoder': $!";
    syswrite $o, $_;
    syswrite $o, $_ while sysread $i, $_, 8192;
    close $o;
  } else {
    syswrite STDOUT, $_;
    syswrite STDOUT, $_ while sysread $i, $_, 8192;
  }
}

File/directory cat.
cat exists to turn filesystem objects into text. Files are emitted and
directories are turned into readable listings. Normally you'd use this in
conjunction with decode.

sub scat {
  for my $f (@_) {
    if (-d $f) {
      $| = 1;
      opendir my $d, $f or die "ni_cat: failed to opendir $f: $!";
      print "$f/$_\n" for sort grep !/^\.\.?$/, readdir $d;
      closedir $d;
    } else {
      open F, '<', $f or die "ni_cat: failed to open $f: $!";
      sforward \*F, siproc {decode};
      close F;
      await_children;
    }
  }
}
