Pipeline construction.
A way to build a shell pipeline in-process by consing a transformation onto
this process's standard input. This will cause a fork to happen, and the forked
PID is returned.

I define some system functions with a `c` prefix: these are checked system
calls that will die with a helpful message if anything fails.

use POSIX qw/dup2 :sys_wait_h/;

sub await_children() {1 while 0 < waitpid -1, WNOHANG}

sub cdup2 {dup2 @_ or die "ni: dup2(@_) failed: $!"}
sub cfork {my $pid = fork; die "ni: fork failed: $!" unless defined $pid; $pid}
sub cpipe {pipe $_[0], $_[1] or die "ni: pipe failed: $!"}

sub move_fd($$) {
  my ($old, $new) = @_;
  return if $old == $new;
  close $new;
  cdup2 $old, $new;
  close $old;
}

Process construction.
A few functions, depending on what you want to do:

| siproc(&): fork into block, return pipe FH to block's STDIN.
  soproc(&): fork into block, return pipe FH from block's STDOUT.
  sicons(&): fork into block, connect its STDOUT to our STDIN.
  socons(&): fork into block, connect our STDOUT to its STDIN.

sub forkopen($$) {
  my ($mode, $f) = @_;
  my ($fh, $pid);
  return $fh if $pid = open $fh, $mode;
  die "ni: forkopen $mode failed: $!" unless defined $pid;
  close $fh;
  &$f();
  exit;
}

sub siproc(&) {forkopen '|-', $_[0]}
sub soproc(&) {forkopen '-|', $_[0]}
sub sicons(&) {my ($f) = @_; move_fd fileno soproc {&$f(@_)}, 0}
sub socons(&) {my ($f) = @_; move_fd fileno siproc {&$f(@_)}, 1}

Stream functions.
These are called by pipelines to simplify things. For example, a common
operation is to append the output of some data-producing command:

| $ ni . .              # lists current directory twice

If you do this, ni will create a pipeline that uses stream wrappers to
concatenate the second `ls` output (despite the fact that technically it's a
shell pipe).

sub sforward($$) {local $_; syswrite $_[1], $_ while sysread $_[0], $_, 8192}
sub stee($$$)    {local $_; syswrite($_[1], $_), syswrite($_[2], $_) while sysread $_[0], $_, 8192}
sub sappend(&)   {sforward \*STDIN, \*STDOUT; &{$_[0]}()}
sub sprepend(&)  {&{$_[0]}(); sforward \*STDIN, \*STDOUT}

sub srfile($) {open my $fh, '<', $_[0] or die "ni: srfile $_[0]: $!"; $fh}
sub swfile($) {open my $fh, '>', $_[0] or die "ni: swfile $_[0]: $!"; $fh}
