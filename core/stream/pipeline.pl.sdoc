Pipeline construction.
A way to build a shell pipeline in-process by consing a transformation onto
this process's standard input. This will cause a fork to happen, and the forked
PID is returned.

I define some system functions with a `c` prefix: these are checked system
calls that will die with a helpful message if anything fails.

use POSIX qw/dup2/;

sub cdup2 {dup2 @_ or die "ni: dup2(@_) failed: $!"}
sub cfork {my $pid = fork; die "ni: fork failed: $!" unless defined $pid; $pid}
sub cpipe {pipe $_[0], $_[1] or die "ni: pipe failed: $!"}

sub move_fd($$) {
  my ($old, $new) = @_;
  return if $old == $new;
  close $new;
  cdup2 $old, $new;
  close $old;
}

Process construction.
A few functions, depending on what you want to do:

| siproc(&): fork into block, return pipe FH to block's STDIN.
  soproc(&): fork into block, return pipe FH from block's STDOUT.
  sicons(&): fork into block, connect its STDOUT to our STDIN, return pid.
  socons(&): fork into block, connect our STDOUT to its STDIN, return pid.



sub with_stdin(&$) {
  cpipe my $r, my $w;
  my $pid = cfork;
  if ($pid) {
    close $r;
    syswrite $w, $_[1];
    close $w;
    $pid;
  } else {
    close $w;
    move_fd 0, 3;
    move_fd fileno $r, 0;
    &{$_[0]}();
    exit;
  }
}

sub stdin_cons(&@) {
  cpipe my $r, my $w;
  my $pid = cfork;
  if ($pid) {
    close $w;
    move_fd fileno $r, 0;
    $pid;
  } else {
    close $r;
    move_fd fileno $w, 1;
    &{$_[0]}(@_[1..$#_]);
    exit;
  }
}
