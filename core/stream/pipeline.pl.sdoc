Pipeline construction.
A way to build a shell pipeline in-process by consing a transformation onto
this process's standard input. This will cause a fork to happen, and the forked
PID is returned.

I define some system functions with a `c` prefix: these are checked system
calls that will die with a helpful message if anything fails.

use Errno qw/EINTR/;
use POSIX qw/dup2 :sys_wait_h/;

sub await_children {
  local ($!, $?);
  1 while 0 < waitpid -1, WNOHANG;
  $SIG{CHLD} = \&await_children;
};
$SIG{CHLD} = \&await_children;

sub cdup2 {dup2 @_ or die "ni: dup2(@_) failed: $!"}
sub cpipe {pipe $_[0], $_[1] or die "ni: pipe failed: $!"}
sub cfork {my $pid = fork; die "ni: fork failed: $!" unless defined $pid; $pid}

sub move_fd($$) {
  my ($old, $new) = @_;
  return if $old == $new;
  close $new;
  cdup2 $old, $new;
  close $old;
}

Safe reads/writes.
This is required because older versions of Perl don't automatically retry
interrupted reads/writes. We run the risk of interruption because we have a
SIGCHLD handler. nfu lost data on older versions of Perl because it failed to
handle this case properly.

sub saferead($$$) {
  my $n = undef;
  do {
    return $n if defined($n = sysread $_[0], $_[1], $_[2]);
  } while $!{EINTR};
  return undef;
}

sub safewrite($$) {
  my $n = undef;
  do {
    return $n if defined($n = syswrite $_[0], $_[1]);
  } while $!{EINTR};
  return undef;
}

Process construction.
A few functions, depending on what you want to do:

| siproc(&): fork into block, return pipe FH to block's STDIN.
  soproc(&): fork into block, return pipe FH from block's STDOUT.
  sicons(&): fork into block, connect its STDOUT to our STDIN.
  socons(&): fork into block, connect our STDOUT to its STDIN.

NOTE: forkopen does something strange and noteworthy. You'll notice that it's
reopening STDIN and STDOUT from FDs, which seems redundant. This is required
because Perl filehandles aren't the same as OS-level file descriptors, and ni
deals with both in different ways.

In particular, ni closes STDIN (the filehandle) if the input comes from a
terminal, since presumably the user doesn't intend to type their input in
manually. This needs to happen before any exec() from a forked filter process.
But this creates a problem: if we later reactivate fd 0, which we do by moving
file descriptors from a pipe. We have to do this at the fd level so exec()
works correctly (since exec doesn't know anything about Perl filehandles, just
fds). Anyway, despite the fact that fd 0 is newly activated by an sicons {}
operation, Perl's STDIN filehandle will think it's closed and return no data.

So that's why we do these redundant open STDIN and STDOUT operations. At some
point I might bypass Perl's IO layer altogether and use POSIX calls, but at the
moment that seems like more trouble than it's worth.

sub forkopen($$) {
  my ($fd, $f) = @_;
  cpipe my $r, my $w;
  my ($ret, $child) = ($r, $w)[$fd ^ 1, $fd];
  if (cfork) {
    close $child;
    return $ret;
  } else {
    close $ret;
    move_fd fileno $child, $fd;
    open STDIN,  '<&=0' if $fd == 0;
    open STDOUT, '>&=1' if $fd == 1;
    &$f;
    exit;
  }
}

sub siproc(&) {forkopen 0, $_[0]}
sub soproc(&) {forkopen 1, $_[0]}
sub sicons(&) {my ($f) = @_; move_fd fileno soproc {&$f}, 0; open STDIN,  '<&=0'}
sub socons(&) {my ($f) = @_; move_fd fileno siproc {&$f}, 1; open STDOUT, '>&=1'}

Stream functions.
These are called by pipelines to simplify things. For example, a common
operation is to append the output of some data-producing command:

| $ ni . .              # lists current directory twice

If you do this, ni will create a pipeline that uses stream wrappers to
concatenate the second `ls` output (despite the fact that technically it's a
shell pipe).

sub sforward($$) {local $_; safewrite $_[1], $_ while saferead $_[0], $_, 8192}
sub stee($$$)    {local $_; safewrite($_[1], $_), safewrite($_[2], $_) while saferead $_[0], $_, 8192}
sub sappend(&)   {sforward \*STDIN, \*STDOUT; &{$_[0]}}
sub sprepend(&)  {&{$_[0]}; sforward \*STDIN, \*STDOUT}

sub srfile($) {open my $fh, '<', $_[0] or die "ni: srfile $_[0]: $!"; $fh}
sub swfile($) {open my $fh, '>', $_[0] or die "ni: swfile $_[0]: $!"; $fh}

Compressed stream support.
This provides a stdin filter you can use to read the contents of a compressed
stream as though it weren't compressed. It's implemented as a filter process so
we don't need to rely on file extensions.

We detect the following file formats:

| gzip:  1f 8b
  bzip2: BZh\0
  lzo:   89 4c 5a 4f
  lz4:   04 22 4d 18
  xz:    fd 37 7a 58 5a

Decoding works by reading enough to decode the magic, then forwarding data
into the appropriate decoding process (or doing nothing if we don't know what
the data is).

sub sdecode(;$) {
  local $_;
  return unless saferead \*STDIN, $_, 8192;

  my $decoder = /^\x1f\x8b/             ? "gzip -dc"
              : /^BZh\0/                ? "bzip2 -dc"
              : /^\x89\x4c\x5a\x4f/     ? "lzop -dc"
              : /^\x04\x22\x4d\x18/     ? "lz4 -dc"
              : /^\xfd\x37\x7a\x58\x5a/ ? "xz -dc" : undef;

  if (defined $decoder) {
    open my $o, "| $decoder" or die "ni_decode: failed to open '$decoder': $!";
    safewrite $o, $_;
    sforward \*STDIN, $o;
  } else {
    safewrite \*STDOUT, $_;
    sforward \*STDIN, \*STDOUT;
  }
}

File/directory cat.
cat exists to turn filesystem objects into text. Files are emitted and
directories are turned into readable listings. Files are automatically
decompressed.

sub scat {
  for my $f (@_) {
    if (-d $f) {
      $| = 1;
      opendir my $d, $f or die "ni_cat: failed to opendir $f: $!";
      print "$f/$_\n" for sort grep !/^\.\.?$/, readdir $d;
      closedir $d;
    } else {
      sforward srfile $f, siproc {sdecode};
    }
  }
}

Self invocation.
You can run ni and read from the resulting file descriptor; this gives you a
way to evaluate lambda expressions (this is how checkpoints work, for example).
If you do this, the ni subprocess won't receive any data on its standard input.

sub sni_exec_list(@) {
  my $stdin = image_with 'transient/op' => json_encode([@_]);
  ($stdin, qw|perl - --internal/operate transient/op|);
}

sub exec_ni(@) {
  my ($stdin, @argv) = sni_exec_list @_;
  safewrite siproc {exec @argv}, $stdin;
}

sub sni(@) {
  my @args = @_;
  soproc {exec_ni @args};
}
