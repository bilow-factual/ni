Pipeline construction.
A way to build a shell pipeline in-process by consing a transformation onto
this process's standard input. This will cause a fork to happen, and the forked
PID is returned.

I define some system functions with a `c` prefix: these are checked system
calls that will die with a helpful message if anything fails.

use Errno qw/EINTR/;
use POSIX qw/dup2/;

sub cdup2 {dup2 @_ or die "ni: dup2(@_) failed: $!"}
sub cpipe {pipe $_[0], $_[1] or die "ni: pipe failed: $!"}
sub cfork {my $pid = fork; die "ni: fork failed: $!" unless defined $pid; $pid}

sub move_fd($$) {
  my ($old, $new) = @_;
  return if $old == $new;
  close $new;
  cdup2 $old, $new;
  close $old;
}

sub sh($) {exec 'sh', '-c', $_[0]}

Safe reads/writes.
This is required because older versions of Perl don't automatically retry
interrupted reads/writes. We run the risk of interruption because we have a
SIGCHLD handler. nfu lost data on older versions of Perl because it failed to
handle this case properly.

sub saferead($$$;$) {
  my $n;
  do {
    return $n if defined($n = sysread $_[0], $_[1], $_[2], $_[3]);
  } while $!{EINTR};
  return undef;
}

sub safewrite($$) {
  my $n;
  do {
    return $n if defined($n = syswrite $_[0], $_[1]);
  } while $!{EINTR};
  return undef;
}

Process construction.
A few functions, depending on what you want to do:

| siproc(&): fork into block, return pipe FH to block's STDIN.
  soproc(&): fork into block, return pipe FH from block's STDOUT.
  sicons(&): fork into block, connect its STDOUT to our STDIN.
  socons(&): fork into block, connect our STDOUT to its STDIN.

NOTE: forkopen does something strange and noteworthy. You'll notice that it's
reopening STDIN and STDOUT from FDs, which seems redundant. This is required
because Perl filehandles aren't the same as OS-level file descriptors, and ni
deals with both in different ways.

In particular, ni closes STDIN (the filehandle) if the input comes from a
terminal, since presumably the user doesn't intend to type their input in
manually. This needs to happen before any exec() from a forked filter process.
But this creates a problem: if we later reactivate fd 0, which we do by moving
file descriptors from a pipe. We have to do this at the fd level so exec()
works correctly (since exec doesn't know anything about Perl filehandles, just
fds). Anyway, despite the fact that fd 0 is newly activated by an sicons {}
operation, Perl's STDIN filehandle will think it's closed and return no data.

So that's why we do these redundant open STDIN and STDOUT operations. At some
point I might bypass Perl's IO layer altogether and use POSIX calls, but at the
moment that seems like more trouble than it's worth.

sub forkopen($$) {
  my ($fd, $f) = @_;
  cpipe my $r, my $w;
  my ($ret, $child) = ($r, $w)[$fd ^ 1, $fd];
  my $pid;
  if ($pid = cfork) {
    close $child;
    return ni::procfh->new($ret, $pid);
  } else {
    close $ret;
    move_fd fileno $child, $fd;
    open STDIN,  '<&=0' if $fd == 0;
    open STDOUT, '>&=1' if $fd == 1;
    &$f;
    exit;
  }
}

sub sioproc(&) {
  my ($f) = @_;
  cpipe my $proc_in, my $w;
  cpipe my $r, my $proc_out;
  my $pid;
  if ($pid = cfork) {
    close $proc_in;
    close $proc_out;
    return ($w, ni::procfh->new($r, $pid));
  } else {
    close $w;
    close $r;
    move_fd fileno $proc_in, 0;
    move_fd fileno $proc_out, 1;
    open STDIN,  '<&=0';
    open STDOUT, '>&=1';
    &$f;
    exit;
  }
}

sub siproc(&) {forkopen 0, $_[0]}
sub soproc(&) {forkopen 1, $_[0]}

sub sicons(&) {
  my ($f) = @_;
  my $fh = soproc {&$f};
  move_fd fileno $fh, 0;
  open STDIN, '<&=0';
  $fh;
}

sub socons(&) {
  my ($f) = @_;
  my $fh = siproc {&$f};
  move_fd fileno $fh, 1;
  open STDOUT, '>&=1';
  $fh;
}

Stream functions.
These are called by pipelines to simplify things. For example, a common
operation is to append the output of some data-producing command:

| $ ni . .              # lists current directory twice

If you do this, ni will create a pipeline that uses stream wrappers to
concatenate the second `ls` output (despite the fact that technically it's a
shell pipe).

sub sforward($$) {local $_; safewrite $_[1], $_ while saferead $_[0], $_, 8192}
sub stee($$$)    {local $_; safewrite($_[1], $_), safewrite($_[2], $_) while saferead $_[0], $_, 8192}
sub sio()        {sforward \*STDIN, \*STDOUT}

sub srfile($) {open my $fh, '<', $_[0] or die "ni: srfile $_[0]: $!"; $fh}
sub swfile($) {open my $fh, '>', $_[0] or die "ni: swfile $_[0]: $!"; $fh}

Compressed stream support.
This provides a stdin filter you can use to read the contents of a compressed
stream as though it weren't compressed. It's implemented as a filter process so
we don't need to rely on file extensions.

We detect the following file formats:

| gzip:  1f 8b
  bzip2: BZh\0
  lzo:   89 4c 5a 4f
  lz4:   04 22 4d 18
  xz:    fd 37 7a 58 5a

Decoding works by reading enough to decode the magic, then forwarding data
into the appropriate decoding process (or doing nothing if we don't know what
the data is).

sub sdecode(;$) {
  local $_;
  return unless saferead \*STDIN, $_, 8192;

  my $decoder = /^\x1f\x8b/             ? "gzip -dc"
              : /^BZh\0/                ? "bzip2 -dc"
              : /^\x89\x4c\x5a\x4f/     ? "lzop -dc"
              : /^\x04\x22\x4d\x18/     ? "lz4 -dc"
              : /^\xfd\x37\x7a\x58\x5a/ ? "xz -dc" : undef;

  if (defined $decoder) {
    my $o = siproc {sh $decoder};
    safewrite $o, $_;
    sforward \*STDIN, $o;
    close $o;
    $o->await;
  } else {
    safewrite \*STDOUT, $_;
    sio;
  }
}

File/directory cat.
cat exists to turn filesystem objects into text. Files are emitted and
directories are turned into readable listings. Files are automatically
decompressed.

sub scat {
  local $| = 1;
  for my $f (@_) {
    if (-d $f) {
      opendir my $d, $f or die "ni_cat: failed to opendir $f: $!";
      print "$f/$_\n" for sort grep !/^\.\.?$/, readdir $d;
      closedir $d;
    } else {
      my $d = siproc {sdecode};
      sforward srfile $f, $d;
      close $d->fh;
      $d->await;
    }
  }
}

Self invocation.
You can run ni and read from the resulting file descriptor; this gives you a
way to evaluate lambda expressions (this is how checkpoints work, for example).
If you do this, ni's standard input will come from a continuation of __DATA__.

defclispecial '--internal/operate', q{
  my ($k) = @_;
  my $fh = siproc {&$main_operator(flatten_operators json_decode($self{$k}))};
  print $fh $_ while <$data>;
  close $fh;
  $fh->await;
};

sub sni_exec_list(@) {
  my $stdin = image_with 'transient/op' => json_encode([@_]);
  ($stdin, qw|perl - --internal/operate transient/op|);
}

sub exec_ni(@) {
  my ($stdin, @argv) = sni_exec_list @_;
  my $fh = siproc {exec @argv};
  safewrite $fh, $stdin;
  sforward \*STDIN, $fh;
  close $fh;
  exit $fh->await;
}

sub sni(@) {
  my @args = @_;
  soproc {close STDIN; close 0; exec_ni @args};
}
