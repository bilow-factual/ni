Process + filehandle combination.
We can't use Perl's process-aware FHs because they block-wait for the process
on close. There are some situations where we care about the exit code and
others where we don't, and this class supports both cases.

package ni::procfh;

use strict;
use warnings;
use POSIX qw/:sys_wait_h/;

Global child collector.
Collect children regardless of whether anyone is listening for them. If we have
an interested party, notify them.

our %child_owners;

sub await_children {
  local ($!, $?, $_);
  while (0 < ($_ = waitpid -1, WNOHANG)) {
    $child_owners{$_}->child_exited($?) if defined $child_owners{$_};
  }
  $SIG{CHLD} = \&await_children;
};
$SIG{CHLD} = \&await_children;

Proc-filehandle class.
Overloading *{} makes it possible for this to act like a real filehandle in
every sense: fileno() works, syswrite() works, etc. The constructor takes care
of numeric fds by promoting them into Perl fh references.

use overload qw/*{} fh "" str/;
sub new($$$) {
  my ($class, $fd, $pid) = @_;
  my $fh = ref($fd) ? $fd : undef;
  open $fh, "<&=$fd" or die "ni: procfh($fd, $pid) failed: $!"
    unless defined $fh;
  $child_owners{$pid} = bless {fh => $fh, pid => $pid, status => undef}, $class;
}

sub DESTROY   {
  my ($self) = @_;
  delete $child_owners{$$self{pid}} unless defined $$self{status};
}

sub fh($)     {my ($self) = @_; $$self{fh}}
sub pid($)    {my ($self) = @_; $$self{pid}}
sub status($) {my ($self) = @_; $$self{status}}

sub kill($$) {
  my ($self, $sig) = @_;
  kill $$self{pid}, $sig unless defined $$self{status};
}

sub str($)
{ my ($self) = @_;
  sprintf "<fd %d, pid %d, status %s>",
          fileno $$self{fh}, $$self{pid}, $$self{status} || 'none' }

Child await.
We have to stop the SIGCHLD handler while we wait for the child in question.
Otherwise we run the risk of waitpid() blocking forever or catching the wrong
process. This ends up being fine because this process can't create more
children while waitpid() is waiting, so we might have some resource delays but
we won't have a leak.

We also don't have to worry about multithreading: only one await() call can
happen per process.

sub await($) {
  local ($?, $!, $SIG{CHLD});
  my ($self) = @_;
  return $$self{status} if defined $$self{status};
  $SIG{CHLD} = 'IGNORE';
  return $$self{status} if defined $$self{status};
  my $pid = waitpid $$self{pid}, 0;
  $self->child_exited($pid <= 0 ? "-1 [waitpid: $!]" : $?);
  $$self{status};
}

sub child_exited($$) {
  my ($self, $status) = @_;
  $$self{status} = $status;
  delete $child_owners{$$self{pid}};
}
