Perl parse element.
A way to figure out where some Perl code ends, in most cases. This works
because appending closing brackets to valid Perl code will always make it
invalid. The same property holds across most code-to-code functions. This is
how ni figures out whether a closing bracket is a lambda-terminator or a part
of some row mapping code.

sub syntax_check($$) {
  my ($check_cmd, $code) = @_;
  my $fh = siproc {sh "$check_cmd >/dev/null 2>&1"};
  safewrite $fh, $code;
  close $fh;
  $fh->await;
}

We need to explicitly disable any BEGIN{} blocks to avoid executing side
effects. We can guarantee that nothing will run (beyond `use` statements, which
we assume are safe) by removing any occurrences of the string `BEGIN` and
replacing them with something syntactically equivalent but less volatile -- in
this case, `END`.

c
BEGIN {
defparser 'plcode', '$', sub {
  return $_[1], '', @_[2..$#_] unless $_[1] =~ /\]$/;
  my ($self, $code, @xs) = @_;
  my $safecode      = $code;
  my $begin_warning = $safecode =~ s/BEGIN/ END /g;
  my $codegen       = $$self[1];
  my $status        = 0;
  my $x             = '';
  $x .= ']' while $status = syntax_check 'perl -c -', &$codegen($safecode)
                  and ($safecode =~ s/\]$//, $code =~ s/\]$//);

  die <<EOF if $status;
ni: failed to get closing bracket count for perl code "$code$x", possibly
    because BEGIN-block metaprogramming is disabled when ni tries to figure
    this out. To avoid this, make sure the shell argument containing your code
    ends with something that isn't a closing bracket; e.g:

    p'[[some code]]'            # this may fail due to bracket inference
    p'[[some code]] '           # this works by bypassing it
    [p'[some code] ' ]          # this works for ni lambdas
EOF

  ($code, $x, @xs);
};
}

Perl wrapper.
Defines the `p` operator, which can be modified in a few different ways to do
different things. By default it functions as a one-in, many-out row
transformer.

sub perl_crunch_empty($) {sr $_[0], qr/#$/, "#\n;()"}

use constant perl_mapgen => gen q{
  package ni::pl;
  %prefix
  close STDIN;
  open STDIN, '<&=3' or die "ni: failed to open fd 3: $!";
  $|++;
  sub row {
    %body
  }
  while (defined rl) {
    %each
  }
};

our @perl_prefix_keys = qw| core/pl/util.pm
                            core/pl/math.pm
                            core/pl/stream.pm
                            core/pl/geohash.pm
                            core/gen/gen.pl
                            core/json/json.pl
                            core/pl/reducers.pm |;

sub defperlprefix($) {push @perl_prefix_keys, $_[0]}

sub perl_prefix() {join "\n", @self{@perl_prefix_keys}}

sub stdin_to_perl($) {
  eval {move_fd 0, 3};
  die "ni: perl driver failed to move FD 0 to 3 ($!)\n"
    . "    this usually means you're running in a context with no STDIN"
  if $@;
  safewrite siproc {exec 'perl', '-'}, $_[0];
}

sub perl_code($$) {perl_mapgen->(prefix => perl_prefix,
                                 body   => $_[0],
                                 each   => $_[1])}

sub perl_mapper($)  {perl_code perl_crunch_empty $_[0], 'ref $_ ? r(@$_) : print $_ . "\n" for row'}
sub perl_grepper($) {perl_code                   $_[0], 'print $_ . "\n" if row'}

defoperator perl_mapper  => q{stdin_to_perl perl_mapper  $_[0]};
defoperator perl_grepper => q{stdin_to_perl perl_grepper $_[0]};

defshort '/p',
  defalt 'perlalt', 'alternatives for /p perl operator',
    pmap q{perl_mapper_op $_}, pplcode \&perl_mapper;

defrowalt pmap q{perl_grepper_op $_},
          pn 1, prx 'p', pplcode \&perl_grepper;
