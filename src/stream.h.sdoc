Stream abstraction and operations.
A stream is just a series of bytes with type information attached to it; the
type information makes it possible to interpret the bytes as more complex
values. Ultimately streams and UNIX file descriptors are convertible, although
for optimization reasons not all streams have file descriptors. Streams are
typically buffered so ni can use nonblocking IO.

#include <sys/types.h>
#include <stdbool.h>
#include <stdint.h>

Packets and buffers.
Let's take the simple case of reading stuff from a file. We don't know what's
in the file yet, so we're just reading binary data. Someone wanting the data
needs to specify some strategy for splitting it into "packets", or units of
data that should be handed off to things like row-mapping operations. For this
example let's assume the file needs to be split at 192-byte boundaries.

Here's how a read is going to work. We start with a ni_stream backed by the
file and ask it for a ni_stream_packet 192 bytes long. We can do this by
constructing a codec describing what we're looking for:

| ni_codec        *codec = ni_compile_codec("C192!*");
  ni_stream       *fs    = ...;                 // stream backed by a file
  ni_stream_packet p[64];
  int n = ni_stream_read(fs, codec, p, 64, NI_READ_DEFAULT);

Ni will do some interesting things here, most of them centered around
eliminating data copies. It knows that each packet will consume exactly 192
bytes of data from the stream and that it can construct up to 64 of them, so
its target buffer size is 12288 bytes. This is trivial if the last read
produced an even multiple of 192 bytes, but that might not be the case; for
example, if the last read produced 256 bytes and we generated one packet, then
we have 64 bytes left over.

#define NI_PACKET_FIELDOFFSET_CACHE 16

typedef struct ni_stream_packet {
  ni_codec const *codec;
  char const     *data1;
  char const     *data2;
  size_t          data1_size;
  size_t          data2_size;
} ni_stream_packet;

void   ni_packet_init(ni_stream_packet       *p);
void   ni_packet_free(ni_stream_packet       *p);
size_t ni_packet_size(ni_stream_packet const *p);

int                ni_packet_fields(ni_stream_packet const *p);
ni_codec_fieldspec ni_packet_field (ni_stream_packet const *p, int f);

Stream structure.
Streams have read buffers. These read buffers are automatically resized to
contain enough data; for example, if you're scanning for newlines and get a
long line, the stream will keep expanding the buffer until you consume the
data. I'll describe buffer operations in a moment to make this clearer.

Custom errno flags.
This deserves a little discussion. C99 specifies that all system-returned
values of errno are positive, so we've got the entire space of negative numbers
to work with. This is great because some things that ni considers to be errors
(like EOF) don't correspond to system call error conditions. Instead, UNIX does
weird things like reading zero bytes and expecting you to figure out that
you've hit EOF.

#define NI_ERRNO_EOF (-1)

#define NI_STREAM_QUEUE_SIZE 64

Stream queues are array minheaps of record addresses. We always take the
minimum because streams are forward-only; see the codec documentation for
details about where queue elements come from. Note that the queue is preserved
between calls to ni_stream_read(), which means that if you change codecs
between calls you'll inherit old queue entries. It's up to you whether you want
to do this, but it may not do what you expect.

Invariant: read_offset is a lower bound of the (circularly-unwrapped) memory
referred to by any valid packet during the scope of a ni_stream_read() call.
This prevents the stream from creating a packet, deciding it needs to read more
stuff, and then overwriting the memory that packet refers to in the same
ni_stream_read() call. After the ni_stream_read() call, read_offset contains
the next enqueued address or one greater than the last record if none was
enqueued.

TODO: figure out exact details of how codecs enqueue addresses

typedef struct ni_stream {
  int      read_errno;
  int      fd;
  char    *buffer;
  int      buffer_capacity_log;
  off_t    read_offset;
  off_t    fill_offset;
  uint64_t ms;
  off_t    queue[NI_STREAM_QUEUE_SIZE];
} ni_stream;

void   ni_stream_init              (ni_stream       *s);
void   ni_stream_free              (ni_stream       *s);
bool   ni_stream_resize_buffer     (ni_stream       *s, int log);
bool   ni_stream_issplit           (ni_stream const *s);
void   ni_stream_accept            (ni_stream       *s, size_t n);
size_t ni_stream_available         (ni_stream const *s);
size_t ni_stream_remaining_capacity(ni_stream const *s);
void   ni_stream_copy_into         (char            *dest,
                                    ni_stream const *s,
                                    off_t            offset,
                                    size_t           n);

bool   ni_stream_eof (ni_stream const *s);
size_t ni_stream_fill(ni_stream *s, size_t n);

ni_stream *ni_fd_stream(int fd);

size_t ni_stream_initial_buffersize_log = 16;
size_t ni_stream_max_buffersize_log     = 20 + 6;

Reading from streams.
Streams are decoded into lists of packets, each of which corresponds to a
record cut made by a codec. Streams try to be state-transparent, which is to
say that they automatically load more data from the underlying fd unless you
specify not to using NI_READ_NOLOAD.

The return value is either the number of complete packets read, or one of the
following:

#define NI_READ_ERROR             (-1)
#define NI_READ_INCOMPLETE_AT_EOF (-2)
#define NI_READ_MUST_LOAD         (-3)

If an error is returned, no packets were read or modified. Flags:

#define NI_READ_DEFAULT 0
#define NI_READ_NOLOAD  1

NB: calling this function invalidates all packets previously generated from
this stream. You should reuse packet arrays unless you just like to allocate
stuff.

NB: due to stream queueing subtleties, packets may contain overlapping data.
This won't make any difference in most cases because you should treat packet
data as constant (as its type signature implies).

int ni_stream_read(ni_stream        *s,
                   ni_codec const   *c,
                   ni_stream_packet *ps,
                   int               nps,
                   int               flags);
