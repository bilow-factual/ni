Stream abstraction.
Streams consume and/or emit bytes and express a preference about the format(s)
they work with. They also support EOF, which is used both to signal the end of
input and within constructs like aggregation.

#include <sys/types.h>

typedef enum ni_stream_type
{
  NI_STREAM_UNKNOWN,
  NI_STREAM_TSV,
  NI_STREAM_BINARY,
  NI_STREAM_GZIP,
  NI_STREAM_BZIP2,
  NI_STREAM_AR,
  NI_STREAM_LZO,
  NI_STREAM_LZMA,
  NI_STREAM_SNAPPY,
  NI_STREAM_PKZIP,
  NI_STREAM_TAR,
  NI_STREAM_XZ,
} ni_stream_type;

struct ni_stream;
typedef struct ni_stream_ops
{
  ssize_t        (*read) (struct ni_stream *s, void *buf, size_t n);
  ssize_t        (*write)(struct ni_stream *s, void const *buf, size_t n);
  void           (*close)(struct ni_stream *s);
  ni_stream_type (*inferred_type)(struct ni_stream const *s);
} ni_stream_ops;

The read() and write() functions don't block. Each either returns 0 to indicate
temporary unavailability, positive to indicate that N bytes were read/written,
or one of the following negative values to indicate an error. errno is always
preserved.

#define NI_READ_EOF     (-1)
#define NI_READ_EIO     (-2)
#define NI_READ_ERRNO   (-3)
#define NI_READ_EPROC   (-4)

#define NI_WRITE_EPIPE  (-1)
#define NI_WRITE_ENOSPC (-2)
#define NI_WRITE_EIO    (-3)
#define NI_WRITE_ERRNO  (-4)
#define NI_WRITE_EPROC  (-5)

Some codes above worth noting are EPROC, which means the connected process
exited with a nonzero code, and EOF, which indicates that no further bytes will
ever be available for reading from the stream. EOF is by definition a stable
condition.

The stream structure below defines some shared fields to make it possible for a
scheduler to quickly collect the file descriptors of all active streams and
issue a single select() call. If either fd is unopened or not meaningful, it
will be set to -1.

typedef struct ni_stream
{
  ni_stream_ops const *ops;
  int                  read_fd;
  int                  write_fd;
  void                *opaque_state;
} ni_stream;

Shorthand methods.
These are provided to bypass the notational overhead imposed by ->ops
polymorphism.

inline ssize_t ni_stream_read(ni_stream *const s,
                              void      *const buf,
                              size_t     const n)
  { return (*s->ops->read)(s, buf, n); }

inline ssize_t ni_stream_write(ni_stream  *const s,
                               void const *const buf,
                               size_t      const n)
  { return (*s->ops->write)(s, buf, n); }

inline void ni_stream_close(ni_stream *const s)
  { return (*s->ops->close)(s); }

inline ni_stream_type ni_stream_inferred_type(ni_stream const *const s)
  { return (*s->ops->inferred_type)(s); }
