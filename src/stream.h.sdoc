Stream abstraction and operations.
A stream is just a series of bytes with type information attached to it; the
type information makes it possible to interpret the bytes as more complex
values. Ultimately streams and UNIX file descriptors are convertible, although
for optimization reasons not all streams have file descriptors. Streams are
typically buffered so ni can use nonblocking IO.

#include <sys/types.h>
#include <stdbool.h>
#include <stdint.h>

Packets and buffers.
Let's take the simple case of reading stuff from a file. We don't know what's
in the file yet, so we're just reading binary data. Someone wanting the data
needs to specify some strategy for splitting it into "packets", or units of
data that should be handed off to things like row-mapping operations. For this
example let's assume the file needs to be split at 192-byte boundaries.

Here's how a read is going to work. We start with a ni_stream backed by the
file and ask it for a ni_stream_packet 192 bytes long. We can do this by
constructing a codec describing what we're looking for:

| ni_codec        *codec = ni_compile_codec("C192!*");
  ni_stream       *fs    = ...;                 // stream backed by a file
  ni_stream_packet p[64];
  int n = ni_stream_read(fs, codec, p, 64, NI_READ_DEFAULT);

Ni will do some interesting things here, most of them centered around
eliminating data copies. It knows that each packet will consume exactly 192
bytes of data from the stream and that it can construct up to 64 of them, so
its target buffer size is 12288 bytes. This is trivial if the last read
produced an even multiple of 192 bytes, but that might not be the case; for
example, if the last read produced 256 bytes and we generated one packet, then
we have 64 bytes left over.

This is where ni does some math to figure out what to do next. Moving 64 bytes
isn't expensive, so depending on where they're located it may decide to just do
that. On the other hand, if we have 480 bytes left over and they're at position
128, it's probably cheaper to just continue filling the buffer and lose the 128
bytes until the pointer can be reset.

typedef struct {
  ni_codec const *codec;
  char const     *data1;
  char const     *data2;
  size_t          data1_size;
  size_t          data2_size;

  // TODO: field stuff
} ni_stream_packet;

void        ni_packet_init       (ni_stream_packet       *p);
void        ni_packet_free       (ni_stream_packet       *p);
size_t      ni_packet_size       (ni_stream_packet const *p);
char const *ni_packet_field_data1(ni_stream_packet       *p, int field);
char const *ni_packet_field_data2(ni_stream_packet       *p, int field);
size_t      ni_packet_field_size (ni_stream_packet       *p, int field);

Stream structure.
A stream is fundamentally described by the following:

| errno: the failure mode of the last failed read/write request; if EOF on
         read, this will be set to NI_ERRNO_EOF.
  fd:    the backing FD, if there is one (otherwise -1)

Streams also have read buffers. These read buffers are automatically resized to
contain enough data; for example, if you're scanning for newlines and get a
long line, the stream will keep expanding the buffer until you consume the
data. I'll describe buffer operations in a moment to make this clearer.

Custom errno flags.
This deserves a little discussion. C99 specifies that all system-returned
values of errno are positive, so we've got the entire space of negative numbers
to work with. This is great because some things that ni considers to be errors
(like EOF) don't correspond to system call error conditions. Instead, UNIX does
weird things like reading zero bytes and expecting you to figure out that
you've hit EOF.

#define NI_ERRNO_EOF (-1)

typedef struct {
  int      read_errno;
  int      fd;
  char    *buffer;
  int      buffer_capacity_log;
  off_t    read_offset;
  off_t    fill_offset;
  off_t    bytes;
  uint64_t ms;
} ni_stream;

void   ni_stream_init              (ni_stream       *s);
void   ni_stream_free              (ni_stream       *s);
bool   ni_stream_resize_buffer     (ni_stream       *s, int log);
bool   ni_stream_issplit           (ni_stream const *s);
void   ni_stream_accept            (ni_stream       *s, size_t n);
size_t ni_stream_available         (ni_stream const *s);
size_t ni_stream_remaining_capacity(ni_stream const *s);
void   ni_stream_copy_into         (char            *dest,
                                    ni_stream const *s,
                                    off_t            offset,
                                    size_t           n);

bool   ni_stream_eof (ni_stream const *s);
size_t ni_stream_fill(ni_stream *s, size_t n);

ni_stream *ni_fd_stream(int fd);

size_t ni_stream_initial_buffersize_log = 16;
size_t ni_stream_max_buffersize         = 20 + 6;

Reading from streams.
Streams are decoded into lists of packets, each of which corresponds to a
record cut made by a codec. Streams try to be state-transparent, which is to
say that they automatically load more data from the underlying fd unless you
specify not to using NI_READ_NOLOAD.

The return value is either the number of complete packets read, or one of the
following:

#define NI_READ_ERROR             (-1)
#define NI_READ_INCOMPLETE_AT_EOF (-2)
#define NI_READ_MUST_LOAD         (-3)

Flags:

#define NI_READ_DEFAULT 0
#define NI_READ_NOLOAD  1

NB: calling this function invalidates all packets you've ever generated from
this stream.

int ni_stream_read(ni_stream        *s,
                   ni_codec const   *c,
                   ni_stream_packet *ps,
                   int               nps,
                   int               flags);
