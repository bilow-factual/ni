CLI entry point.
Some custom toplevel option handlers and the main function that ni uses to
parse CLI options and execute the data pipeline.

our %cli_special;
sub defclispecial($$) {$cli_special{$_[0]} = fn $_[1]}

Development options.
Things useful for developing ni.

defclispecial '--dev/eval', q{print ni::eval($_[0], "anon $_[0]"), "\n"};
defclispecial '--dev/parse', q{
  dev_trace 'ni::parse';
  parse pcli '', @_;
};

defclispecial '--dev/parse-one', q{
  dev_trace 'ni::parse';
  parse ni::eval($_[0]), @_[1..$#_];
};

Extensions.
Options to extend and modify the ni image.

defclispecial '--internal/lib', q{extend_self 'lib', $_[0]};
defclispecial '--lib', q{intern_lib shift; goto \&main};

Internal interfacing.
Functions used by ni internally.

defclispecial '--internal/operate', q{
  &$main_operator(flatten_operators json_decode($self{$_[0]}));
};

Documentation.

defclispecial '--explain', q{
  my ($r) = parse pcli '', @_;
  print json_encode($_), "\n" for @$r;
};

Root CLI context.
This is used by extensions that define long and short options.

defcontext '';

Main stuff.
sub main() is called by the ni boot header on @ARGV. I've separated
$main_operator so it can be extended to handle various cases; for instance, ni
launches a pager when its output is connected to a terminal, etc. This is
handled by core/stream.

our $main_operator = sub {operate @$_ for @_};

sub main {
  my ($cmd, @args) = @_;
  return $cli_special{$cmd}->(@args) if exists $cli_special{$cmd};

  @_ = ('//help')
    if -t STDIN and -t STDOUT and !@_ || $_[0] =~ /^-h$|^-\?$|^--help$/;

  my ($r) = cli @_;
  return &$main_operator(flatten_operators $r) if ref $r;

  my (undef, @rest) = parse pcli_debug '', @_;
  print STDERR "ni: failed to parse starting here (ni --dev/parse to trace):\n";
  print STDERR "  @rest\n";
  exit 1;
}
