Main function.
ni can be invoked as a stream processor, but it can also do some toplevel
things besides. This main function knows how to handle these cases.

package ni;

use constant exit_success      => 0;
use constant exit_run_error    => 1;
use constant exit_nop          => 2;
use constant exit_sigchld_fail => 3;

our %option_handlers;

our @pipeline_prefix = sh 'true';
our @pipeline_suffix = ();

sub parse_ops {
  return () unless @_;
  my ($parsed) = cli->(@_);
  return @$parsed if ref $parsed && @$parsed;
  my (undef, @rest) = cli_d->(@_);
  die "failed to parse " . join ' ', @rest;
}

sub sh_code {pipeline @pipeline_prefix, parse_ops(@_), @pipeline_suffix}

sub run_sh {
  open SH, '| sh'   or
  open SH, '| ash'  or
  open SH, '| dash' or
  open SH, '| bash' or die "ni: could not run any POSIX sh: $!";

  syswrite SH, $_[0]
    or die "ni: could not write compiled pipeline to shell process: $!";

  unless (-t STDIN) {
    syswrite SH, $_ while sysread STDIN, $_, 8192;
  }
  close STDIN;
  close SH;
  0;
}

Internal and debugging options.
A handful of things useful for ni development. These are also present in the
final image.

$option_handlers{'internal/eval'}
  = sub {eval "package ni; $_[0]"; die $@ if $@; exit_success};

$option_handlers{'internal/lib'}
  = sub {intern_lib $_[0]; $self{'ni.map'} .= "\nlib $_[0]";
         modify_self 'ni.map'};

Documentation options.
Options for the end user that can't otherwise be parsed as pipelines.

$option_handlers{usage} = sub {print $help_topics{usage}, "\n"; exit_nop};
$option_handlers{help}
  = sub {print $help_topics{@_ ? $_[0] : 'ni'}, "\n"; exit_nop};

$option_handlers{explain} = sub {TODO()};
$option_handlers{compile} = sub {print sh_code @_; exit_nop};

sub main {
  my ($command, @args) = @ARGV;
  $command = '--help' if $command eq '-h';
  my $h = $command =~ s/^--// && $option_handlers{$command};
  return &$h(@args) if $h;
  run_sh sh_code @ARGV;
}
