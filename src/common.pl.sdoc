Regex parsing.
Sometimes we'll have an operator that takes a regex, which is subject to the
CLI reader problem the same way code arguments are. Rather than try to infer
brackets the same way, we just require that regexes are terminated with /
(which should be ok because that's also how they typically start).

c
BEGIN {defparseralias regex => pmap q{s/\/$//; $_}, prx qr{^(?:[^\\/]+|\\.)*/}}

Generic code parser.
Counts brackets outside quoted strings, which in our case are '' and "".
Doesn't look for regular expressions because these vary by language; but this
parser should be able to handle most straightforward languages with quoted
string literals and backslash escapes.

defparser 'generic_code', '',
  sub {my ($self, $code, @xs) = @_;
       return ($code, '', @xs) unless $code =~ /\]$/;
       (my $tcode = $code) =~ s/"([^"\\]+|\\.)"|'([^'\\]+|\\.)'//g;
       my $balance = length(sgr $tcode, qr/[^[]/, '') - length(sgr $tcode, qr/[^]]/, '');
       $balance ? (substr($code, 0, $balance), substr($code, $balance), @xs)
                : ($code, '', @xs)};

Basic CLI types.
Some common argument formats for various commands, sometimes transformed for
specific cases. These are documented somewhere in `doc/`.

A parsed column spec is an N-element array: [floor, cols...]. `floor` indicates
the first column that would be selected by a `.` ("the rest").

use constant neval   => pmap q{eval}, prx '=([^]=]+)';
use constant integer => palt pmap(q{int},       neval),
                             pmap(q{10 ** $_},  prx 'E(-?\d+)'),
                             pmap(q{1 << $_},   prx 'B(\d+)'),
                             pmap(q{0 + "0$_"}, prx 'x[0-9a-fA-F]+'),
                             pmap(q{0 + $_},    prx '[1-9]\d*(?:[eE]\d+)?');
use constant float   => pmap q{0 + $_},
                        pcond q{length}, prx '-?\d*(?:\.\d+)?(?:[eE][-+]?\d+)?';
use constant number  => palt neval, integer, float;

use constant colspec1      => pmap q{ord() - 65}, prx '[A-Z]';
use constant colspec_rest  => pmap q{-1}, prx '\.';
use constant colspec_range => pmap q{[$$_[0] .. $$_[2]]},
                              pseq colspec1, prx '-', colspec1;

use constant colspec_fixed => pmap q{[max(@$_) + 1, @$_]},
                              pmap q{[map ref() ? @$_ : $_, @$_]},
                              prep palt(colspec_range, colspec1), 1;

use constant colspec => pmap q{[max(@$_) + 1, @$_]},
                        pmap q{[map ref() ? @$_ : $_, @$_]},
                        prep palt(colspec_range, colspec1, colspec_rest), 1;

Filenames, in general.
Typically filenames won't include bracket characters, though they might include
just about everything else. Two possibilities there: if we need special stuff,
there's the `file:` prefix; otherwise we assume the non-bracket interpretation.

use constant tmpdir   => dor $ENV{TMPDIR}, '/tmp';
use constant tempfile => pmap q{tmpdir . "/ni-$<-$_"}, prx '@:(\w*)';
use constant filename => palt prx 'file:(.+)',
                              prx '\.?/(?:[^/]|$)[^]]*',
                              tempfile,
                              pcond q{-e}, prx '[^][]+';

use constant nefilename => palt filename, prx '[^][]+';
