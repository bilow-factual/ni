Regex parsing.
Sometimes we'll have an operator that takes a regex, which is subject to the
CLI reader problem the same way code arguments are. Rather than try to infer
brackets the same way, we just require that regexes are terminated with /
(which should be ok because that's also how they typically start).

use constant regex => pmap q{s/\/$//; $_}, prx qr{^(?:[^\\/]+|\\.)*/};

Generic code parser.
Counts brackets outside quoted strings, which in our case are '' and "".
Doesn't look for regular expressions because these vary by language; but this
parser should be able to handle most straightforward languages with quoted
string literals and backslash escapes.

defparser 'generic_code', '',
  sub {my ($self, $code, @xs) = @_;
       return ($code, @xs) unless $code =~ /\]$/;
       (my $tcode = $code) =~ s/"([^"\\]+|\\.)"|'([^'\\]+|\\.)'//g;
       my $balance = length(sgr $tcode, qr/[^[]/, '') - length(sgr $tcode, qr/[^]]/, '');
       $balance ? (substr($code, 0, $balance), substr($code, $balance))
                : ($code, @xs)};

Code parsing.
This is nontrivial due to the CLI reader problem. The idea is that we need to
figure out how many closing brackets belong to the code, vs how many close a
lambda. Depending on the language, the only way to do this may be to shell out
to an interpreter.

defparser 'rbcode', '',
  sub {return @_[1..$#_] unless $_[1] =~ /\]$/;
       my ($self, $code, @xs, $x, $qcode) = @_;
       ($qcode = $code) =~ s/'/'\\''/g;
       $x .= ']' while $_ = system("ruby -ce '$qcode' >/dev/null 2>&1")
                       and ($qcode =~ s/\]$//, $code =~ s/\]$//);
       $_ ? () : length $x ? ($code, $x, @xs) : ($code, @xs)};

Perl code is similar to Ruby, but we need to explicitly disable any BEGIN{}
blocks to avoid executing side effects. We can guarantee that nothing will run
(beyond `use` statements, which we assume are safe) by removing any
occurrences of the string `BEGIN` and replacing them with something
syntactically equivalent but less volatile -- in this case, `END`.

defparser 'plcode', '',
  sub {return @_[1..$#_] unless $_[0] =~ /\]$/;
       my ($self, $code, @xs, $x, $qcode) = @_;
       ($qcode = $code) =~ s/'/'\\''/g;

       my $begin_warning = $qcode =~ s/BEGIN/END/g;
       $x .= ']' while $_ = system("perl -ce '$qcode' >/dev/null 2>&1")
                       and ($qcode =~ s/\]$//, $code =~ s/\]$//);

       print STDERR <<EOF if $_ && $begin_warning;
ni: failed to get closing bracket count for perl code "$_[0]", possibly
    because BEGIN-block metaprogramming is disabled when ni tries to figure
    this out. To avoid this, bypass bracket inference by terminating your code
    with a single space, e.g:

    p'[[some code]]'            # this fails due to bracket inference
    p'[[some code]] '           # this works by bypassing it
EOF
       $_ ? () : length $x ? ($code, $x, @xs) : ($code, @xs)};

Basic CLI types.
Some common argument formats for various commands, sometimes transformed for
specific cases. These are documented somewhere in `doc/`.

use constant neval   => pmap q{eval}, prx '=([^]]+)';
use constant integer => palt pmap(q{int},       neval),
                             pmap(q{10 ** $_},  prx 'E(-?\d+)'),
                             pmap(q{1 << $_},   prx 'B(\d+)'),
                             pmap(q{0 + "0$_"}, prx 'x[0-9a-fA-F]+'),
                             pmap(q{0 + $_},    prx '\d+');
use constant float   => pmap q{0 + $_}, prx '-?\d*(?:\.\d+)?(?:[eE][-+]?\d+)?';
use constant number  => palt neval, integer, float;

use constant colspec1 => prx '[A-Z]';
use constant colspec  => prx '[-A-Z.]+';

Filenames, in general.
Typically filenames won't include bracket characters, though they might include
just about everything else. Two possibilities there: if we need special stuff,
there's the `file:` prefix; otherwise we assume the non-bracket interpretation.

use constant tmpdir   => dor $ENV{TMPDIR}, '/tmp';
use constant tempfile => pmap q{tmpdir . "/ni-$$-$_"}, prx '^@(\w*)';

use constant filename => palt prc '^file:(.+)', tempfile,
                              pcond q{-e}, prx '^[^][]+';
