POSIX shell command generation.
ni stream operators end up being compiled down to POSIX shell commands and
piped into a shell process. This way you can compile a ni pipeline and execute
it later in an environment that doesn't have ni or even perl, for example.

Conceptually this is all straightforward: we just need a function that takes a
parsed CLI option and produces the shell command for it. In practice there are
some surrounding complexities:

| 1. Some processes require configuration via stdin; for example, Ruby if
     we want to preload a library like spreadsheet.rb without writing to the
     filesystem (since spreadsheet.rb is probably too big for the command
     line).
  2. We want data and bandwidth monitoring at each pipeline stage, as well as
     bottleneck detection. This means we need to insert filter processes.
  3. Sometimes we'll have command failovers and such, e.g. if /usr/bin/less is
     unavailable.

Constraint (1) means we'll need to compile a whole pipeline, not just an
individual command. (2) and (3) can be done by modifying the pipeline before
we compile it.

package ni;

Simple constructors.
Constructors for straightforward pipeline elements.

sub shell_quote;
sub shell_quote {join ' ', map /[^-A-Za-z_0-9\/.]/
                                 ? "'" . sgr($_, qr/'/, "'\\''") . "'"
                                 : $_,
                           map ref $_ ? shell_quote @$_ : $_, @_}

sub sh {+{id => shell_quote(@_), exec => [@_]}}

Pipeline data format.
Pipelines can be described as JSON arrays of command objects. The schema looks
like this:

| pipeline = [command1, command2, ...]
  command = {
    id: "ls -l foo",
    exec: ["/bin/sh", "-c", ["/bin/ls", "-l", "/tmp/foo"]],
    env: {"HOME": "/home/spencer"},
    stdin: "heredoc-string ...",                // large string
    files: {
      "/tmp/foo": "file-contents...",           // large string
      ...
    },
    meta: {
      // random stuff
    }
  }

The `exec` list is really a string, but with the exception that any array will
have each entry shell-quoted. You can nest arrays if you want a string of
shell-quoted sub-items, etc. The only reason it's done this way is to make
pipeline metaprogramming easier; otherwise you'd have to implement a
shell-unquoter if you wanted to know the arguments to a command.

use constant none => {};

sub heredoc_terminator {
  my $id = 0;
  ++$id while $_[1] =~ /^_$_[0]_$id$/m;
  "_$_[0]_$id";
}

sub compile_pipeline {
  my %file_inits;
  my @commands;
  my @heredocs;

  for my $i (0..$#_) {
    my $c = $_[$i];
    exists $c->{$_} or die "compile_pipeline: must specify $_" for qw/exec id/;

    my $redirections;
    if (exists $c->{stdin}) {
      my $h = heredoc_terminator $i, $c->{stdin};
      push @heredocs, "$c->{stdin}\n$h";
      $redirections = "3<&0 <<\'$h\'";
    }

    $file_inits{$_} = $c->{files}{$_} for keys %{$c->{files} || none};
    my @env = map "$_=" . shell_quote($c->{env}{$_}), keys %{$c->{env} || none};
    push @commands, join " ", @env, shell_quote(@{$c->{exec}}), $redirections;
  }

  my $mkdirs = keys %file_inits
               ? 'mkdir -p ' . shell_quote map /^(.*)\/[^\/]*$/,
                                           keys %file_inits
               : '';

  my $cats   = join "\n", map {
                 my $h = heredoc_terminator '', $file_inits{$_};
                 "cat > " . shell_quote($_) . " <<'$h'\n$file_inits{$_}\n$h"
               } keys %file_inits;

  my $libs   = join "\n", @ni::self{grep /\.sh$/, sort keys %ni::self};
  my $pipe   = join "\\\n  | ", @commands;
  my $docs   = join "\n", @heredocs;
  join "\n", $libs, $mkdirs, $cats, $pipe, $docs;
}
