Command-line option parser.
A context-aware command line parser, which in a Canard-powered world works as
the reader. Certain static symbols, despite being resolved at runtime, have
read-time parse semantics that make it possible for ni syntax to be as
expressive as (and often much more than) nfu. See design/cli.md for details.

package ni::cli;

This is implemented using parser combinators. %syntax_elements is an alias
table so we can describe operator syntax using just strings. %operator_syntax
maps short operator names to a string description of how to parse them; for
example:

| $operator_syntax{T} = 'rowspec';
  $syntax_elements{rowspec} = sub { ... };

Quasifiles are parsed with early preference using subs from @quasifile_parsers;
functionally it's interpreted as a choice that happens _before_ option parsing
happens, unless the option is prefixed with '-'. This means that in the event
of something ambiguous, e.g. `ni f00`, where `f00` is the name of a file, the
file interpretation will be preferred. If you want to force the option
interpretation, you need to say `ni -f00`.

our %syntax_elements;
our %operator_syntax;
our @quasifile_parsers;

sub seq {
  my @ps = @_;
  sub {
    my @args = @_;
    my @xs;
    (($_, @args) = &$_(@args)) ? push @xs, $_ : return () for @ps;
    \@xs, @args;
  };
}

sub alt {
  my @ps = @_;
  sub {
    my @r;
    @r = &$_(@_) and return @r for @ps;
  };
}

use POSIX qw/dup2/;

if (-t STDIN) {
  print STDERR "TODO: print usage\n";
  exit 2;
}

Fork a system shell process using a pipe for input.

pipe(my $r, my $w) or die "failed to pipe: $!";

if (my $pid = fork) {
  close STDOUT;
  close $r;
} else {
  close $w;
  close STDIN;
  dup2 fileno($r), 0 or die "failed to dup2 " . fileno($r) . ": $!";
  exec '/bin/sh' or die "failed to create executor shell: $!";
}

while (@ARGV) {
  my $arg = shift @ARGV;
  if ($arg =~ /^-m(.*)$/s) {
    my $code = length($1) ? $1 : shift @ARGV;
    $code =~ s/'/'\''/g;

    my $command =
      ruby . " -e 'Kernel.eval \$stdin.read' '$code' 3<&0 <<'EOF' |\n"
           . $ni::self{'spreadsheet.rb'}
           . "\nEOF\n"
           . pager . "\n";
    syswrite $w, $command;
  } else {
    print STDERR "ni: unknown argument $arg\n";
  }
}

syswrite $w, $_ while sysread STDIN, $_, 8192;
close $w;
close STDIN;

waitpid $pid, 0;
