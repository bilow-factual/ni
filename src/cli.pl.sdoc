CLI parser generator.
ni's CLI grammar is interesting because it maintains the same basic structure
across a number of different interpretation contexts. For example, the main CLI
arguments are interpreted as local/POSIX stuff, but if you create a JVM Spark
context then the same grammar will host a series of modified operators that
compile into Java/Scala code instead. The invariant parts of this are factored
into a function that produces a CLI grammar with mutable long/short mappings
(which can be modified using 'deflong' and 'defshort' below).

TODO: rewrite all of this

our %contexts;

sub context($) {my ($c, $p) = split /\//, $_[0]; $contexts{$c}{$p}}

sub defcontext($) {
  my $short = {};
  my $long  = [];
  my $r = $contexts{$_[0]} = {};
  $$r{ops} = sub {$$r{ops}->(@_)};

  $$r{longs}  = $long;
  $$r{shorts} = $short;

  $$r{long}   = altr @$long;
  $$r{short}  = chaltr %$short;
  $$r{lambda} = alt mr '_', pn 1, mrc '\[', $$r{ops}, mr '\]';
  $$r{thing}  = alt $$r{lambda}, $$r{long}, $$r{short};
  $$r{suffix} = rep $$r{thing}, 1;
  $$r{op}     = pn 1, rep(consumed_opt), $$r{thing}, rep(consumed_opt);
  $$r{ops}    = rep $$r{op};
  $$r{cli}    = pn 0, $$r{ops}, end_of_argv;
  $$r{cli_d}  = $$r{ops};
}

defcontext 'root';

sub defshort($$$) {
  die "ni: redefining existing short operator $_[1] (use rmshort first)"
    if exists $contexts{$_[0]}{shorts}{$_[1]};
  $contexts{$_[0]}{shorts}{$_[1]} = $_[2];
}

sub rmshort($) {delete $contexts{$_[0]}{shorts}{$_[1]}}

sub deflong($$$) {unshift @{$contexts{$_[0]}{longs}}, $_[2]}
