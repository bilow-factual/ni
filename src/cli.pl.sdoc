Command-line option parser.
A context-aware command line parser, which in a Canard-powered world works as
the reader. Certain static symbols, despite being resolved at runtime, have
read-time parse semantics that make it possible for ni syntax to be as
expressive as (and often much more than) nfu. See design/cli.md for details.

package ni;

This is implemented using parser combinators. %syntax_elements is an alias
table so we can describe operator syntax using just strings. %operator_syntax
maps short operator names to a string description of how to parse them; for
example:

| $operator_syntax{T} = 'rowspec';
  $syntax_elements{rowspec} = sub { ... };

Quasifiles are parsed with early preference using subs from
@quasifile_parsers; functionally it's interpreted as a choice that happens
_before_ option parsing happens, unless the option is prefixed with '-'. This
means that in the event of something ambiguous, e.g. `ni f00`, where `f00` is
the name of a file, the file interpretation will be preferred. If you want to
force the option interpretation, you need to say `ni -f00`.

our %syntax_elements;
our %operator_syntax;
our @quasifile_parsers;

A parse state is just a modified copy of @ARGV, including string
transformations. For example:

| $ ni foo m'r a + b' T4
  # initial parse state is ("foo", "mr a + b", "T4")
  # quasifile parse step consumes "foo", so we then have ("mr a + b", "T4")
  # quasifile parse step rejects ("mr a + b", "T4") by returning ()
  # long option parsers all reject ("mr a + b", "T4")
  # short option parser "m" happens:
  #   m -> ruby-code
  #   ruby-code is run on ("r a + b", "T4") and returns (code, "T4")
  #     (had the code ended in extra ] characters, the parser would have
  #      returned those separately, e.g. (code, "]", "T4"))
  # ...

This might seem like it would be slow, but most of the overhead lives in
high-throughput native functions that are unlikely to take up much time in
practice.

use constant nil => sub {(undef, @_)};

sub seq {
  my @ps = @_;
  sub {my @args = @_;
       my @xs;
       (($_, @args) = &$_(@args)) ? push @xs, $_ : return () for @ps;
       (\@xs, @args)}}

sub alt {
  my @ps = @_;
  sub {my @r;
       @r = &$_(@_) and return @r for @ps}}

sub r0;
sub r0 {alt seq($_[0], r0 $_[0]), nil}
sub r1 {seq $_[0], r0 $_[0]}

Match/consume regex.
You can specify a match group if you want to save (i.e. not consume) part of
the string. For example, to assert that `m` can be parsed only when followed
by one or more characters (but to leave those characters for the next parse
stage):

| seq mr('^m(.+)'), parse_the_grouped_stuff...

It's important to anchor the regex; otherwise the match could begin anywhere
within the first argument.

sub mr {
  my $r = qr/$_[0]/;
  sub {my ($x, @xs) = @_;
       $x =~ s/($r)/$2/ ? ($1, $x, @xs) : ()}}

Character dispatch.
This is just a way to bypass a lot of the alt() overhead that would otherwise
result to decode a high-entropy stream of text. The most obvious case is short
option parsing.

| chp(a => seq(...), b => ..., ...)
  # functionally the same as alt(seq(mr('^a', seq(...))),
  #                              seq(mr('^b', ...)),
  #                              ...)

sub chp {
  my %ps = @_;
  sub {my ($x, @xs) = @_;
       return () unless $x =~ s/^(.)// && exists $ps{$1};
       my @ys = $ps{$1}->($x, @xs);
       @ys ? ([$1, $ys[0]], @ys[1..$#ys]) : ()}}

Parse result transformation.
Allows you to modify the result of a parse stage: a monadic map.

sub pmap(&$) {
  my ($f, $p) = @_;
  sub {my @xs = &$p(@_);
       @xs ? (&$f($xs[0]), @xs[1..$#xs]) : ()}}

Original code...
=====================================================================

use POSIX qw/dup2/;

if (-t STDIN) {
  print STDERR "TODO: print usage\n";
  exit 2;
}

Fork a system shell process using a pipe for input.

pipe(my $r, my $w) or die "failed to pipe: $!";

if (my $pid = fork) {
  close STDOUT;
  close $r;
} else {
  close $w;
  close STDIN;
  dup2 fileno($r), 0 or die "failed to dup2 " . fileno($r) . ": $!";
  exec '/bin/sh' or die "failed to create executor shell: $!";
}

while (@ARGV) {
  my $arg = shift @ARGV;
  if ($arg =~ /^-m(.*)$/s) {
    my $code = length($1) ? $1 : shift @ARGV;
    $code =~ s/'/'\''/g;

    my $command =
      ruby . " -e 'Kernel.eval \$stdin.read' '$code' 3<&0 <<'EOF' |\n"
           . $ni::self{'spreadsheet.rb'}
           . "\nEOF\n"
           . pager . "\n";
    syswrite $w, $command;
  } else {
    print STDERR "ni: unknown argument $arg\n";
  }
}

syswrite $w, $_ while sysread STDIN, $_, 8192;
close $w;
close STDIN;

waitpid $pid, 0;
