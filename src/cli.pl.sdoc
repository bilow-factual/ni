Command-line option parser.
A context-aware command line parser, which in a Canard-powered world works as
the reader. Certain static symbols, despite being resolved at runtime, have
read-time parse semantics that make it possible for ni syntax to be as
expressive as (and often much more than) nfu. See design/cli.md for details.

package ni;

A parse state is just a modified copy of @ARGV, including string
transformations. For example:

| $ ni foo m'r a + b' T4
  # initial parse state is ("foo", "mr a + b", "T4")
  # quasifile parse step consumes "foo", so we then have ("mr a + b", "T4")
  # quasifile parse step rejects ("mr a + b", "T4") by returning ()
  # long option parsers all reject ("mr a + b", "T4")
  # short option parser "m" happens:
  #   m -> ruby-code
  #   ruby-code is run on ("r a + b", "T4") and returns (code, "T4")
  #     (had the code ended in extra ] characters, the parser would have
  #      returned those separately, e.g. (code, "]", "T4"))
  # ...

This might seem like it would be slow, but most of the overhead lives in
high-throughput native functions that are unlikely to take up much time in
practice.

sub seqr {
  my ($ps) = @_;
  sub {my ($x, @xs, @ys);
       (($x, @_) = &$_(@_)) ? push @xs, $x : return () for @$ps;
       (\@xs, @_)}}

sub altr {
  my ($ps) = @_;
  sub {my @r; @r = &$_(@_) and return @r for @$ps; ()}}

sub seq {seqr [@_]}
sub alt {altr [@_]}

sub rep {
  my ($p, $n) = (@_, 0);
  sub {my (@c, @r);
       push @r, $_ while ($_, @_) = &$p(@c = @_);
       @r >= $n ? (\@r, @c) : ()}}

sub maybe {
  my ($p) = @_;
  sub {my @xs = &$p(@_); @xs ? @xs : (undef, @_)}};

Match/consume regex.
You can specify a match group if you want to save (i.e. not consume) part of
the string. For example, to assert that `m` can be parsed only when followed
by one or more characters (but to leave those characters for the next parse
stage):

| seq mr('^m(.+)'), parse_the_grouped_stuff...

It's important to anchor the regex; otherwise the match could begin anywhere
within the first argument.

sub mr {
  my $r = qr/$_[0]/;
  sub {my ($x, @xs) = @_;
       $x =~ s/($r)/$2/ ? ($1, $x, @xs) : ()}}

Character dispatch.
This is just a way to bypass a lot of the alt() overhead that would otherwise
result to decode a high-entropy stream of text. The most obvious case is short
option parsing.

| chp(a => seq(...), b => ..., ...)
  # functionally the same as alt(seq(mr('^a', seq(...))),
  #                              seq(mr('^b', ...)),
  #                              ...)

sub chpr {
  my ($ps) = @_;
  sub {my ($x, @xs, $c, @ys) = @_;
       return () unless $x =~ s/^(.)// && exists $$ps{$c = $1};
       (@ys = $$ps{$c}($x, @xs)) ? ([$c, $ys[0]], @ys[1..$#ys]) : ()}}

sub chp {chpr {@_}}

Parse result transformation.
Allows you to modify the result of a parse stage: a monadic map.

sub pmap(&$) {
  my ($f, $p) = @_;
  sub {my @xs = &$p(@_);
       @xs ? (&$f($_ = $xs[0]), @xs[1..$#xs]) : ()}}

CLI option parsing.
%syntax_elements is an alias table so we can describe operator syntax using
just strings. %operator_syntax maps short operator names to a string
description of how to parse them; for example:

| $operator_syntax{T} = 'rowspec';
  $syntax_elements{rowspec} = sub { ... };

Quasifiles are parsed with early preference using subs from
@quasifile_parsers; functionally it's interpreted as a choice that happens
_before_ option parsing happens, unless the option is prefixed with '-'. This
means that in the event of something ambiguous, e.g. `ni f00`, where `f00` is
the name of a file, the file interpretation will be preferred. If you want to
force the option interpretation, you need to say `ni -f00`.

our %syntax_elements;
our %operator_syntax;
our @quasifile_parsers;

use constant end_of_argv  => sub {@_           ? () : (0)};
use constant consumed_opt => sub {length $_[0] ? () : @_};
use constant short_opt    => $syntax_elements{short} = chpr \%operator_syntax;
use constant op           => $syntax_elements{op}
                           = seq maybe(consumed_opt),
                                 alt altr(\@quasifile_parsers), short_opt;

use constant cli          => seq rep(op), end_of_argv;

$operator_syntax{m}   = mr '.*';
$operator_syntax{p}   = mr '.*';
$operator_syntax{'-'} = short_opt;

push @quasifile_parsers, pmap {{file => $_}} mr '^/\w+';

use JSON;
print encode_json([cli->(@ARGV)]), "\n";
exit 0;
