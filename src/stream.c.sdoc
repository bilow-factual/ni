Stream implementation.
Stream buffers are circular, with the "read pointer" always behind the "fill
pointer" in modular space. Stream capacities are always powers of two, so all
modular arithmetic is done by masking.

#include <errno.h>
#include <string.h>
#include <unistd.h>


void ni_stream_init(ni_stream *const s)
{
  s->fd = -1;
  s->read_errno = s->buffer_capacity_log
                = s->read_offset = s->fill_offset
                = s->bytes = s->ms = 0;
  s->buffer   = 0;
}


void ni_stream_free(ni_stream *const s)
{
  if (s->buffer) free(s->buffer);
  free(s);
}


Resize the buffer, but preserve data. This resets the stream's read offset to
0. You can't resize a buffer to be smaller than the stream's available data; if
you really want to do this, use ni_stream_accept(available) first.

bool ni_stream_resize_buffer(ni_stream *const s, int const log)
{
  if (log == s->buffer_capacity_log) return true;

  size_t const new_size  = 1 << log;
  size_t const available = ni_stream_available(s);
  char *new_buffer;

  if (new_size < available)             return false;
  if (!(new_buffer = malloc(new_size))) return false;
  ni_stream_copy_into(new_buffer, s, 0, available);

  free(s->buffer);
  s->buffer              = new_buffer;
  s->buffer_capacity_log = log;
  s->read_offset         = 0;
  s->fill_offset         = available;
  return true;
}


bool ni_stream_issplit(ni_stream const *const s)
  { return s->fill_offset < s->read_offset; }


void ni_stream_accept(ni_stream *const s, size_t const n)
{
  ni_assert_nope(n <= ni_stream_available(s),
    "ni is trying to accept %llu bytes, more than the %llu available "
    "in the stream.\n",
    ni_ull(n),
    ni_ull(ni_stream_available(s)));
  s->read_offset = s->read_offset + n & (1 << s->buffer_capacity_log) - 1;
  if (s->read_offset == s->fill_offset) s->read_offset = s->fill_offset = 0;
}


size_t ni_stream_available(ni_stream const *const s)
{
  size_t const size = 1 << s->buffer_capacity_log;
  return s->fill_offset + size - s->read_offset & size - 1;
}


size_t ni_stream_remaining_capacity(ni_stream const *const s)
  { return (1 << s->buffer_capacity_log) - ni_stream_available(s); }


void ni_stream_copy_into(char            *const dest,
                         ni_stream const *const s,
                         off_t            const offset,
                         size_t           const n)
{
  ni_assert_nope(offset + n <= ni_stream_available(s),
    "ni is trying to copy %llu + %llu byte(s) from a stream with only %llu"
    " byte(s) available.\n",
    ni_ull(offset),
    ni_ull(n),
    ni_ull(ni_stream_available(s)));

  if (!ni_stream_issplit(s))
    memcpy(dest, s->buffer + s->read_offset + offset, n);
  else {
    size_t const split = (1 << s->buffer_capacity_log) - s->read_offset;
    memcpy(dest,         s->buffer + s->read_offset, split);
    memcpy(dest + split, s->buffer,                  s->fill_offset);
  }
}


bool ni_stream_eof(ni_stream const *const s)
  { return s->read_errno == NI_ERRNO_EOF; }


Returns true if the stream has an error from the most recent read() call.

bool ni_stream_update_errno(ni_stream *const s,
                            ssize_t    const read_size)
{
  if (read_size > 0) return false;
  s->read_errno = read_size ? errno : NI_ERRNO_EOF;
  return true;
}


TODO: optimize; if the overhead of a read() exceeds that of moving the existing
memory, then move stuff and do a larger contiguous read().

size_t ni_stream_fill(ni_stream *const s, size_t const n)
{
  ni_assert_nope(s->fd >= 0,
    "ni is trying to read from a stream whose file descriptor is"
    " negative (which internally means the stream has no underlying"
    " file or device).");

  if (n > ni_stream_remaining_capacity(s)
      && !ni_stream_resize_buffer(s, ni_cintlog2(n + ni_stream_available(s))))
    return 0;

  if (ni_stream_issplit(s)) {
    ssize_t const r = read(s->fd,
                           s->buffer + s->fill_offset,
                           s->read_offset - s->fill_offset);
    if (ni_stream_update_errno(s, r)) return 0;
    s->fill_offset += r;
    return r;
  } else {
    size_t  const size = 1 << s->buffer_capacity_log;
    ssize_t const r1   = read(s->fd,
                              s->buffer + s->fill_offset,
                              size - s->fill_offset);
    if (ni_stream_update_errno(s, r1))                   return 0;
    if (s->fill_offset = s->fill_offset + r1 & size - 1) return r1;
    if (s->read_offset) {
      ssize_t const r2 = read(s->fd, s->buffer, s->read_offset);
      if (ni_stream_update_errno(s, r2)) return r1;
      s->fill_offset += r2;
      return r1 + r2;
    }
    return r1;
  }
}


ni_stream *ni_fd_stream(int const fd)
{
  ni_stream *const result = malloc(sizeof(ni_stream));
  ni_stream_init(result);
  result->fd = fd;
  return result;
}


int ni_stream_read(ni_stream        *const s,
                   ni_codec const   *const c,
                   ni_stream_packet *const ps,
                   int               const nps,
                   int               const flags)
{
  // TODO
}
