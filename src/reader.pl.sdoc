Canard readers.
ni-canard has two readers, one of which is simple and the other of which is
very subtle and complex. The difference is that the simple reader works on code
stored in files, whereas the subtle+complex one parses command-line options and
needs to work around issues like quotation-mark erasure.

{
package ni::canard;

String reader.
Let's start with this one. Canard has a [straightforward, documented
syntax](https://github.com/spencertipping/canard/tree/master) that involves
symbols, lists, and strings. I've modified that syntax slightly here because we
don't need all of the string alternatives. This one just gives you two:

| 1. Here-strings, e.g. #"EOF \n ... \nEOF
  2. Compact strings, e.g. "foo"

This also provides a more predictable experience, since "foo" is the kind of
string you'd probably expect to write.

sub read_string {
  my @parsed = (native 0);
  while ($_[0] =~ /\G\s*(\[|\]|                         # lists
                         \#"(\S+)\n([\s\S]*?)\n\2|      # here-strings
                         ("(?:[^\\"]|\\.)*)"|           # compact strings
                         [^]["\s][^][\s]*               # symbols
                         )/gx) {
    my ($v, $h, $s1, $s2) = ($1, $2, $3, $4);
    if ($v eq '[') {
      push @parsed, native 0;
    } elsif ($v eq ']') {
      die "too many closing brackets" unless @parsed > 1;
      my $h = pop @parsed;
      $parsed[-1] = cons $parsed[-1], $h;
    } else {
      $parsed[-1] = cons $parsed[-1], length $h  ? string $s1
                                    : length $s2 ? string substr($s2, 1)
                                    :              symbol $v;
    }
  }
  die "not enough closing brackets" if @parsed > 1;
  $parsed[0];
}

CLI reader.
This actually is less complicated than it sounds; the only awkwardness here is
that we need an interpreter instance in order to read the CLI options. We also
have language-specific bracket counters to resolve the close-bracket ambiguity
caused by shell quote erasure.

# TODO

}
