Ni CLI.
Argument parsing logic, stream construction functions, and general terminal
interaction. This is also where the progress reporting logic lives, since it's
primarily a frontend feature.

Operator arguments are parsed using a simple grammar comprised of a sequence of
these elements:

| * = string: consume one arg, or the rest of the short arg
  . = string: consume one arg, or one character from the short arg
  ? = optional string: don't consume if next arg is an operator, consume short
  L = ni lambda; if short, parse one char; else take an arg
  S = size = int with suffix (same short and long)
  N = integer
  R = row-spec (for take and drop)
  F = field-spec (for address)
  c = optional code prefix flag
  j = optional join prefix flag

typedef struct ni_stream* (*cli_stream_op)(struct ni_stream *s,
                                           int               argc,
                                           char const       *argv);
typedef struct {
  char        short_form;
  char const *long_form;
  char const *args;
  char const *description;
  cli_stream_op op;
} cli_stream_option;

static cli_stream_option const cli_options[] = {
  {'a', "aggregate",  "L",  "aggregate rows by first field", },
  {'b', "buffer",     "S",  "preload data into memory"},
  {'B', "diskbuffer", "S",  "preload data through disk"},
  {'c', "count",      "",   "'uniq -c' for addressed columns"},
  {'C', "clojure",    "C*", "pipe through clojure"},
  {'D', "duplicate",  "*",  "duplicate into quasifile"},
  {'e', "encode",     "*",  "generate binary data with codec"},
  {'E', "decode",     "*",  "parse binary data with codec"},
  {'f', "fields",     "n",  "reorder, drop, create fields"},
  {'F', "fieldsplit", "S",  "split into columns on regexp"},
  {'g', "group",      "",   "group rows by addressed columns"},
  {'G', "grep",       "*",  "pipe through egrep"},
  {'H', "hadoop",     "LL", "hadoop streaming; emits hdfs qfile"},
  {'i', "into",       "?",  "write to qfile, emit qfile name"},
  {'I', "from",       "",   "read from qfiles in stream"},
  {'j', "join",       "j*", "join against qfile"},
  {'J', "java",       "C*", "pipe through java"},
  {'k', "constant",   ".",  "emit a constant value"},
  {'M', "octave",     "C*", "pipe through octave"},
  {'n', "number",     "",   "prepend line number"},
  {'o', "order",      "",   "order rows by addressed columns"},
  {'O', "rorder",     "",   "reverse order"},
  {'p', "perl",       "C*", "pipe through perl"},
  {'P', "python",     "C*", "pipe through python"},
  {'q', "sql",        ".*", "sqlite3 query with transient table"},
  {'Q', "psql",       ".*", "postgres query with transient table"},
  {'r', "ruby",       "C*", "pipe through ruby"},
  {'R', "R",          "C*", "pipe through R"},
  {'s', "sum",        "",   "running sum"},
  {'S', "delta",      "",   "delta (inverts sum)"},
  {'t', "take",       "R",  "take selected lines"},
  {'T', "tcp",        "NL", "TCP server"},
  {'u', "uniq",       "",   "'uniq' for addressed columns"},
  {'v', "vertical",   "",   "chop line into multiple lines"},
  {'V', "horizontal", "",   "join lines when addressed field is blank"},
  {'x', "canard",     "C*", "pipes through canard"},
  {'X', "shell",      "C*", "pipes through shell command"},
  {'z', "zip",        "*",  "zip columns from specified qfile"},
  {'Z', "scala",      "C*", "pipe through scala"},
  {':', "conf",       "*",  "set configuration variable"},
  {'@', "address",    "F",  "set address of next command"},
  {'^', "prepend",    "*",  "prepends qfile to stream"},
  {'[', "begin",      "",   "push new stream onto stack"},
  {']', "end",        "",   "pop stream, append to current"},
};

#define for_cli_options(i) \
  for (int i = 0; i < sizeof(cli_options) / sizeof(cli_stream_option); ++i)

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define EXIT_NORMAL       0
#define EXIT_USER_ERROR   1
#define EXIT_SYSTEM_ERROR 2

void usage(void) {
  for_rs_parts(qusage, i) fprintf(stderr, "%s\n", qusage[i]);
  for_cli_options(i)
    fprintf(stderr, "  -%c|--%-10s  | %-2s | %s\n",
                    cli_options[i].short_form,
                    cli_options[i].long_form,
                    cli_options[i].args,
                    cli_options[i].description);
  fprintf(stderr, "\n");
}

#define die(...) \
  do { \
    fprintf(stderr, "ni: " __VA_ARGS__); \
    exit(EXIT_SYSTEM_ERROR); \
  } while (0);

int main(int const argc, char const *const *argv) {
  if (unlink(argv[0])) die("unlink failed for %s", argv[0]);
  if (unlink(argv[1])) die("unlink failed for %s", argv[1]);

  int const stdin_tty = isatty(STDIN_FILENO);
  if (argc == 2 && stdin_tty) {
    usage();
    return EXIT_USER_ERROR;
  }

  if (argc == 3 && !strcmp(argv[2], "--self")) {
    for_rs_parts(qni_header_sh, i) printf("%s\n", qni_header_sh[i]);
    printf("awk '");
    for_rs_parts(qdecompress_awk, i) printf("%s\n", qdecompress_awk[i]);
    printf("' <<'EOF'\n");
    for_rs_names(i) {
      int nparts = 0;
      for_rs_parts(rs[i], j) nparts = j + 1;
      printf("%d %s\n", nparts, rn[i]);
      for_rs_parts(rs[i], j) printf("%s\n", rs[i][j]);
    }
    printf("EOF\n");
    for_rs_parts(qni_footer_sh, i) printf("%s\n", qni_footer_sh[i]);
    return EXIT_NORMAL;
  }

  fprintf(stderr, "TODO: implement CLI\n");
  return 1;
}
