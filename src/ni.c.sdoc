Ni source code.
The source code has a heap and GC, a basic object system, some reflection
stuff, a stream abstraction, a runtime for Canard, and TODO. In-code comments
are minimized because ni is shipped as self-compiling source and we don't want
to weigh it down with documentation.

I need the project before it's done, so these variables govern which versions
of various features get compiled:

#define NI_STATUS_REFHEAP 0
#define NI_STATUS_STREAMS 0
#define NI_STATUS_STREAMHACK_MVP 1
#define NI_STATUS_QUASIFILE 0
#define NI_STATUS_QUASIFILEHACK_MVP 1

Implementation plan.
For my benefit: I need to figure out dependencies to get the order right.

| quasifiles   shell + regexp (+ streams for compression; see below)
  explain      streams
  opt          streams + gc?
  canard       refheap + gc

TODO: how to deal with compressed data? nfu used file extensions, but I think
we're better off using magic detection -- which means streams need to support
peeking -- which means we need streams.



#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

void ni_image_begin(void) {}

#define NI_EXIT_NORMAL       0
#define NI_EXIT_USER_ERROR   1
#define NI_EXIT_SYSTEM_ERROR 2
#define NI_EXIT_NI_BUG       3

#if NI_STATUS_REFHEAP

Reference type (heap) implementation.
ni references are 64-bit values that have a number of interpretations depending
on certain high-order bits. Floating-point values are unboxed, so all
alternative interpretations are encoded as NaN cases:

typedef uint64_t ni_v;

void *ni_heap_start;
void *ni_heap_next;
void *ni_heap_limit;

#define NI_NAN_MASK  0x7ff0000000000000ull
#define NI_TYPE_MASK 0x000f000000000000ull
#define NI_DATA_MASK 0x0000ffffffffffffull

#define NI_TYPE_DBL  0  /* actual NaN value or real double */
#define NI_TYPE_PTR  1  /* pointer to something in the heap */
#define NI_TYPE_FN   2  /* pointer to native function */
#define NI_TYPE_I48  3  /* immediate 48-bit unsigned integer */
#define NI_TYPE_SM   4  /* small immediate thing */

#define ni_vdata(x) ((x) & NI_DATA_MASK)
#define ni_vptr_addr(x) (ni_heap_start             + ni_vdata(x))
#define ni_fptr_addr(x) ((void*) (&ni_image_begin) + ni_vdata(x))

int ni_vtype(const ni_v x) {
  return (x & NI_NAN_MASK) == NI_NAN_MASK
       ? NI_TYPE_DBL
       : (int) ((x & NI_TYPE_MASK) >> 48);
}

Some notes here. These types store data in the low 48 bits of the value, which
is smaller than the address space on some systems. If the kernel/linker spread
stuff out, we could run out of ways to reach everything. As a result, all
pointers are relative to something. `NI_TYPE_PTR` is relative to the start of
the heap, and `NI_TYPE_FN` is relative to `&ni_image_begin` (which will be
close to other functions on every sane platform).

TODO: figure out semnatics for bytecode, and figure out how to engineer this
such that the bytecode hosts the GC and related machinery. Then we get better
data structure reuse.

#endif

Main function.
The entry point for the CLI, and associated parsers/etc.

#if NI_STATUS_QUASIFILEHACK_MVP

int ni_quasifile_fd(const char *qf) {
  /* For now just support normal files. */
  
}

#endif

#if 0

If we don't have streams, then we can't store the representation of parsed CLI
args. In this case we approximate by fork/chaining stuff. Each CLI argument
causes a fork to happen, and we capture its stdout fd to either pipe into
stdout, or to redirect into a pager.

int ni_parse_args(const int argc, const char **argv) {
  int read_fd = isatty(STDIN_FILENO) ? -1 : STDIN_FILENO;
  for (int i = 0; i < argc; ++i) {
    int fds[2];
    if (pipe(fds)) {
      fprintf(stderr, "pipe() error: %d\n", errno);
      exit(NI_EXIT_SYSTEM_ERROR);
    }

    if (argv[i][0] != '-') {
      /* We have a quasifile; get a fd for it. */

    }
  }
}

#endif

void ni_usage(void) {
  fprintf(stderr, "TODO: print usage\n");
}

#define die(...) \
  do { \
    fprintf(stderr, __VA_ARGS__); \
    exit(NI_EXIT_SYSTEM_ERROR); \
  } while (0);

int main(const int argc, const char *const *argv) {
  /* Any arguments? If not, and if stdin is a TTY, then print usage; the user
   * should be using cat instead. */
  const int stdin_tty = isatty(STDIN_FILENO);
  if (argc == 1 && stdin_tty) {
    ni_usage();
    return 1;
  }

  if (unlink(argv[0])) die("unlink failed for %s", argv[0]);
  if (unlink(argv[1])) die("unlink failed for %s", argv[1]);
  fprintf(stderr, "zomg, this works\n");

#if NI_STATUS_STREAMHACK_MVP
  /*int fd = ni_parse_args(argc, argv);*/
  return 0;
#endif

#if NI_STATUS_STREAMS
  /* At this point it's a legitimate usage. The initial stream should read
   * stdin if it's redirected; otherwise we just use the empty stream. */
  ni_stream *in = stdin_tty ? ni_empty_stream() : ni_fd_stream(STDIN_FILENO);

  /* Forward the stream to the output. If a TTY, redirect into the pager. */
  ni_stream *out = ni_fd_stream(STDOUT_FILENO);
  if (isatty(STDOUT_FILENO))
    /* Figure out which process is the pager by trial and error. If we have an
     * env-var $PAGER, use that. */
    (out = ni_process_stream(getenv("PAGER"), NULL, out))
      || (out = ni_process_stream("less", NULL, ni_fd_stream(STDOUT)))
      || (out = ni_process_stream("more", NULL, ni_fd_stream(STODUT)));

  /* TODO: parse arguments */
  return ni_connect(in, out);
#endif
}
