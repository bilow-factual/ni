Ni source code.
The source code has a heap and GC, a basic object system, some reflection
stuff, a stream abstraction, a runtime for Canard, and TODO. In-code comments
are minimized because ni is shipped as self-compiling source and we don't want
to weigh it down with documentation.

#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

void ni_image_begin(void) {}

#define NI_EXIT_NORMAL     0
#define NI_EXIT_USER_ERROR 1
#define NI_EXIT_NI_BUG     2

Reference type (heap) implementation.
ni references are 64-bit values that have a number of interpretations depending
on certain high-order bits. Floating-point values are unboxed, so all
alternative interpretations are encoded as NaN cases:

typedef uint64_t ni_v;

void *ni_heap_start;
void *ni_heap_next;
void *ni_heap_limit;

#define NI_NAN_MASK  0x7ff0000000000000ull
#define NI_TYPE_MASK 0x000f000000000000ull
#define NI_DATA_MASK 0x0000ffffffffffffull

#define NI_TYPE_DBL  0  /* actual NaN value or real double */
#define NI_TYPE_PTR  1  /* pointer to something in the heap */
#define NI_TYPE_FN   2  /* pointer to native function */
#define NI_TYPE_I48  3  /* immediate 48-bit unsigned integer */
#define NI_TYPE_SM   4  /* small immediate thing */

#define ni_vdata(x) ((x) & NI_DATA_MASK)
#define ni_vptr_addr(x) (ni_heap_start             + ni_vdata(x))
#define ni_fptr_addr(x) ((void*) (&ni_image_begin) + ni_vdata(x))

int ni_vtype(const ni_v x) {
  return (x & NI_NAN_MASK) == NI_NAN_MASK
       ? NI_TYPE_DBL
       : (int) ((x & NI_TYPE_MASK) >> 48 & 0xf);
}

Some notes here. These types store data in the low 48 bits of the value, which
is smaller than the address space on some systems. If the kernel/linker spread
stuff out, we could run out of ways to reach everything. As a result, all
pointers are relative to something. `NI_TYPE_PTR` is relative to the start of
the heap, and `NI_TYPE_FN` is relative to `&ni_image_begin` (which will be
close to other functions on every sane platform).

Main function.
The entry point for the CLI, and associated parsers/etc.

void ni_usage(void) {}

int main(const int argc, const char *const *argv) {
  /* Any arguments? If not, and if stdin is a TTY, then print usage; the user
   * should be using cat instead. */
  const int stdin_tty = isatty(STDIN_FILENO);
  if (argc == 1 && stdin_tty) {
    ni_usage();
    return 1;
  }

  return 0;

#if 0
  /* At this point it's a legitimate usage. The initial stream should read
   * stdin if it's redirected; otherwise we just use the empty stream. */
  ni_stream *in = stdin_tty ? ni_empty_stream() : ni_fd_stream(STDIN_FILENO);

  /* Forward the stream to the output. If a TTY, redirect into the pager. */
  ni_stream *out = ni_fd_stream(STDOUT_FILENO);
  if (isatty(STDOUT_FILENO))
    /* Figure out which process is the pager by trial and error. If we have an
     * env-var $PAGER, use that. */
    (out = ni_process_stream(getenv("PAGER"), NULL, out))
      || (out = ni_process_stream("less", NULL, ni_fd_stream(STDOUT)))
      || (out = ni_process_stream("more", NULL, ni_fd_stream(STODUT)));

  /* TODO: parse arguments */
  return ni_connect(in, out);
#endif
}
