Codecs.
Codecs are specifications about how to handle data; the idea is very similar to
Perl's pack() and unpack(), but with better support for text. Codecs are also
used as a simple type system for stream packets, which allows any packet to be
printed in human-readable form and transported efficiently.

The idea is that you're starting with unstructured bytes and want to end up
with a tabular format consisting of a series of records, each containing one or
more fields. This is done by writing a codec that "cuts" the bytes into
records. Fields are inferred by looking at the structure of the result.

Codecs are designed to be able to preparse simple languages like TSV, CSV, XML,
and most binary formats. They're deliberately uncomplicated because they need
to be invertible. Internally, codecs are compiled into a simple bytecode that
ni interprets against buffer contents to form packets. ni_read_stream
implements the bytecode interpreter.

Before getting into the details, here are some examples of codecs:

| ni_compile_codec("C|'\t*!|'\n")       // TSV parser
  ni_compile_codec("C*!|'\n")           // unparsed lines of text
  ni_compile_codec("D!*")               // one binary double per record
  ni_compile_codec("C16SSLQ3LS6!")      // Elf64_Ehdr binary structure

Basic elements.
Codecs have some control structures like | and *, but fundamentally they
consist of the following type elements:

| C  8-bit integer as a character (may contain nulls)
  D  IEEE-754 double in binary format
  F  IEEE-754 single in binary format
  L  32-bit unsigned integer, little endian
  l  32-bit unsigned integer, big endian
  Q  64-bit unsigned integer, little endian
  q  64-bit unsigned integer, big endian
  S  16-bit unsigned integer, little endian
  s  16-bit unsigned integer, big endian

| h  hex-encoded integer as text (repeat count determines #bits)
  o  octal-encoded integer as text
  d  decimal-encoded integer as text
  f  double as text

Control structures.
Each control structure is a postfix operator:

| |d    repeat until and consume delimiter d or EOF
  <d    repeat until but not including delimiter d
  >d    repeat until and consume delimiter d
  N     repeat decimal-encoded int N times
  *     repeat until EOF
  ?     make optional: if EOF, accept empty
  !     cut record
  #     discard record, start new cut
  @     set absolute offset after next record cut
  %     set relative offset after next record cut

Delimiters can be any of the following:

| xHH      two hex digits: match a specific byte
  'C       a single non-null byte
  "str"    a string of non-null bytes
  [chars]  a regex-style character class
  (...)    the concatenation of delimiters ("foo" == ('f 'o 'o))

For example, to emit the URL of an HTTP GET request as a record:

| ni_compile_codec("C4# C|\" HTTP\"!")

Offsets are forward-only and anything you skip is forgotten from the stream. If
you need to keep the content, you should decode it as a sequence of characters
and buffer it into a packet.

Regular expression-like things.
Codecs provide a couple of elements similar to things you get in regular
expressions; this makes it possible to use them to decode more complex
structures like simple JSON arrays and well-formed XML.

| [chars]  regex-style character class; used to assert and fail
  (a,b,c)  regex-style alternatives; if a fails, then b, etc

Backtracking tends to be fast because all repetition operators are
deterministic; that is, every codec runs in linear time. For example, this
codec decodes a JSON array of numbers, one per record:

| ni_compile_codec("[[]# ((d,f)!|',)>']")

Each alternative group prepends a codec index to the decoded-field list. This
is really useful because it makes it possible to re-encode decoded results. But
it's worth knowing about because if you decode a JSON string with the above
codec you'll get output like this:

| 1     5.0
  1     3.14
  0     7
  1     -1.0

Codec execution.
Codecs have two distinct phases of execution. For the decoding case (which is
optimized heavily), the stream is quickly split into unparsed records. Records
are decoded using sub-codecs when their fields are accessed; when possible,
field positions are indexed to provide constant-time and zero-copy lookups.

typedef struct {
  // TODO
} ni_codec;
