Codec compiler.
Codecs are specifications about how to handle data; the idea is very similar to
Perl's pack() and unpack(), but with better support for text. Codecs are used
as a simple type system for stream packets, which allows any packet to be
printed in human-readable form.

Codecs are written in a simple declarative language that compiles into
invertible bytecode. The result is that every codec defines both encoding and
decoding simultaneously. Although encoding inverts decoding, decoding does not
always invert encoding due to delimited values (i.e. you could have placed a
delimiter into a string, which would then change the decoding).

The basic operations are:

| primitive encode/decode (e.g. short, long, float, double)
  cut record
  read delimited
  set offset (relative or absolute, buffering or losing data)
  repeat something N times
  repeat something until EOF

Codecs always work in terms of records and fields. If you run ni on unformatted
data, it uses a TSV codec (here the \n and \t are actually single bytes, not
C-style escapes):

| a\n:a\t*!*

This can be read as, "take newline-delimited strings as records, and within
each record take tab-delimited strings as fields."

Likewise, ni also supports binary data with the use of fixed-width encoding
operators. For example, if you want to read doubles in groups of 8 from a
binary file:

| D@8!*

Codecs can also specify what happens in the event of partial reads. In the
8-double example above, no partial record will be generated if an early EOF
happens; that data will be rejected and left for whoever else wants to try to
decode it. If you want to consume partial records, use the greedy-optional
operator:

| D@?8!*

This means, "consume unless EOF" and as used here will cause fewer fields to be
cut for short records. (EOF is a final condition, so the results don't become
nondeterministic or anything.)

#include <sys/types.h>

#define NI_CODEC_FIXED_SIZE           1
#define NI_CODEC_USES_DELIMITERS      2
#define NI_CODEC_FORCES_EOF           4
#define NI_CODEC_USES_BUFFERING_SEEKS 8
#define NI_CODEC_USES_ABSOLUTE_SEEKS  16

typedef struct {
  int                    flags;
  size_t                 size;
  unsigned char const   *bytecode;
  struct ni_codec const *cut_references;
} ni_codec;

Bytecode.
This bytecode is interpreted by ni_stream_read.

| take N        takes N bytes into the current context
  seek N        seeks by relative (signed) offset
  delimit C     take up to and including character C or EOF
  cut K         cuts a record with codec index K
  goto-eof L    bump instruction pointer by L if EOF
  goto-noeof L  bump instruction pointer by L unless EOF

Each bytecode operand is encoded as a 16-bit integer that may be signed or
unsigned. Operands immediately follow bytecodes. Bytecodes themselves are
numbered in a compact range to make it easier for C to optimize a switch() over
them.

typedef enum {
  NI_CB_TAKE,
  NI_CB_SEEK,
  NI_CB_DELIMIT,
  NI_CB_CUT,
  NI_CB_GOTO_EOF,
  NI_CB_GOTO_NOEOF,
} ni_codec_bytecode;

Errno values for codec compilation.
On error, ni_compile_codec will return NULL and set errno to one of the
following values:

| NI_CODEC_ESYNTAX: some kind of syntax error
  NI_CODEC_ENREC:   illegal nested record cut (i.e. inside record
                    interpretation)
  NI_CODEC_ENFIELD: illegal nested field cut

#define NI_CODEC_ESYNTAX (-1)
#define NI_CODEC_ENREC   (-2)
#define NI_CODEC_ENFIELD (-3)

ni_codec *ni_compile_codec(char const *s);
void ni_free_codec(ni_codec *c);
