Codecs.
Codecs are reversible programs that assign formats to data, often examining the
data in the process. They record all decisions made during execution into a
separate stream, which means that no information is lost while they run.
Conceptually, here's the dataflow of decoding a stream:

| codec -> ni_compile_codec
                      \
                       \
  input_stream --> ni_decode --> output_packets
                  /      \  \
  codec_state ----        \  --> aux_stream
                           \
                            ---> codec_state

Here's what that looks like in code:

| ni_codec       *c = ni_compile_codec("codec string");
  ni_codec_state *s = ni_codec_init_state(c);
  ni_stream  *input = ...;
  ni_stream    *aux = ni_buffer_stream(1024 * 64);
  ni_packet ps[64];
  int packets = ni_decode(c, s, input, aux, ps,
                          sizeof(ps) / sizeof(ni_packet));
  if (packets < 0)
    // error; "packets" will contain a code explaining what went wrong
    // you'll need to handle some of these, like aux overflows
  else
    for (int i = 0; i < packets; ++i)
      do_something_with(ps[i]);

Codec language.
Codecs are written in a concatenative combinatory language resembling a cross
between regular expressions, pack() templates, and Joy. The easiest way to
describe the semantics is probably to start with regular expressions and change
the following:

| 1. Appropriate [] to mean lambda, not a character class.
  2. Change the semantics of * to prevent repeat-count backtracking.
  3. Remove lazy repetition operators.
  4. Appropriate most letters to mean fixed-width storage types.
  5. Appropriate various symbols to do codec-specific things.

For example, here's how TSV is parsed with a regular expression, assuming two
special (R...) and (F...) constructs to emit records/fields:

| compile_regex("(R(F[^\t\n]*)*\n)*")

The codec would look like this:

| ni_compile_codec("C>'\t@>'\n!*")

You can read the codec from left to right like this:

| C    = 8-bit char
  >'\t = repeat until \t or end
  @    = emit a field
  >'\n = repeat until \n or end
  !    = emit a record
  *    = repeat until end

Example: parsing JSON.
Codecs are Turing-complete and can parse much more complex structures than
regular expressions or pack() templates. For example, the following codec
parses JSON (albeit more slowly than a probabilistic algorithm):

| ni_compile_codec(
    "[object | array | string | number | bool | null]:json "
    "['{ (string ': json ',?)* '}]:object "
    "['[ (json ',?)* ']]:array "
    "['\" (C-('\\|'\")*('\\C)*)* '\"]:string "
    "[f]:number "
    "[\"false\" | \"true\"]:bool "
    "[\"null\"]:null "
    "json!*")

This parser emits a lot of data to the aux stream to encode things like repeat
counts, branch identifiers, etc. As a result, the parsed record will be
hierarchically navigable -- though probably not in the most useful way. Here's
some of what's going on:

| [...]:json           = create a named subroutine
  x | y | z ...        = alternatives, just like regular expressions
  '{                   = match literal {, reject otherwise
  (string ': json ',?) = match a string, literal :, json, optional literal ,
  '\"                  = match literal "
  C-('\\|'\")          = match any byte that isn't \ or "
  '\\C                 = literal \ followed by any byte
  [f]                  = text-encoded double float
  \"false\"            = the literal char sequence "false"

The parser above has two significant limitations:

| 1. It makes no attempt to interpret most values. String escapes aren't
     evaluated, for example.
  2. It doesn't map anything to actual data structures; you'll have to dig
     through the parse tree if you want to access stuff.

Codecs aren't really built to work around things like this, since the goal is
to assign an interpretation to data in-place rather than actually rewriting it.

Example: parsing Linux ELF64 binary.
Relevant structure definitions from elf(5) on Linux/amd64:

| #define EI_NIDENT 16
  typedef struct {
    unsigned char e_ident[EI_NIDENT];
    uint16_t      e_type;
    uint16_t      e_machine;
    uint32_t      e_version;
    Elf64_Addr    e_entry;      // uint64_t
    Elf64_Off     e_phoff;      // uint64_t
    Elf64_Off     e_shoff;      // uint64_t
    uint32_t      e_flags;
    uint16_t      e_ehsize;
    uint16_t      e_phentsize;
    uint16_t      e_phnum;
    uint16_t      e_shentsize;
    uint16_t      e_shnum;
    uint16_t      e_shstrndx;
  } Elf64_Ehdr;
  typedef struct {
    uint32_t   p_type;
    uint32_t   p_flags;
    Elf64_Off  p_offset;
    Elf64_Addr p_vaddr;
    Elf64_Addr p_paddr;
    uint64_t   p_filesz;
    uint64_t   p_memsz;
    uint64_t   p_align;
  } Elf64_Phdr;
  typedef struct {
    uint32_t   sh_name;
    uint32_t   sh_type;
    uint64_t   sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off  sh_offset;
    uint64_t   sh_size;
    uint32_t   sh_link;
    uint32_t   sh_info;
    uint64_t   sh_addralign;
    uint64_t   sh_entsize;
  } Elf64_Shdr;

ELF parsing involves some interesting stuff because of the flexibility of the
format. Because ni streams are forward-only, we need to use seek queues rather
than trying to parse things in place.
