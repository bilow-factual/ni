Codecs.
Codecs are specifications about how to handle data; the idea is very similar to
Perl's pack() and unpack(), but with better support for text. Codecs are also
used as a simple type system for stream packets, which allows any packet to be
printed in human-readable form and transported efficiently.

The idea is that you're starting with unstructured bytes and want to end up
with a tabular format consisting of a series of records, each containing one or
more fields. This is done by writing a codec that "cuts" the bytes into
records. Fields are inferred by looking at the structure of the result.

Codecs are designed to be able to preparse simple languages like TSV, CSV, XML,
and most binary formats. They're deliberately uncomplicated because they need
to be invertible. Internally, codecs are compiled into a simple bytecode that
ni interprets against buffer contents to form packets. ni_read_stream
implements the bytecode interpreter.

Before getting into the details, here are some examples of codecs:

| ni_compile_codec("C|'\t*!|'\n")       // TSV parser
  ni_compile_codec("C*!|'\n")           // unparsed lines of text
  ni_compile_codec("D!*")               // one binary double per record
  ni_compile_codec("C16SSLQ3LS6!")      // Elf64_Ehdr binary structure

Basic elements.
Codecs have some control structures like | and *, but fundamentally they
consist of the following type elements:

| C  8-bit integer as a character (may contain nulls, single field on repeat)
  c  8-bit integer as an integer (like C but splits fields on repeat)
  U  UTF-8 character (single string field on repeat)
  D  native binary double float (probably IEEE-754)
  F  native binary single float (probably IEEE-754)
  L  32-bit unsigned integer
  l  32-bit signed integer
  Q  64-bit unsigned integer
  q  64-bit signed integer
  S  16-bit unsigned integer
  s  16-bit signed integer

Integer types use native endianness, but you can use a < prefix to force
big-endian and a > to force little-endian.

| h  hex-encoded integer as text (repeat count determines #bits)
  o  octal-encoded integer as text
  d  decimal-encoded integer as text
  f  double as text

Control structures.
Each control structure is a postfix operator:

| |d    repeat until and consume delimiter d or EOF
  *<d   repeat until but not including delimiter d
  *>d   repeat until and consume delimiter d
  N     repeat decimal-encoded int N times
  *     repeat until EOF
  ?     make optional: if EOF, accept empty
  !     cut record
  #     discard record, start new cut
  :N    store field's integer value in register N
  +N    relative offset by value of register N

TODO: fix offset and register commands. We need to be able to handle stuff like
ELF headers, etc, which are complicated. For example, do we parse shdrs or
phdrs first? It depends on which is lower if our cursor is forward-only.

Oh! Use a seek queue! Offset commands enqueue addresses into a minheap that
will dictate where the next record will start. By default the record cut
enqueues the "current offset" if repeated. Maybe think about the details here,
but I think the idea is right.

TODO: how is it possible to invert offsets? We know they're forward-only, so
maybe we can derive the offsets by looking at the way records are packed; then
"label this" means "get ready to write the actual offset", and "offset" means
"write the current location back to the label". (This actually works nicely
because we can just use the same registers and store the location to write the
address as the register's value.)

It seems like a few things still aren't quite right. Record-cut is potentially
an awkward operator.

Delimiters can be any of the following:

| xHH      two hex digits: match a specific byte
  'C       a single non-null byte
  "str"    a string of non-null bytes
  [chars]  a regex-style character class
  (...)    the concatenation of delimiters ("foo" == ('f 'o 'o))

For example, to emit the URL of an HTTP GET request as a record:

| ni_compile_codec("C4# C|\" HTTP\"!")

Offsets are forward-only and anything you skip is forgotten from the stream. If
you need to keep the content, you should decode it as a sequence of characters
and buffer it into a packet.

Regular expression-like things.
Codecs provide a couple of elements similar to things you get in regular
expressions; this makes it possible to use them to decode more complex
structures like simple JSON arrays and well-formed XML.

| [chars]  regex-style character class; used to assert and fail
  (a,b,c)  regex-style alternatives; if a fails, then b, etc

Character classes are valid only inside an alternative group. Backtracking
tends to be fast because all repetition operators are deterministic; that is,
every codec runs in linear time. For example, this codec decodes a JSON array
of numbers, one per record:

| ni_compile_codec("C# ((d,f)!|',)>']")

Each alternative group prepends a codec index to the decoded-field list. This
is really useful because it makes it possible to re-encode decoded results. But
it's worth knowing about because if you decode a JSON string with the above
codec you'll get output like this:

| 1     5.0
  1     3.14
  0     7
  1     -1.0

Grouping and field splitting.
After unrolling, each "fundamental thing" is split into a field. A "fundamental
thing" is either a conversion directive like S, D, etc, or a paren group. Field
splits are inferred by the compiler and are designed to correspond to data
structures you'll be able to use. For example:

| D8            8 fields, each a double
  C8            one field, an 8-byte array
  d8            8 fields, each an int64
  (C8D)8        8 fields, each an undecoded struct { char[8], double }
  (C8D)*        N fields, each an undecoded struct { char[8], double }
  C|'\t         N fields, each a byte array

Here's how types are mapped:

| C<repeat>     = byte[] (string if it's possible without UTF-8 decoding)
  U<repeat>     = string with UTF-8 characters
  D,F,S,s,...   = primitive numbers
  SLQ           = tuple(int16, int32, int64)
  S2LQ          = tuple(int16, int16, int32, int64)
  C64D          = tuple(byte[64], double)
  (x)           = tuple(x)
  (x)5          = tuple(x, x, x, x, x)
  (xyz)         = tuple(x, y, z)
  x*            = tuple(x, x, ..., x)
  x?            = tuple(x) | tuple()
  (x,y,z)       = tuple(0, x...) | tuple(1, y...) | tuple(2, z...)

Codec execution.
Codecs have two distinct phases of execution. For the decoding case (which is
optimized heavily), the stream is quickly split into unparsed records. Records
are decoded using sub-codecs when their fields are accessed; when possible,
field positions are indexed to provide constant-time and zero-copy lookups.

Although ni thinks in terms of records and fields, a codec is fundamentally
hierarchical set of byte ranges that are interpreted as you request fields.

typedef struct ni_codec_fieldspec {
  uint32_t offset;
  uint32_t size;
} ni_codec_fieldspec;

struct ni_codec_bytecode;
typedef struct ni_codec_bytecode ni_codec_bytecode;

Field position caching.
Ok, this is a little complicated but ultimately worth it. The goal here is to
store as much as possible in the codec itself since that's just written once.
We can do this in some cases because some fields have constant width; e.g.
(D8S8) is always 64 + 16 bytes.

Things get complicated if fixed-width fields are mixed with delimited things.

#define NI_CODEC_FIXEDSIZE    1
#define NI_CODEC_HAS_MAX_SIZE 2

#define NI_CODEC_SUBSIZE_CACHE 64

typedef struct ni_codec {
  int                     flags;
  int                     n_subs;
  struct ni_codec const **subs;


} ni_codec;

struct ni_stream_packet;

ni_codec *ni_codec_compile(char const *s);
void      ni_codec_free   (ni_codec *c);

int ni_codec_fields(ni_codec                const *c,
                    struct ni_stream_packet const *p);

ni_codec_fieldspec ni_codec_field(ni_codec                const *c,
                                  struct ni_stream_packet const *p,
                                  int                            n);

Executing bytecode always returns the offset at which the execution ended. You
can use this for each record's fields to extract field offsets.

off_t ni_codec_run(ni_codec_bytecode const *b,
                   char              const *data1,
                   size_t                   data1_size,
                   char              const *data2,
                   size_t                   data2_size);
