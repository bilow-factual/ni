Faceting functions.
Functions that operate on a single facet, which is defined by the first column
value. Mnemonics:

| fe: facet each (side-effects for each value, streaming)
  fr: facet reduce (streaming, n-ary)

sub fe(&) {my ($k, $f, $x) = (a, @_);
           $x = &$f, rl while defined and a eq $k;
           push @q, $_ if defined;
           $x}

sub fr(&@) {my ($k, $f, @xs) = (a, @_);
            @xs = &$f(@xs), rl while defined and a eq $k;
            push @q, $_ if defined;
            @xs}

Compound reductions.
Suppose you want to calculate, in parallel, the sum of one column and the mean
of another. You can't use two separate `fr` calls since the first one will
force the whole stream. Instead, you need a way to build a single compound
function that maintains the two separate state elements. That's what `fc`
(facet compound) is about.

In fast languages we could probably get away with some nice combinatory stuff
here, but this is performance-critical and Perl isn't fast. So I'm making some
epic use of codegen and `eval` to help Perl be all it can be. We end up
compiling into a single function body for an `fr` call, which is then mapped
through a finalizer to eliminate intermediate states.

sub fsum($)  {+{reduce => gen "%1 + ($_[0])",
                init   => [0],
                end    => gen '%1'}}

sub fmean($) {+{reduce => gen "%1 + ($_[0]), %2 + 1",
                init   => [0, 0],
                end    => gen '%1 / (%2 || 1)'}}

sub fmin($)  {+{reduce => gen "defined %1 ? min %1, ($_[0]) : ($_[0])",
                init   => [undef],
                end    => gen '%1'}}

sub fmax($)  {+{reduce => gen "defined %1 ? max %1, ($_[0]) : ($_[0])",
                init   => [undef],
                end    => gen '%1'}}

sub farr($)  {+{reduce => gen "[\@{%1}, ($_[0])]",
                init   => [[]],
                end    => gen '%1'}}

sub rfn($$)  {+{reduce => gen $_[0],
                init   => [@_[1..$#_]],
                end    => gen join ', ', map "%$_", 1..$#_}}

sub compound_facet(@) {
  local $_;
  my $slots = 0;
  my @indexes = map {my $n = @{$$_{init}}; $slots += $n; $slots - $n} @_;
  my @mapping = map {my $i = $_;
                     [map {;$_ => sprintf "\$_[%d]", $indexes[$i] + $_ - 1}
                          1..@{$_[$i]{init}}]} 0..$#_;
  +{init   => [map @{$$_{init}}, @_],
    reduce => join(', ', map $_[$_]{reduce}->(@{$mapping[$_]}), 0..$#_),
    end    => join(', ', map $_[$_]{end}->(@{$mapping[$_]}),    0..$#_)}
}

sub fc(@) {
  my %c      = %{compound_facet @_};
  my $reduce = eval "sub{\n($c{reduce})\n}" or die "fc: '$c{reduce}': $@";
  my $end    = eval "sub{\n($c{end})\n}"    or die "fc: '$c{end}': $@";
  &$end(fr {$reduce->(@_)} @{$c{init}});
}
