Faceting functions.
Functions that operate on a single facet, which is defined by the first column
value. Mnemonics:

| fe: facet each (side-effects for each value, streaming)
  fr: facet reduce (streaming, n-ary)

sub fe(&) {my ($k, $f, $x) = (a, @_);
           $x = &$f, rl while defined and a eq $k;
           push @q, $_ if defined;
           $x}

sub fr(&@) {my ($k, $f, @xs) = (a, @_);
            @xs = &$f(@xs), rl while defined and a eq $k;
            push @q, $_ if defined;
            @xs}

Compound reductions.
Suppose you want to calculate, in parallel, the sum of one column and the mean
of another. You can't use two separate `fr` calls since the first one will
force the whole stream. Instead, you need a way to build a single compound
function that maintains the two separate state elements. That's what `fc`
(facet compound) is about.

In fast languages we could probably get away with some nice combinatory stuff
here, but this is performance-critical and Perl isn't fast. So I'm making some
epic use of codegen and `eval` to help Perl be all it can be. We end up
compiling into a single function body for an `fr` call, which is then mapped
through a finalizer to eliminate intermediate states.

sub fsum($)  {+{reduce => gen "%v1 + ($_[0])",
                init   => gen '0',
                n      => 1,
                end    => gen '%v1'}}

sub fmean($) {+{reduce => gen "%v1 + ($_[0]), %v2 + 1",
                init   => gen '0, 0',
                n      => 2,
                end    => gen '%v1 / (%v2 || 1)'}}

sub fmin($)  {+{reduce => gen "defined %v1 ? min %v1, ($_[0]) : ($_[0])",
                init   => gen 'undef',
                n      => 1,
                end    => gen '%v1'}}

sub fmax($)  {+{reduce => gen "defined %v1 ? max %v1, ($_[0]) : ($_[0])",
                init   => gen 'undef',
                n      => 1,
                end    => gen '%v1'}}

sub compound_facet(@) {
  local $_;
  my $slots = 0;
  my @indexes = map {$slots += $$_{n}; $slots - $$_{n}} @_;
  my @mapping = map {my $i = $_;
                     [map {;"v$_" => sprintf "\$_[%d]", $indexes[$i] + $_ - 1}
                          1..$_[$i]{n}]} 0..$#_;

  +{init   => join(', ', map $$_{init}->(), @_),
    reduce => join(', ', map $_[$_]{reduce}->(@{$mapping[$_]}), 0..$#_),
    end    => join(', ', map $_[$_]{end}->(@{$mapping[$_]}),    0..$#_)}
}

sub fc(@) {
  my %c      = %{compound_facet @_};
  my @init   = eval "($c{init})"            or die "fc: '$c{init}': $@";
  my $reduce = eval "sub{\n($c{reduce})\n}" or die "fc: '$c{reduce}': $@";
  my $end    = eval "sub{\n($c{end})\n}"    or die "fc: '$c{end}': $@";
  &$end(fr {$reduce->(@_)} @init);
}
