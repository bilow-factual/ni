JSPlot.
A plotting library that allows you to live-transform the data, and that
supports incremental rendering in not much space.

$(function () {
var w  = $(window);
var c  = $('#c');
var t  = $('#i');
var cx = c[0].getContext('2d');
var wwl, whl;
setInterval(function () {
  var ww = w.width(), wh = w.height();
  if (ww !== wwl || wh !== whl) {
    t.css({width: ww - 2 * t.offset().left});
    c.attr({width: wwl = ww, height: whl = wh});
    refresh();
  }
}, 50);

View coordinates.
vr = view rotation, vp = view position, vs = view scaling. Everything is done
in 3D whether we're looking at 2D or 3D data.

var vr = [0, 0, 0];
var vp = [0, 0, 0];
var vs = [0, 0, 0];

AJAX data requests.
Data comes down in small pieces and is rendered as it arrives. We do this for
two reasons: first, to decrease view latency; and second, to run in constant
space. (The client does store some data, but there's an upper bound on how
much.)

t.keydown(function (e) {if (e.which === 13) refresh()});

var ws = null;
var refresh = function () {
  var ws_url = document.location.href.replace(/^http:/, 'ws:') + 'ni/';
  if (ws != null) ws.close();
  ws = new WebSocket(ws_url + t.val(), 'data');
  cache = [];
  cx.clearRect(0, 0, wwl, whl);
  ws.onmessage = function (e) {collect_point(e.data.split(/\t/))};
};

Rendering logic.
Super simple: [x, y, z] if present. We sample points into a cache and render
everything in timed batches.

var n_points        = 0;
var points_to_cache = 65536;
var cache           = [];
var buffer          = [];
var collect_point = function (p) {
  buffer.push(p);
  ++n_points;
  var i = Math.random() * n_points | 0;
  if (i < points_to_cache) cache[i] = p;
};

setInterval(function () {
  cx.fillStyle = 'rgba(255, 255, 255, 0.5)';
  for (var i = 0; i < buffer.length; ++i)
    cx.fillRect(+buffer[i][0] + wwl/2, +buffer[i][1] + whl/2, 1, 1);
  buffer = [];
}, 50);

refresh();

});
