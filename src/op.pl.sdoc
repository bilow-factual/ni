Operator definition.
Like ni's parser combinators, operators are indirected using names. This
provides an intermediate representation that can be inspected and serialized.

our %operators;
sub defoperator($$) {
  my ($name, $f) = @_;
  die "ni: cannot redefine operator $name" if exists $operators{$name};
  $operators{$name} = fn $f;
  ni::eval "sub ${name}_op(@) {['$name', \@_]}", "defoperator $name";
  ni::eval "sub ${name}_run(@) {\$operators{\$name}->(\@_)}",
           "defoperator $name ($f)";
}

sub operate {
  my ($name, @args) = @_;
  die "ni operate: undefined operator: $name" unless exists $operators{$name};
  $operators{$name}->(@args);
}

sub flatten_operators($) {
  my ($name) = @{$_[0]};
  return $_[0] unless ref $name;
  map flatten_operators($_), @{$_[0]};
}

Ni operators.
Some operators are most easily specified in terms of ni commands.

sub defnioperator($$) {
  my ($name, $op) = @_;
  my ($ops) = cli shell_unquote $op;
  if (!defined $ops) {
    my (undef, @rest) = parse pcli_debug '', shell_unquote $op;
    die "ni: defnioperator parse failed starting at @rest";
  }
  *{"${name}_op"} = sub() {$ops};
}
