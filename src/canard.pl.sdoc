Canard interpreter.
As canard implementations go, this is a fairly pragmatic one optimized to get
ni off the ground while supporting all of the core features of the language.
Perl-callable functions are in the `ni::canard` namespace, whereas
canard->native functions are in `ni::canard::internal` (and are usually defined
with `defnative`).

{
package ni::canard;

Core data constructors.
If you're dealing with an object in canard, it's going to be one of these
types. Natives aren't blessed because they're just integer offsets into the
interpreter's `n` table.

sub native {$_[0] + 0}
sub cons   {bless [$_[0], $_[1]], 'ni::canard::cons'}
sub symbol {bless \$_[0],         'ni::canard::symbol'}
sub string {bless \$_[0],         'ni::canard::string'}

sub interpreter {bless {n => [], d => 0, c => 0, r => 0},
                       'ni::canard::interpreter'}

Core functions.
Structural equality and serialization.

sub eql {
  return 1 if $_[0] eq $_[1];
  my $r = ref $_[0];
  return $_[0] eq $_[1] unless length $r;
  return 0 unless $r eq ref $_[1];
  $r eq 'ni::canard::cons' ? eql(h($_[0]), h($_[1])) && eql(t($_[0]), t($_[1]))
                           : ${$_[0]} eq ${$_[1]};
}

sub str;
sub str {
  my $r = ref $_[0];
  return $_[0] unless length $r;
  return    ${$_[0]}    if $r eq 'ni::canard::symbol';
  return "\"${$_[0]}\"" if $r eq 'ni::canard::string';
  my @xs;
  my $l = $_[0];
  while (ref($l) eq 'ni::canard::cons') {
    push @xs, str $l->[1];
    $l = $l->[0];
  }
  '[' . join(' ', reverse @xs) . ']';
}

List-related functions.
Some shorthands for working with conses. These will fail if any cons holds a
circular reference to another one (which isn't possible with the normal API).

sub h {$_[0] ? $_[0][1] : 0}
sub t {$_[0] ? $_[0][0] : 0}
sub hn; sub hn {my ($xs, $n) = @_; $n ? hn t($xs), $n - 1 : h $xs}
sub tn; sub tn {my ($xs, $n) = @_; $n ? tn t($xs), $n - 1 :   $xs}

sub list {my $r = 0; $r = cons $r, $_ for @_; $r}

sub lsub {
  my ($l, $m) = @_;
  my $r = ref $l;
  return $m->{$$l} if $r eq 'ni::canard::symbol' && exists $m->{$$l};
  return $l    unless $r eq 'ni::canard::cons';
  cons lsub(t($l), $m), lsub(h($l), $m);
}
}
