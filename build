#!/bin/bash
# Builds the ni image from files in src/.
cd $(dirname $0)

# Preprocessor to erase SDoc documentation. This minimizes the image size but
# still makes it possible to document code in some detail.
unsdoc() {
  perl -e 'print join "", map s/^c\n//r,
                          grep !/^\h*[|A-Z]/,
                          split /\n(\h*\n)+/, join "", <>'
}

# Resource format is "<nlines> <filename>\n<data...>", e.g.
#
# 5 foo.pl
# #!/usr/bin/env perl
# # stuff
# while (<>) {
#   print "hi $_";
# }
#
# See src/ni for the logic that parses this from the __DATA__ section.
resource() {
  cd gen
  for r; do
    wc -l $r
    cat $r
  done
  cd ..
}

# SDoc-process all source files into corresponding entries in gen/.
rm -rf gen
mkdir -p gen
for f in $(find src -type f); do
  if [[ "${f%.sdoc}" != $f ]]; then
    sdoc_gen=${f%.sdoc}
    sdoc_gen=gen/${sdoc_gen#src/}
    mkdir -p $(dirname $sdoc_gen)
    unsdoc < $f > $sdoc_gen
  else
    mkdir -p gen/$(dirname ${f#src/})
    cp $f gen/${f#src/}
  fi
done

# Build the ni image by including the header verbatim, then bundling the rest
# of the files as resources. The header knows how to unpack resources from the
# __DATA__ section of the script, and it evaluates the ones ending in .pl. This
# mechanism makes it possible for ni to serialize its code without being stored
# anywhere.
{
  cat gen/ni                    # "eval" the bootstrap code
  resource ni                   # ... and now store so ni can regenerate it
  resource util.pl
  resource sh.pl cli.pl ops.pl

  # Library resources
  resource sh/stream.sh

  resource rb/spreadsheet.rb

  resource waul/caterwaul{,.std,.ui}.min.js
} > ni

chmod +x ni
